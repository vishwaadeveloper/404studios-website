
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model FeatureGroup
 * 
 */
export type FeatureGroup = $Result.DefaultSelection<Prisma.$FeatureGroupPayload>
/**
 * Model Feature
 * 
 */
export type Feature = $Result.DefaultSelection<Prisma.$FeaturePayload>
/**
 * Model FeatureTier
 * 
 */
export type FeatureTier = $Result.DefaultSelection<Prisma.$FeatureTierPayload>
/**
 * Model BusinessType
 * 
 */
export type BusinessType = $Result.DefaultSelection<Prisma.$BusinessTypePayload>
/**
 * Model BusinessTypeDefault
 * 
 */
export type BusinessTypeDefault = $Result.DefaultSelection<Prisma.$BusinessTypeDefaultPayload>
/**
 * Model BusinessTypePage
 * 
 */
export type BusinessTypePage = $Result.DefaultSelection<Prisma.$BusinessTypePagePayload>
/**
 * Model ServiceCategory
 * 
 */
export type ServiceCategory = $Result.DefaultSelection<Prisma.$ServiceCategoryPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model TimeSlot
 * 
 */
export type TimeSlot = $Result.DefaultSelection<Prisma.$TimeSlotPayload>
/**
 * Model ContactFormStep
 * 
 */
export type ContactFormStep = $Result.DefaultSelection<Prisma.$ContactFormStepPayload>
/**
 * Model PricingCalculation
 * 
 */
export type PricingCalculation = $Result.DefaultSelection<Prisma.$PricingCalculationPayload>
/**
 * Model CalculationFeature
 * 
 */
export type CalculationFeature = $Result.DefaultSelection<Prisma.$CalculationFeaturePayload>
/**
 * Model ContactInfo
 * 
 */
export type ContactInfo = $Result.DefaultSelection<Prisma.$ContactInfoPayload>
/**
 * Model ProjectType
 * 
 */
export type ProjectType = $Result.DefaultSelection<Prisma.$ProjectTypePayload>
/**
 * Model BudgetRange
 * 
 */
export type BudgetRange = $Result.DefaultSelection<Prisma.$BudgetRangePayload>
/**
 * Model TimelineOption
 * 
 */
export type TimelineOption = $Result.DefaultSelection<Prisma.$TimelineOptionPayload>
/**
 * Model PackageOption
 * 
 */
export type PackageOption = $Result.DefaultSelection<Prisma.$PackageOptionPayload>
/**
 * Model MigrationLog
 * 
 */
export type MigrationLog = $Result.DefaultSelection<Prisma.$MigrationLogPayload>
/**
 * Model SystemAudit
 * 
 */
export type SystemAudit = $Result.DefaultSelection<Prisma.$SystemAuditPayload>
/**
 * Model FeatureFlag
 * 
 */
export type FeatureFlag = $Result.DefaultSelection<Prisma.$FeatureFlagPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more FeatureGroups
 * const featureGroups = await prisma.featureGroup.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more FeatureGroups
   * const featureGroups = await prisma.featureGroup.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.featureGroup`: Exposes CRUD operations for the **FeatureGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeatureGroups
    * const featureGroups = await prisma.featureGroup.findMany()
    * ```
    */
  get featureGroup(): Prisma.FeatureGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feature`: Exposes CRUD operations for the **Feature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Features
    * const features = await prisma.feature.findMany()
    * ```
    */
  get feature(): Prisma.FeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featureTier`: Exposes CRUD operations for the **FeatureTier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeatureTiers
    * const featureTiers = await prisma.featureTier.findMany()
    * ```
    */
  get featureTier(): Prisma.FeatureTierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.businessType`: Exposes CRUD operations for the **BusinessType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessTypes
    * const businessTypes = await prisma.businessType.findMany()
    * ```
    */
  get businessType(): Prisma.BusinessTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.businessTypeDefault`: Exposes CRUD operations for the **BusinessTypeDefault** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessTypeDefaults
    * const businessTypeDefaults = await prisma.businessTypeDefault.findMany()
    * ```
    */
  get businessTypeDefault(): Prisma.BusinessTypeDefaultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.businessTypePage`: Exposes CRUD operations for the **BusinessTypePage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessTypePages
    * const businessTypePages = await prisma.businessTypePage.findMany()
    * ```
    */
  get businessTypePage(): Prisma.BusinessTypePageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceCategory`: Exposes CRUD operations for the **ServiceCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCategories
    * const serviceCategories = await prisma.serviceCategory.findMany()
    * ```
    */
  get serviceCategory(): Prisma.ServiceCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timeSlot`: Exposes CRUD operations for the **TimeSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeSlots
    * const timeSlots = await prisma.timeSlot.findMany()
    * ```
    */
  get timeSlot(): Prisma.TimeSlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactFormStep`: Exposes CRUD operations for the **ContactFormStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactFormSteps
    * const contactFormSteps = await prisma.contactFormStep.findMany()
    * ```
    */
  get contactFormStep(): Prisma.ContactFormStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pricingCalculation`: Exposes CRUD operations for the **PricingCalculation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PricingCalculations
    * const pricingCalculations = await prisma.pricingCalculation.findMany()
    * ```
    */
  get pricingCalculation(): Prisma.PricingCalculationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calculationFeature`: Exposes CRUD operations for the **CalculationFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalculationFeatures
    * const calculationFeatures = await prisma.calculationFeature.findMany()
    * ```
    */
  get calculationFeature(): Prisma.CalculationFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactInfo`: Exposes CRUD operations for the **ContactInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactInfos
    * const contactInfos = await prisma.contactInfo.findMany()
    * ```
    */
  get contactInfo(): Prisma.ContactInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectType`: Exposes CRUD operations for the **ProjectType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectTypes
    * const projectTypes = await prisma.projectType.findMany()
    * ```
    */
  get projectType(): Prisma.ProjectTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budgetRange`: Exposes CRUD operations for the **BudgetRange** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BudgetRanges
    * const budgetRanges = await prisma.budgetRange.findMany()
    * ```
    */
  get budgetRange(): Prisma.BudgetRangeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timelineOption`: Exposes CRUD operations for the **TimelineOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimelineOptions
    * const timelineOptions = await prisma.timelineOption.findMany()
    * ```
    */
  get timelineOption(): Prisma.TimelineOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.packageOption`: Exposes CRUD operations for the **PackageOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PackageOptions
    * const packageOptions = await prisma.packageOption.findMany()
    * ```
    */
  get packageOption(): Prisma.PackageOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.migrationLog`: Exposes CRUD operations for the **MigrationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MigrationLogs
    * const migrationLogs = await prisma.migrationLog.findMany()
    * ```
    */
  get migrationLog(): Prisma.MigrationLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemAudit`: Exposes CRUD operations for the **SystemAudit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemAudits
    * const systemAudits = await prisma.systemAudit.findMany()
    * ```
    */
  get systemAudit(): Prisma.SystemAuditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featureFlag`: Exposes CRUD operations for the **FeatureFlag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeatureFlags
    * const featureFlags = await prisma.featureFlag.findMany()
    * ```
    */
  get featureFlag(): Prisma.FeatureFlagDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    FeatureGroup: 'FeatureGroup',
    Feature: 'Feature',
    FeatureTier: 'FeatureTier',
    BusinessType: 'BusinessType',
    BusinessTypeDefault: 'BusinessTypeDefault',
    BusinessTypePage: 'BusinessTypePage',
    ServiceCategory: 'ServiceCategory',
    Service: 'Service',
    Contact: 'Contact',
    TimeSlot: 'TimeSlot',
    ContactFormStep: 'ContactFormStep',
    PricingCalculation: 'PricingCalculation',
    CalculationFeature: 'CalculationFeature',
    ContactInfo: 'ContactInfo',
    ProjectType: 'ProjectType',
    BudgetRange: 'BudgetRange',
    TimelineOption: 'TimelineOption',
    PackageOption: 'PackageOption',
    MigrationLog: 'MigrationLog',
    SystemAudit: 'SystemAudit',
    FeatureFlag: 'FeatureFlag'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "featureGroup" | "feature" | "featureTier" | "businessType" | "businessTypeDefault" | "businessTypePage" | "serviceCategory" | "service" | "contact" | "timeSlot" | "contactFormStep" | "pricingCalculation" | "calculationFeature" | "contactInfo" | "projectType" | "budgetRange" | "timelineOption" | "packageOption" | "migrationLog" | "systemAudit" | "featureFlag"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      FeatureGroup: {
        payload: Prisma.$FeatureGroupPayload<ExtArgs>
        fields: Prisma.FeatureGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureGroupPayload>
          }
          findFirst: {
            args: Prisma.FeatureGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureGroupPayload>
          }
          findMany: {
            args: Prisma.FeatureGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureGroupPayload>[]
          }
          create: {
            args: Prisma.FeatureGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureGroupPayload>
          }
          createMany: {
            args: Prisma.FeatureGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatureGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureGroupPayload>[]
          }
          delete: {
            args: Prisma.FeatureGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureGroupPayload>
          }
          update: {
            args: Prisma.FeatureGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureGroupPayload>
          }
          deleteMany: {
            args: Prisma.FeatureGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeatureGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureGroupPayload>[]
          }
          upsert: {
            args: Prisma.FeatureGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureGroupPayload>
          }
          aggregate: {
            args: Prisma.FeatureGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeatureGroup>
          }
          groupBy: {
            args: Prisma.FeatureGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatureGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatureGroupCountArgs<ExtArgs>
            result: $Utils.Optional<FeatureGroupCountAggregateOutputType> | number
          }
        }
      }
      Feature: {
        payload: Prisma.$FeaturePayload<ExtArgs>
        fields: Prisma.FeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          findFirst: {
            args: Prisma.FeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          findMany: {
            args: Prisma.FeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          create: {
            args: Prisma.FeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          createMany: {
            args: Prisma.FeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          delete: {
            args: Prisma.FeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          update: {
            args: Prisma.FeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          deleteMany: {
            args: Prisma.FeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          upsert: {
            args: Prisma.FeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          aggregate: {
            args: Prisma.FeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeature>
          }
          groupBy: {
            args: Prisma.FeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatureCountArgs<ExtArgs>
            result: $Utils.Optional<FeatureCountAggregateOutputType> | number
          }
        }
      }
      FeatureTier: {
        payload: Prisma.$FeatureTierPayload<ExtArgs>
        fields: Prisma.FeatureTierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureTierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureTierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTierPayload>
          }
          findFirst: {
            args: Prisma.FeatureTierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureTierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTierPayload>
          }
          findMany: {
            args: Prisma.FeatureTierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTierPayload>[]
          }
          create: {
            args: Prisma.FeatureTierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTierPayload>
          }
          createMany: {
            args: Prisma.FeatureTierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatureTierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTierPayload>[]
          }
          delete: {
            args: Prisma.FeatureTierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTierPayload>
          }
          update: {
            args: Prisma.FeatureTierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTierPayload>
          }
          deleteMany: {
            args: Prisma.FeatureTierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureTierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeatureTierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTierPayload>[]
          }
          upsert: {
            args: Prisma.FeatureTierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureTierPayload>
          }
          aggregate: {
            args: Prisma.FeatureTierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeatureTier>
          }
          groupBy: {
            args: Prisma.FeatureTierGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatureTierGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatureTierCountArgs<ExtArgs>
            result: $Utils.Optional<FeatureTierCountAggregateOutputType> | number
          }
        }
      }
      BusinessType: {
        payload: Prisma.$BusinessTypePayload<ExtArgs>
        fields: Prisma.BusinessTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload>
          }
          findFirst: {
            args: Prisma.BusinessTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload>
          }
          findMany: {
            args: Prisma.BusinessTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload>[]
          }
          create: {
            args: Prisma.BusinessTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload>
          }
          createMany: {
            args: Prisma.BusinessTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload>[]
          }
          delete: {
            args: Prisma.BusinessTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload>
          }
          update: {
            args: Prisma.BusinessTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload>
          }
          deleteMany: {
            args: Prisma.BusinessTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusinessTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload>[]
          }
          upsert: {
            args: Prisma.BusinessTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePayload>
          }
          aggregate: {
            args: Prisma.BusinessTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessType>
          }
          groupBy: {
            args: Prisma.BusinessTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessTypeCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessTypeCountAggregateOutputType> | number
          }
        }
      }
      BusinessTypeDefault: {
        payload: Prisma.$BusinessTypeDefaultPayload<ExtArgs>
        fields: Prisma.BusinessTypeDefaultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessTypeDefaultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeDefaultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessTypeDefaultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeDefaultPayload>
          }
          findFirst: {
            args: Prisma.BusinessTypeDefaultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeDefaultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessTypeDefaultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeDefaultPayload>
          }
          findMany: {
            args: Prisma.BusinessTypeDefaultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeDefaultPayload>[]
          }
          create: {
            args: Prisma.BusinessTypeDefaultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeDefaultPayload>
          }
          createMany: {
            args: Prisma.BusinessTypeDefaultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessTypeDefaultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeDefaultPayload>[]
          }
          delete: {
            args: Prisma.BusinessTypeDefaultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeDefaultPayload>
          }
          update: {
            args: Prisma.BusinessTypeDefaultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeDefaultPayload>
          }
          deleteMany: {
            args: Prisma.BusinessTypeDefaultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessTypeDefaultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusinessTypeDefaultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeDefaultPayload>[]
          }
          upsert: {
            args: Prisma.BusinessTypeDefaultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypeDefaultPayload>
          }
          aggregate: {
            args: Prisma.BusinessTypeDefaultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessTypeDefault>
          }
          groupBy: {
            args: Prisma.BusinessTypeDefaultGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessTypeDefaultGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessTypeDefaultCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessTypeDefaultCountAggregateOutputType> | number
          }
        }
      }
      BusinessTypePage: {
        payload: Prisma.$BusinessTypePagePayload<ExtArgs>
        fields: Prisma.BusinessTypePageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessTypePageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessTypePageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePagePayload>
          }
          findFirst: {
            args: Prisma.BusinessTypePageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessTypePageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePagePayload>
          }
          findMany: {
            args: Prisma.BusinessTypePageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePagePayload>[]
          }
          create: {
            args: Prisma.BusinessTypePageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePagePayload>
          }
          createMany: {
            args: Prisma.BusinessTypePageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessTypePageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePagePayload>[]
          }
          delete: {
            args: Prisma.BusinessTypePageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePagePayload>
          }
          update: {
            args: Prisma.BusinessTypePageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePagePayload>
          }
          deleteMany: {
            args: Prisma.BusinessTypePageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessTypePageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusinessTypePageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePagePayload>[]
          }
          upsert: {
            args: Prisma.BusinessTypePageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessTypePagePayload>
          }
          aggregate: {
            args: Prisma.BusinessTypePageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessTypePage>
          }
          groupBy: {
            args: Prisma.BusinessTypePageGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessTypePageGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessTypePageCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessTypePageCountAggregateOutputType> | number
          }
        }
      }
      ServiceCategory: {
        payload: Prisma.$ServiceCategoryPayload<ExtArgs>
        fields: Prisma.ServiceCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          findFirst: {
            args: Prisma.ServiceCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          findMany: {
            args: Prisma.ServiceCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          create: {
            args: Prisma.ServiceCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          createMany: {
            args: Prisma.ServiceCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          delete: {
            args: Prisma.ServiceCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          update: {
            args: Prisma.ServiceCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ServiceCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ServiceCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          aggregate: {
            args: Prisma.ServiceCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceCategory>
          }
          groupBy: {
            args: Prisma.ServiceCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      TimeSlot: {
        payload: Prisma.$TimeSlotPayload<ExtArgs>
        fields: Prisma.TimeSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          findFirst: {
            args: Prisma.TimeSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          findMany: {
            args: Prisma.TimeSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>[]
          }
          create: {
            args: Prisma.TimeSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          createMany: {
            args: Prisma.TimeSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeSlotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>[]
          }
          delete: {
            args: Prisma.TimeSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          update: {
            args: Prisma.TimeSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          deleteMany: {
            args: Prisma.TimeSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimeSlotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>[]
          }
          upsert: {
            args: Prisma.TimeSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          aggregate: {
            args: Prisma.TimeSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeSlot>
          }
          groupBy: {
            args: Prisma.TimeSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeSlotCountArgs<ExtArgs>
            result: $Utils.Optional<TimeSlotCountAggregateOutputType> | number
          }
        }
      }
      ContactFormStep: {
        payload: Prisma.$ContactFormStepPayload<ExtArgs>
        fields: Prisma.ContactFormStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFormStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFormStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormStepPayload>
          }
          findFirst: {
            args: Prisma.ContactFormStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFormStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormStepPayload>
          }
          findMany: {
            args: Prisma.ContactFormStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormStepPayload>[]
          }
          create: {
            args: Prisma.ContactFormStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormStepPayload>
          }
          createMany: {
            args: Prisma.ContactFormStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactFormStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormStepPayload>[]
          }
          delete: {
            args: Prisma.ContactFormStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormStepPayload>
          }
          update: {
            args: Prisma.ContactFormStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormStepPayload>
          }
          deleteMany: {
            args: Prisma.ContactFormStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactFormStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactFormStepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormStepPayload>[]
          }
          upsert: {
            args: Prisma.ContactFormStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormStepPayload>
          }
          aggregate: {
            args: Prisma.ContactFormStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactFormStep>
          }
          groupBy: {
            args: Prisma.ContactFormStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactFormStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactFormStepCountArgs<ExtArgs>
            result: $Utils.Optional<ContactFormStepCountAggregateOutputType> | number
          }
        }
      }
      PricingCalculation: {
        payload: Prisma.$PricingCalculationPayload<ExtArgs>
        fields: Prisma.PricingCalculationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PricingCalculationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingCalculationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PricingCalculationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingCalculationPayload>
          }
          findFirst: {
            args: Prisma.PricingCalculationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingCalculationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PricingCalculationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingCalculationPayload>
          }
          findMany: {
            args: Prisma.PricingCalculationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingCalculationPayload>[]
          }
          create: {
            args: Prisma.PricingCalculationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingCalculationPayload>
          }
          createMany: {
            args: Prisma.PricingCalculationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PricingCalculationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingCalculationPayload>[]
          }
          delete: {
            args: Prisma.PricingCalculationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingCalculationPayload>
          }
          update: {
            args: Prisma.PricingCalculationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingCalculationPayload>
          }
          deleteMany: {
            args: Prisma.PricingCalculationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PricingCalculationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PricingCalculationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingCalculationPayload>[]
          }
          upsert: {
            args: Prisma.PricingCalculationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingCalculationPayload>
          }
          aggregate: {
            args: Prisma.PricingCalculationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePricingCalculation>
          }
          groupBy: {
            args: Prisma.PricingCalculationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PricingCalculationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PricingCalculationCountArgs<ExtArgs>
            result: $Utils.Optional<PricingCalculationCountAggregateOutputType> | number
          }
        }
      }
      CalculationFeature: {
        payload: Prisma.$CalculationFeaturePayload<ExtArgs>
        fields: Prisma.CalculationFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalculationFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalculationFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationFeaturePayload>
          }
          findFirst: {
            args: Prisma.CalculationFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalculationFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationFeaturePayload>
          }
          findMany: {
            args: Prisma.CalculationFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationFeaturePayload>[]
          }
          create: {
            args: Prisma.CalculationFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationFeaturePayload>
          }
          createMany: {
            args: Prisma.CalculationFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalculationFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationFeaturePayload>[]
          }
          delete: {
            args: Prisma.CalculationFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationFeaturePayload>
          }
          update: {
            args: Prisma.CalculationFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationFeaturePayload>
          }
          deleteMany: {
            args: Prisma.CalculationFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalculationFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CalculationFeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationFeaturePayload>[]
          }
          upsert: {
            args: Prisma.CalculationFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationFeaturePayload>
          }
          aggregate: {
            args: Prisma.CalculationFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalculationFeature>
          }
          groupBy: {
            args: Prisma.CalculationFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalculationFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalculationFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<CalculationFeatureCountAggregateOutputType> | number
          }
        }
      }
      ContactInfo: {
        payload: Prisma.$ContactInfoPayload<ExtArgs>
        fields: Prisma.ContactInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>
          }
          findFirst: {
            args: Prisma.ContactInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>
          }
          findMany: {
            args: Prisma.ContactInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>[]
          }
          create: {
            args: Prisma.ContactInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>
          }
          createMany: {
            args: Prisma.ContactInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>[]
          }
          delete: {
            args: Prisma.ContactInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>
          }
          update: {
            args: Prisma.ContactInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>
          }
          deleteMany: {
            args: Prisma.ContactInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>[]
          }
          upsert: {
            args: Prisma.ContactInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>
          }
          aggregate: {
            args: Prisma.ContactInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactInfo>
          }
          groupBy: {
            args: Prisma.ContactInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactInfoCountArgs<ExtArgs>
            result: $Utils.Optional<ContactInfoCountAggregateOutputType> | number
          }
        }
      }
      ProjectType: {
        payload: Prisma.$ProjectTypePayload<ExtArgs>
        fields: Prisma.ProjectTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>
          }
          findFirst: {
            args: Prisma.ProjectTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>
          }
          findMany: {
            args: Prisma.ProjectTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>[]
          }
          create: {
            args: Prisma.ProjectTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>
          }
          createMany: {
            args: Prisma.ProjectTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>[]
          }
          delete: {
            args: Prisma.ProjectTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>
          }
          update: {
            args: Prisma.ProjectTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>
          }
          deleteMany: {
            args: Prisma.ProjectTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>[]
          }
          upsert: {
            args: Prisma.ProjectTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>
          }
          aggregate: {
            args: Prisma.ProjectTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectType>
          }
          groupBy: {
            args: Prisma.ProjectTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectTypeCountAggregateOutputType> | number
          }
        }
      }
      BudgetRange: {
        payload: Prisma.$BudgetRangePayload<ExtArgs>
        fields: Prisma.BudgetRangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetRangeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetRangeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRangePayload>
          }
          findFirst: {
            args: Prisma.BudgetRangeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetRangeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRangePayload>
          }
          findMany: {
            args: Prisma.BudgetRangeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRangePayload>[]
          }
          create: {
            args: Prisma.BudgetRangeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRangePayload>
          }
          createMany: {
            args: Prisma.BudgetRangeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetRangeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRangePayload>[]
          }
          delete: {
            args: Prisma.BudgetRangeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRangePayload>
          }
          update: {
            args: Prisma.BudgetRangeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRangePayload>
          }
          deleteMany: {
            args: Prisma.BudgetRangeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetRangeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BudgetRangeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRangePayload>[]
          }
          upsert: {
            args: Prisma.BudgetRangeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetRangePayload>
          }
          aggregate: {
            args: Prisma.BudgetRangeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudgetRange>
          }
          groupBy: {
            args: Prisma.BudgetRangeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetRangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetRangeCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetRangeCountAggregateOutputType> | number
          }
        }
      }
      TimelineOption: {
        payload: Prisma.$TimelineOptionPayload<ExtArgs>
        fields: Prisma.TimelineOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimelineOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimelineOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineOptionPayload>
          }
          findFirst: {
            args: Prisma.TimelineOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimelineOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineOptionPayload>
          }
          findMany: {
            args: Prisma.TimelineOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineOptionPayload>[]
          }
          create: {
            args: Prisma.TimelineOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineOptionPayload>
          }
          createMany: {
            args: Prisma.TimelineOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimelineOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineOptionPayload>[]
          }
          delete: {
            args: Prisma.TimelineOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineOptionPayload>
          }
          update: {
            args: Prisma.TimelineOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineOptionPayload>
          }
          deleteMany: {
            args: Prisma.TimelineOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimelineOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimelineOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineOptionPayload>[]
          }
          upsert: {
            args: Prisma.TimelineOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineOptionPayload>
          }
          aggregate: {
            args: Prisma.TimelineOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimelineOption>
          }
          groupBy: {
            args: Prisma.TimelineOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimelineOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimelineOptionCountArgs<ExtArgs>
            result: $Utils.Optional<TimelineOptionCountAggregateOutputType> | number
          }
        }
      }
      PackageOption: {
        payload: Prisma.$PackageOptionPayload<ExtArgs>
        fields: Prisma.PackageOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackageOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackageOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload>
          }
          findFirst: {
            args: Prisma.PackageOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackageOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload>
          }
          findMany: {
            args: Prisma.PackageOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload>[]
          }
          create: {
            args: Prisma.PackageOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload>
          }
          createMany: {
            args: Prisma.PackageOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PackageOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload>[]
          }
          delete: {
            args: Prisma.PackageOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload>
          }
          update: {
            args: Prisma.PackageOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload>
          }
          deleteMany: {
            args: Prisma.PackageOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackageOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PackageOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload>[]
          }
          upsert: {
            args: Prisma.PackageOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageOptionPayload>
          }
          aggregate: {
            args: Prisma.PackageOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackageOption>
          }
          groupBy: {
            args: Prisma.PackageOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackageOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackageOptionCountArgs<ExtArgs>
            result: $Utils.Optional<PackageOptionCountAggregateOutputType> | number
          }
        }
      }
      MigrationLog: {
        payload: Prisma.$MigrationLogPayload<ExtArgs>
        fields: Prisma.MigrationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MigrationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MigrationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationLogPayload>
          }
          findFirst: {
            args: Prisma.MigrationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MigrationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationLogPayload>
          }
          findMany: {
            args: Prisma.MigrationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationLogPayload>[]
          }
          create: {
            args: Prisma.MigrationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationLogPayload>
          }
          createMany: {
            args: Prisma.MigrationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MigrationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationLogPayload>[]
          }
          delete: {
            args: Prisma.MigrationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationLogPayload>
          }
          update: {
            args: Prisma.MigrationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationLogPayload>
          }
          deleteMany: {
            args: Prisma.MigrationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MigrationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MigrationLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationLogPayload>[]
          }
          upsert: {
            args: Prisma.MigrationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationLogPayload>
          }
          aggregate: {
            args: Prisma.MigrationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMigrationLog>
          }
          groupBy: {
            args: Prisma.MigrationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<MigrationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.MigrationLogCountArgs<ExtArgs>
            result: $Utils.Optional<MigrationLogCountAggregateOutputType> | number
          }
        }
      }
      SystemAudit: {
        payload: Prisma.$SystemAuditPayload<ExtArgs>
        fields: Prisma.SystemAuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemAuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemAuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAuditPayload>
          }
          findFirst: {
            args: Prisma.SystemAuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemAuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAuditPayload>
          }
          findMany: {
            args: Prisma.SystemAuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAuditPayload>[]
          }
          create: {
            args: Prisma.SystemAuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAuditPayload>
          }
          createMany: {
            args: Prisma.SystemAuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemAuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAuditPayload>[]
          }
          delete: {
            args: Prisma.SystemAuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAuditPayload>
          }
          update: {
            args: Prisma.SystemAuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAuditPayload>
          }
          deleteMany: {
            args: Prisma.SystemAuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemAuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemAuditUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAuditPayload>[]
          }
          upsert: {
            args: Prisma.SystemAuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemAuditPayload>
          }
          aggregate: {
            args: Prisma.SystemAuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemAudit>
          }
          groupBy: {
            args: Prisma.SystemAuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemAuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemAuditCountArgs<ExtArgs>
            result: $Utils.Optional<SystemAuditCountAggregateOutputType> | number
          }
        }
      }
      FeatureFlag: {
        payload: Prisma.$FeatureFlagPayload<ExtArgs>
        fields: Prisma.FeatureFlagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureFlagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureFlagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          findFirst: {
            args: Prisma.FeatureFlagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureFlagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          findMany: {
            args: Prisma.FeatureFlagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>[]
          }
          create: {
            args: Prisma.FeatureFlagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          createMany: {
            args: Prisma.FeatureFlagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatureFlagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>[]
          }
          delete: {
            args: Prisma.FeatureFlagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          update: {
            args: Prisma.FeatureFlagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          deleteMany: {
            args: Prisma.FeatureFlagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureFlagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeatureFlagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>[]
          }
          upsert: {
            args: Prisma.FeatureFlagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          aggregate: {
            args: Prisma.FeatureFlagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeatureFlag>
          }
          groupBy: {
            args: Prisma.FeatureFlagGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatureFlagGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatureFlagCountArgs<ExtArgs>
            result: $Utils.Optional<FeatureFlagCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    featureGroup?: FeatureGroupOmit
    feature?: FeatureOmit
    featureTier?: FeatureTierOmit
    businessType?: BusinessTypeOmit
    businessTypeDefault?: BusinessTypeDefaultOmit
    businessTypePage?: BusinessTypePageOmit
    serviceCategory?: ServiceCategoryOmit
    service?: ServiceOmit
    contact?: ContactOmit
    timeSlot?: TimeSlotOmit
    contactFormStep?: ContactFormStepOmit
    pricingCalculation?: PricingCalculationOmit
    calculationFeature?: CalculationFeatureOmit
    contactInfo?: ContactInfoOmit
    projectType?: ProjectTypeOmit
    budgetRange?: BudgetRangeOmit
    timelineOption?: TimelineOptionOmit
    packageOption?: PackageOptionOmit
    migrationLog?: MigrationLogOmit
    systemAudit?: SystemAuditOmit
    featureFlag?: FeatureFlagOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type FeatureGroupCountOutputType
   */

  export type FeatureGroupCountOutputType = {
    features: number
  }

  export type FeatureGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | FeatureGroupCountOutputTypeCountFeaturesArgs
  }

  // Custom InputTypes
  /**
   * FeatureGroupCountOutputType without action
   */
  export type FeatureGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureGroupCountOutputType
     */
    select?: FeatureGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeatureGroupCountOutputType without action
   */
  export type FeatureGroupCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureWhereInput
  }


  /**
   * Count Type FeatureCountOutputType
   */

  export type FeatureCountOutputType = {
    defaults: number
    calculations: number
    tiers: number
  }

  export type FeatureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaults?: boolean | FeatureCountOutputTypeCountDefaultsArgs
    calculations?: boolean | FeatureCountOutputTypeCountCalculationsArgs
    tiers?: boolean | FeatureCountOutputTypeCountTiersArgs
  }

  // Custom InputTypes
  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureCountOutputType
     */
    select?: FeatureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeCountDefaultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessTypeDefaultWhereInput
  }

  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeCountCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalculationFeatureWhereInput
  }

  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeCountTiersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureTierWhereInput
  }


  /**
   * Count Type FeatureTierCountOutputType
   */

  export type FeatureTierCountOutputType = {
    calculations: number
  }

  export type FeatureTierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calculations?: boolean | FeatureTierCountOutputTypeCountCalculationsArgs
  }

  // Custom InputTypes
  /**
   * FeatureTierCountOutputType without action
   */
  export type FeatureTierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureTierCountOutputType
     */
    select?: FeatureTierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeatureTierCountOutputType without action
   */
  export type FeatureTierCountOutputTypeCountCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalculationFeatureWhereInput
  }


  /**
   * Count Type BusinessTypeCountOutputType
   */

  export type BusinessTypeCountOutputType = {
    defaults: number
    pages: number
    calculations: number
  }

  export type BusinessTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaults?: boolean | BusinessTypeCountOutputTypeCountDefaultsArgs
    pages?: boolean | BusinessTypeCountOutputTypeCountPagesArgs
    calculations?: boolean | BusinessTypeCountOutputTypeCountCalculationsArgs
  }

  // Custom InputTypes
  /**
   * BusinessTypeCountOutputType without action
   */
  export type BusinessTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeCountOutputType
     */
    select?: BusinessTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessTypeCountOutputType without action
   */
  export type BusinessTypeCountOutputTypeCountDefaultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessTypeDefaultWhereInput
  }

  /**
   * BusinessTypeCountOutputType without action
   */
  export type BusinessTypeCountOutputTypeCountPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessTypePageWhereInput
  }

  /**
   * BusinessTypeCountOutputType without action
   */
  export type BusinessTypeCountOutputTypeCountCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PricingCalculationWhereInput
  }


  /**
   * Count Type ServiceCategoryCountOutputType
   */

  export type ServiceCategoryCountOutputType = {
    services: number
  }

  export type ServiceCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceCategoryCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryCountOutputType
     */
    select?: ServiceCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    formSteps: number
    calculations: number
    timeSlots: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formSteps?: boolean | ContactCountOutputTypeCountFormStepsArgs
    calculations?: boolean | ContactCountOutputTypeCountCalculationsArgs
    timeSlots?: boolean | ContactCountOutputTypeCountTimeSlotsArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountFormStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactFormStepWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountCalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PricingCalculationWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountTimeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSlotWhereInput
  }


  /**
   * Count Type PricingCalculationCountOutputType
   */

  export type PricingCalculationCountOutputType = {
    features: number
  }

  export type PricingCalculationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | PricingCalculationCountOutputTypeCountFeaturesArgs
  }

  // Custom InputTypes
  /**
   * PricingCalculationCountOutputType without action
   */
  export type PricingCalculationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingCalculationCountOutputType
     */
    select?: PricingCalculationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PricingCalculationCountOutputType without action
   */
  export type PricingCalculationCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalculationFeatureWhereInput
  }


  /**
   * Models
   */

  /**
   * Model FeatureGroup
   */

  export type AggregateFeatureGroup = {
    _count: FeatureGroupCountAggregateOutputType | null
    _avg: FeatureGroupAvgAggregateOutputType | null
    _sum: FeatureGroupSumAggregateOutputType | null
    _min: FeatureGroupMinAggregateOutputType | null
    _max: FeatureGroupMaxAggregateOutputType | null
  }

  export type FeatureGroupAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type FeatureGroupSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type FeatureGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    iconName: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    iconName: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureGroupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    iconName: number
    displayOrder: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeatureGroupAvgAggregateInputType = {
    displayOrder?: true
  }

  export type FeatureGroupSumAggregateInputType = {
    displayOrder?: true
  }

  export type FeatureGroupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    iconName?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureGroupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    iconName?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureGroupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    iconName?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeatureGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureGroup to aggregate.
     */
    where?: FeatureGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureGroups to fetch.
     */
    orderBy?: FeatureGroupOrderByWithRelationInput | FeatureGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeatureGroups
    **/
    _count?: true | FeatureGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatureGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatureGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureGroupMaxAggregateInputType
  }

  export type GetFeatureGroupAggregateType<T extends FeatureGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatureGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatureGroup[P]>
      : GetScalarType<T[P], AggregateFeatureGroup[P]>
  }




  export type FeatureGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureGroupWhereInput
    orderBy?: FeatureGroupOrderByWithAggregationInput | FeatureGroupOrderByWithAggregationInput[]
    by: FeatureGroupScalarFieldEnum[] | FeatureGroupScalarFieldEnum
    having?: FeatureGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureGroupCountAggregateInputType | true
    _avg?: FeatureGroupAvgAggregateInputType
    _sum?: FeatureGroupSumAggregateInputType
    _min?: FeatureGroupMinAggregateInputType
    _max?: FeatureGroupMaxAggregateInputType
  }

  export type FeatureGroupGroupByOutputType = {
    id: string
    name: string
    description: string | null
    iconName: string | null
    displayOrder: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: FeatureGroupCountAggregateOutputType | null
    _avg: FeatureGroupAvgAggregateOutputType | null
    _sum: FeatureGroupSumAggregateOutputType | null
    _min: FeatureGroupMinAggregateOutputType | null
    _max: FeatureGroupMaxAggregateOutputType | null
  }

  type GetFeatureGroupGroupByPayload<T extends FeatureGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureGroupGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureGroupGroupByOutputType[P]>
        }
      >
    >


  export type FeatureGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    iconName?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    features?: boolean | FeatureGroup$featuresArgs<ExtArgs>
    _count?: boolean | FeatureGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featureGroup"]>

  export type FeatureGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    iconName?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["featureGroup"]>

  export type FeatureGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    iconName?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["featureGroup"]>

  export type FeatureGroupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    iconName?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeatureGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "iconName" | "displayOrder" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["featureGroup"]>
  export type FeatureGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | FeatureGroup$featuresArgs<ExtArgs>
    _count?: boolean | FeatureGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeatureGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FeatureGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FeatureGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeatureGroup"
    objects: {
      features: Prisma.$FeaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      iconName: string | null
      displayOrder: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["featureGroup"]>
    composites: {}
  }

  type FeatureGroupGetPayload<S extends boolean | null | undefined | FeatureGroupDefaultArgs> = $Result.GetResult<Prisma.$FeatureGroupPayload, S>

  type FeatureGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatureGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatureGroupCountAggregateInputType | true
    }

  export interface FeatureGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeatureGroup'], meta: { name: 'FeatureGroup' } }
    /**
     * Find zero or one FeatureGroup that matches the filter.
     * @param {FeatureGroupFindUniqueArgs} args - Arguments to find a FeatureGroup
     * @example
     * // Get one FeatureGroup
     * const featureGroup = await prisma.featureGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatureGroupFindUniqueArgs>(args: SelectSubset<T, FeatureGroupFindUniqueArgs<ExtArgs>>): Prisma__FeatureGroupClient<$Result.GetResult<Prisma.$FeatureGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeatureGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatureGroupFindUniqueOrThrowArgs} args - Arguments to find a FeatureGroup
     * @example
     * // Get one FeatureGroup
     * const featureGroup = await prisma.featureGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatureGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatureGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatureGroupClient<$Result.GetResult<Prisma.$FeatureGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatureGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureGroupFindFirstArgs} args - Arguments to find a FeatureGroup
     * @example
     * // Get one FeatureGroup
     * const featureGroup = await prisma.featureGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatureGroupFindFirstArgs>(args?: SelectSubset<T, FeatureGroupFindFirstArgs<ExtArgs>>): Prisma__FeatureGroupClient<$Result.GetResult<Prisma.$FeatureGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatureGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureGroupFindFirstOrThrowArgs} args - Arguments to find a FeatureGroup
     * @example
     * // Get one FeatureGroup
     * const featureGroup = await prisma.featureGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatureGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatureGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatureGroupClient<$Result.GetResult<Prisma.$FeatureGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeatureGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeatureGroups
     * const featureGroups = await prisma.featureGroup.findMany()
     * 
     * // Get first 10 FeatureGroups
     * const featureGroups = await prisma.featureGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featureGroupWithIdOnly = await prisma.featureGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeatureGroupFindManyArgs>(args?: SelectSubset<T, FeatureGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeatureGroup.
     * @param {FeatureGroupCreateArgs} args - Arguments to create a FeatureGroup.
     * @example
     * // Create one FeatureGroup
     * const FeatureGroup = await prisma.featureGroup.create({
     *   data: {
     *     // ... data to create a FeatureGroup
     *   }
     * })
     * 
     */
    create<T extends FeatureGroupCreateArgs>(args: SelectSubset<T, FeatureGroupCreateArgs<ExtArgs>>): Prisma__FeatureGroupClient<$Result.GetResult<Prisma.$FeatureGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeatureGroups.
     * @param {FeatureGroupCreateManyArgs} args - Arguments to create many FeatureGroups.
     * @example
     * // Create many FeatureGroups
     * const featureGroup = await prisma.featureGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatureGroupCreateManyArgs>(args?: SelectSubset<T, FeatureGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeatureGroups and returns the data saved in the database.
     * @param {FeatureGroupCreateManyAndReturnArgs} args - Arguments to create many FeatureGroups.
     * @example
     * // Create many FeatureGroups
     * const featureGroup = await prisma.featureGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeatureGroups and only return the `id`
     * const featureGroupWithIdOnly = await prisma.featureGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatureGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatureGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeatureGroup.
     * @param {FeatureGroupDeleteArgs} args - Arguments to delete one FeatureGroup.
     * @example
     * // Delete one FeatureGroup
     * const FeatureGroup = await prisma.featureGroup.delete({
     *   where: {
     *     // ... filter to delete one FeatureGroup
     *   }
     * })
     * 
     */
    delete<T extends FeatureGroupDeleteArgs>(args: SelectSubset<T, FeatureGroupDeleteArgs<ExtArgs>>): Prisma__FeatureGroupClient<$Result.GetResult<Prisma.$FeatureGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeatureGroup.
     * @param {FeatureGroupUpdateArgs} args - Arguments to update one FeatureGroup.
     * @example
     * // Update one FeatureGroup
     * const featureGroup = await prisma.featureGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatureGroupUpdateArgs>(args: SelectSubset<T, FeatureGroupUpdateArgs<ExtArgs>>): Prisma__FeatureGroupClient<$Result.GetResult<Prisma.$FeatureGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeatureGroups.
     * @param {FeatureGroupDeleteManyArgs} args - Arguments to filter FeatureGroups to delete.
     * @example
     * // Delete a few FeatureGroups
     * const { count } = await prisma.featureGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatureGroupDeleteManyArgs>(args?: SelectSubset<T, FeatureGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeatureGroups
     * const featureGroup = await prisma.featureGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatureGroupUpdateManyArgs>(args: SelectSubset<T, FeatureGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureGroups and returns the data updated in the database.
     * @param {FeatureGroupUpdateManyAndReturnArgs} args - Arguments to update many FeatureGroups.
     * @example
     * // Update many FeatureGroups
     * const featureGroup = await prisma.featureGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeatureGroups and only return the `id`
     * const featureGroupWithIdOnly = await prisma.featureGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeatureGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, FeatureGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeatureGroup.
     * @param {FeatureGroupUpsertArgs} args - Arguments to update or create a FeatureGroup.
     * @example
     * // Update or create a FeatureGroup
     * const featureGroup = await prisma.featureGroup.upsert({
     *   create: {
     *     // ... data to create a FeatureGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeatureGroup we want to update
     *   }
     * })
     */
    upsert<T extends FeatureGroupUpsertArgs>(args: SelectSubset<T, FeatureGroupUpsertArgs<ExtArgs>>): Prisma__FeatureGroupClient<$Result.GetResult<Prisma.$FeatureGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeatureGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureGroupCountArgs} args - Arguments to filter FeatureGroups to count.
     * @example
     * // Count the number of FeatureGroups
     * const count = await prisma.featureGroup.count({
     *   where: {
     *     // ... the filter for the FeatureGroups we want to count
     *   }
     * })
    **/
    count<T extends FeatureGroupCountArgs>(
      args?: Subset<T, FeatureGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeatureGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureGroupAggregateArgs>(args: Subset<T, FeatureGroupAggregateArgs>): Prisma.PrismaPromise<GetFeatureGroupAggregateType<T>>

    /**
     * Group by FeatureGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureGroupGroupByArgs['orderBy'] }
        : { orderBy?: FeatureGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeatureGroup model
   */
  readonly fields: FeatureGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeatureGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    features<T extends FeatureGroup$featuresArgs<ExtArgs> = {}>(args?: Subset<T, FeatureGroup$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeatureGroup model
   */
  interface FeatureGroupFieldRefs {
    readonly id: FieldRef<"FeatureGroup", 'String'>
    readonly name: FieldRef<"FeatureGroup", 'String'>
    readonly description: FieldRef<"FeatureGroup", 'String'>
    readonly iconName: FieldRef<"FeatureGroup", 'String'>
    readonly displayOrder: FieldRef<"FeatureGroup", 'Int'>
    readonly isActive: FieldRef<"FeatureGroup", 'Boolean'>
    readonly createdAt: FieldRef<"FeatureGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"FeatureGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeatureGroup findUnique
   */
  export type FeatureGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureGroup
     */
    select?: FeatureGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureGroup
     */
    omit?: FeatureGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureGroupInclude<ExtArgs> | null
    /**
     * Filter, which FeatureGroup to fetch.
     */
    where: FeatureGroupWhereUniqueInput
  }

  /**
   * FeatureGroup findUniqueOrThrow
   */
  export type FeatureGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureGroup
     */
    select?: FeatureGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureGroup
     */
    omit?: FeatureGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureGroupInclude<ExtArgs> | null
    /**
     * Filter, which FeatureGroup to fetch.
     */
    where: FeatureGroupWhereUniqueInput
  }

  /**
   * FeatureGroup findFirst
   */
  export type FeatureGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureGroup
     */
    select?: FeatureGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureGroup
     */
    omit?: FeatureGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureGroupInclude<ExtArgs> | null
    /**
     * Filter, which FeatureGroup to fetch.
     */
    where?: FeatureGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureGroups to fetch.
     */
    orderBy?: FeatureGroupOrderByWithRelationInput | FeatureGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureGroups.
     */
    cursor?: FeatureGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureGroups.
     */
    distinct?: FeatureGroupScalarFieldEnum | FeatureGroupScalarFieldEnum[]
  }

  /**
   * FeatureGroup findFirstOrThrow
   */
  export type FeatureGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureGroup
     */
    select?: FeatureGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureGroup
     */
    omit?: FeatureGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureGroupInclude<ExtArgs> | null
    /**
     * Filter, which FeatureGroup to fetch.
     */
    where?: FeatureGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureGroups to fetch.
     */
    orderBy?: FeatureGroupOrderByWithRelationInput | FeatureGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureGroups.
     */
    cursor?: FeatureGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureGroups.
     */
    distinct?: FeatureGroupScalarFieldEnum | FeatureGroupScalarFieldEnum[]
  }

  /**
   * FeatureGroup findMany
   */
  export type FeatureGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureGroup
     */
    select?: FeatureGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureGroup
     */
    omit?: FeatureGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureGroupInclude<ExtArgs> | null
    /**
     * Filter, which FeatureGroups to fetch.
     */
    where?: FeatureGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureGroups to fetch.
     */
    orderBy?: FeatureGroupOrderByWithRelationInput | FeatureGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeatureGroups.
     */
    cursor?: FeatureGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureGroups.
     */
    skip?: number
    distinct?: FeatureGroupScalarFieldEnum | FeatureGroupScalarFieldEnum[]
  }

  /**
   * FeatureGroup create
   */
  export type FeatureGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureGroup
     */
    select?: FeatureGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureGroup
     */
    omit?: FeatureGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a FeatureGroup.
     */
    data: XOR<FeatureGroupCreateInput, FeatureGroupUncheckedCreateInput>
  }

  /**
   * FeatureGroup createMany
   */
  export type FeatureGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeatureGroups.
     */
    data: FeatureGroupCreateManyInput | FeatureGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatureGroup createManyAndReturn
   */
  export type FeatureGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureGroup
     */
    select?: FeatureGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureGroup
     */
    omit?: FeatureGroupOmit<ExtArgs> | null
    /**
     * The data used to create many FeatureGroups.
     */
    data: FeatureGroupCreateManyInput | FeatureGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatureGroup update
   */
  export type FeatureGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureGroup
     */
    select?: FeatureGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureGroup
     */
    omit?: FeatureGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a FeatureGroup.
     */
    data: XOR<FeatureGroupUpdateInput, FeatureGroupUncheckedUpdateInput>
    /**
     * Choose, which FeatureGroup to update.
     */
    where: FeatureGroupWhereUniqueInput
  }

  /**
   * FeatureGroup updateMany
   */
  export type FeatureGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeatureGroups.
     */
    data: XOR<FeatureGroupUpdateManyMutationInput, FeatureGroupUncheckedUpdateManyInput>
    /**
     * Filter which FeatureGroups to update
     */
    where?: FeatureGroupWhereInput
    /**
     * Limit how many FeatureGroups to update.
     */
    limit?: number
  }

  /**
   * FeatureGroup updateManyAndReturn
   */
  export type FeatureGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureGroup
     */
    select?: FeatureGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureGroup
     */
    omit?: FeatureGroupOmit<ExtArgs> | null
    /**
     * The data used to update FeatureGroups.
     */
    data: XOR<FeatureGroupUpdateManyMutationInput, FeatureGroupUncheckedUpdateManyInput>
    /**
     * Filter which FeatureGroups to update
     */
    where?: FeatureGroupWhereInput
    /**
     * Limit how many FeatureGroups to update.
     */
    limit?: number
  }

  /**
   * FeatureGroup upsert
   */
  export type FeatureGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureGroup
     */
    select?: FeatureGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureGroup
     */
    omit?: FeatureGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the FeatureGroup to update in case it exists.
     */
    where: FeatureGroupWhereUniqueInput
    /**
     * In case the FeatureGroup found by the `where` argument doesn't exist, create a new FeatureGroup with this data.
     */
    create: XOR<FeatureGroupCreateInput, FeatureGroupUncheckedCreateInput>
    /**
     * In case the FeatureGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureGroupUpdateInput, FeatureGroupUncheckedUpdateInput>
  }

  /**
   * FeatureGroup delete
   */
  export type FeatureGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureGroup
     */
    select?: FeatureGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureGroup
     */
    omit?: FeatureGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureGroupInclude<ExtArgs> | null
    /**
     * Filter which FeatureGroup to delete.
     */
    where: FeatureGroupWhereUniqueInput
  }

  /**
   * FeatureGroup deleteMany
   */
  export type FeatureGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureGroups to delete
     */
    where?: FeatureGroupWhereInput
    /**
     * Limit how many FeatureGroups to delete.
     */
    limit?: number
  }

  /**
   * FeatureGroup.features
   */
  export type FeatureGroup$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    where?: FeatureWhereInput
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    cursor?: FeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * FeatureGroup without action
   */
  export type FeatureGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureGroup
     */
    select?: FeatureGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureGroup
     */
    omit?: FeatureGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureGroupInclude<ExtArgs> | null
  }


  /**
   * Model Feature
   */

  export type AggregateFeature = {
    _count: FeatureCountAggregateOutputType | null
    _avg: FeatureAvgAggregateOutputType | null
    _sum: FeatureSumAggregateOutputType | null
    _min: FeatureMinAggregateOutputType | null
    _max: FeatureMaxAggregateOutputType | null
  }

  export type FeatureAvgAggregateOutputType = {
    minCount: number | null
    displayOrder: number | null
  }

  export type FeatureSumAggregateOutputType = {
    minCount: number | null
    displayOrder: number | null
  }

  export type FeatureMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    name: string | null
    description: string | null
    explanation: string | null
    isCountable: boolean | null
    minCount: number | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    name: string | null
    description: string | null
    explanation: string | null
    isCountable: boolean | null
    minCount: number | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureCountAggregateOutputType = {
    id: number
    groupId: number
    name: number
    description: number
    explanation: number
    isCountable: number
    minCount: number
    displayOrder: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeatureAvgAggregateInputType = {
    minCount?: true
    displayOrder?: true
  }

  export type FeatureSumAggregateInputType = {
    minCount?: true
    displayOrder?: true
  }

  export type FeatureMinAggregateInputType = {
    id?: true
    groupId?: true
    name?: true
    description?: true
    explanation?: true
    isCountable?: true
    minCount?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureMaxAggregateInputType = {
    id?: true
    groupId?: true
    name?: true
    description?: true
    explanation?: true
    isCountable?: true
    minCount?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureCountAggregateInputType = {
    id?: true
    groupId?: true
    name?: true
    description?: true
    explanation?: true
    isCountable?: true
    minCount?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feature to aggregate.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Features
    **/
    _count?: true | FeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureMaxAggregateInputType
  }

  export type GetFeatureAggregateType<T extends FeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeature[P]>
      : GetScalarType<T[P], AggregateFeature[P]>
  }




  export type FeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureWhereInput
    orderBy?: FeatureOrderByWithAggregationInput | FeatureOrderByWithAggregationInput[]
    by: FeatureScalarFieldEnum[] | FeatureScalarFieldEnum
    having?: FeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureCountAggregateInputType | true
    _avg?: FeatureAvgAggregateInputType
    _sum?: FeatureSumAggregateInputType
    _min?: FeatureMinAggregateInputType
    _max?: FeatureMaxAggregateInputType
  }

  export type FeatureGroupByOutputType = {
    id: string
    groupId: string
    name: string
    description: string | null
    explanation: string | null
    isCountable: boolean
    minCount: number
    displayOrder: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: FeatureCountAggregateOutputType | null
    _avg: FeatureAvgAggregateOutputType | null
    _sum: FeatureSumAggregateOutputType | null
    _min: FeatureMinAggregateOutputType | null
    _max: FeatureMaxAggregateOutputType | null
  }

  type GetFeatureGroupByPayload<T extends FeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureGroupByOutputType[P]>
        }
      >
    >


  export type FeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    name?: boolean
    description?: boolean
    explanation?: boolean
    isCountable?: boolean
    minCount?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    defaults?: boolean | Feature$defaultsArgs<ExtArgs>
    calculations?: boolean | Feature$calculationsArgs<ExtArgs>
    tiers?: boolean | Feature$tiersArgs<ExtArgs>
    group?: boolean | FeatureGroupDefaultArgs<ExtArgs>
    _count?: boolean | FeatureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feature"]>

  export type FeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    name?: boolean
    description?: boolean
    explanation?: boolean
    isCountable?: boolean
    minCount?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | FeatureGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feature"]>

  export type FeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    name?: boolean
    description?: boolean
    explanation?: boolean
    isCountable?: boolean
    minCount?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | FeatureGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feature"]>

  export type FeatureSelectScalar = {
    id?: boolean
    groupId?: boolean
    name?: boolean
    description?: boolean
    explanation?: boolean
    isCountable?: boolean
    minCount?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "name" | "description" | "explanation" | "isCountable" | "minCount" | "displayOrder" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["feature"]>
  export type FeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaults?: boolean | Feature$defaultsArgs<ExtArgs>
    calculations?: boolean | Feature$calculationsArgs<ExtArgs>
    tiers?: boolean | Feature$tiersArgs<ExtArgs>
    group?: boolean | FeatureGroupDefaultArgs<ExtArgs>
    _count?: boolean | FeatureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | FeatureGroupDefaultArgs<ExtArgs>
  }
  export type FeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | FeatureGroupDefaultArgs<ExtArgs>
  }

  export type $FeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feature"
    objects: {
      defaults: Prisma.$BusinessTypeDefaultPayload<ExtArgs>[]
      calculations: Prisma.$CalculationFeaturePayload<ExtArgs>[]
      tiers: Prisma.$FeatureTierPayload<ExtArgs>[]
      group: Prisma.$FeatureGroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      name: string
      description: string | null
      explanation: string | null
      isCountable: boolean
      minCount: number
      displayOrder: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feature"]>
    composites: {}
  }

  type FeatureGetPayload<S extends boolean | null | undefined | FeatureDefaultArgs> = $Result.GetResult<Prisma.$FeaturePayload, S>

  type FeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatureCountAggregateInputType | true
    }

  export interface FeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feature'], meta: { name: 'Feature' } }
    /**
     * Find zero or one Feature that matches the filter.
     * @param {FeatureFindUniqueArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatureFindUniqueArgs>(args: SelectSubset<T, FeatureFindUniqueArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatureFindUniqueOrThrowArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindFirstArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatureFindFirstArgs>(args?: SelectSubset<T, FeatureFindFirstArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindFirstOrThrowArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Features
     * const features = await prisma.feature.findMany()
     * 
     * // Get first 10 Features
     * const features = await prisma.feature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featureWithIdOnly = await prisma.feature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeatureFindManyArgs>(args?: SelectSubset<T, FeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feature.
     * @param {FeatureCreateArgs} args - Arguments to create a Feature.
     * @example
     * // Create one Feature
     * const Feature = await prisma.feature.create({
     *   data: {
     *     // ... data to create a Feature
     *   }
     * })
     * 
     */
    create<T extends FeatureCreateArgs>(args: SelectSubset<T, FeatureCreateArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Features.
     * @param {FeatureCreateManyArgs} args - Arguments to create many Features.
     * @example
     * // Create many Features
     * const feature = await prisma.feature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatureCreateManyArgs>(args?: SelectSubset<T, FeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Features and returns the data saved in the database.
     * @param {FeatureCreateManyAndReturnArgs} args - Arguments to create many Features.
     * @example
     * // Create many Features
     * const feature = await prisma.feature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Features and only return the `id`
     * const featureWithIdOnly = await prisma.feature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Feature.
     * @param {FeatureDeleteArgs} args - Arguments to delete one Feature.
     * @example
     * // Delete one Feature
     * const Feature = await prisma.feature.delete({
     *   where: {
     *     // ... filter to delete one Feature
     *   }
     * })
     * 
     */
    delete<T extends FeatureDeleteArgs>(args: SelectSubset<T, FeatureDeleteArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feature.
     * @param {FeatureUpdateArgs} args - Arguments to update one Feature.
     * @example
     * // Update one Feature
     * const feature = await prisma.feature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatureUpdateArgs>(args: SelectSubset<T, FeatureUpdateArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Features.
     * @param {FeatureDeleteManyArgs} args - Arguments to filter Features to delete.
     * @example
     * // Delete a few Features
     * const { count } = await prisma.feature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatureDeleteManyArgs>(args?: SelectSubset<T, FeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Features
     * const feature = await prisma.feature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatureUpdateManyArgs>(args: SelectSubset<T, FeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features and returns the data updated in the database.
     * @param {FeatureUpdateManyAndReturnArgs} args - Arguments to update many Features.
     * @example
     * // Update many Features
     * const feature = await prisma.feature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Features and only return the `id`
     * const featureWithIdOnly = await prisma.feature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, FeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Feature.
     * @param {FeatureUpsertArgs} args - Arguments to update or create a Feature.
     * @example
     * // Update or create a Feature
     * const feature = await prisma.feature.upsert({
     *   create: {
     *     // ... data to create a Feature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feature we want to update
     *   }
     * })
     */
    upsert<T extends FeatureUpsertArgs>(args: SelectSubset<T, FeatureUpsertArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureCountArgs} args - Arguments to filter Features to count.
     * @example
     * // Count the number of Features
     * const count = await prisma.feature.count({
     *   where: {
     *     // ... the filter for the Features we want to count
     *   }
     * })
    **/
    count<T extends FeatureCountArgs>(
      args?: Subset<T, FeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureAggregateArgs>(args: Subset<T, FeatureAggregateArgs>): Prisma.PrismaPromise<GetFeatureAggregateType<T>>

    /**
     * Group by Feature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureGroupByArgs['orderBy'] }
        : { orderBy?: FeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feature model
   */
  readonly fields: FeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    defaults<T extends Feature$defaultsArgs<ExtArgs> = {}>(args?: Subset<T, Feature$defaultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypeDefaultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calculations<T extends Feature$calculationsArgs<ExtArgs> = {}>(args?: Subset<T, Feature$calculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalculationFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tiers<T extends Feature$tiersArgs<ExtArgs> = {}>(args?: Subset<T, Feature$tiersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureTierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    group<T extends FeatureGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatureGroupDefaultArgs<ExtArgs>>): Prisma__FeatureGroupClient<$Result.GetResult<Prisma.$FeatureGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feature model
   */
  interface FeatureFieldRefs {
    readonly id: FieldRef<"Feature", 'String'>
    readonly groupId: FieldRef<"Feature", 'String'>
    readonly name: FieldRef<"Feature", 'String'>
    readonly description: FieldRef<"Feature", 'String'>
    readonly explanation: FieldRef<"Feature", 'String'>
    readonly isCountable: FieldRef<"Feature", 'Boolean'>
    readonly minCount: FieldRef<"Feature", 'Int'>
    readonly displayOrder: FieldRef<"Feature", 'Int'>
    readonly isActive: FieldRef<"Feature", 'Boolean'>
    readonly createdAt: FieldRef<"Feature", 'DateTime'>
    readonly updatedAt: FieldRef<"Feature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Feature findUnique
   */
  export type FeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature findUniqueOrThrow
   */
  export type FeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature findFirst
   */
  export type FeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Features.
     */
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Feature findFirstOrThrow
   */
  export type FeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Features.
     */
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Feature findMany
   */
  export type FeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Features to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Feature create
   */
  export type FeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a Feature.
     */
    data: XOR<FeatureCreateInput, FeatureUncheckedCreateInput>
  }

  /**
   * Feature createMany
   */
  export type FeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Features.
     */
    data: FeatureCreateManyInput | FeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feature createManyAndReturn
   */
  export type FeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * The data used to create many Features.
     */
    data: FeatureCreateManyInput | FeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feature update
   */
  export type FeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a Feature.
     */
    data: XOR<FeatureUpdateInput, FeatureUncheckedUpdateInput>
    /**
     * Choose, which Feature to update.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature updateMany
   */
  export type FeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Features.
     */
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyInput>
    /**
     * Filter which Features to update
     */
    where?: FeatureWhereInput
    /**
     * Limit how many Features to update.
     */
    limit?: number
  }

  /**
   * Feature updateManyAndReturn
   */
  export type FeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * The data used to update Features.
     */
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyInput>
    /**
     * Filter which Features to update
     */
    where?: FeatureWhereInput
    /**
     * Limit how many Features to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feature upsert
   */
  export type FeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the Feature to update in case it exists.
     */
    where: FeatureWhereUniqueInput
    /**
     * In case the Feature found by the `where` argument doesn't exist, create a new Feature with this data.
     */
    create: XOR<FeatureCreateInput, FeatureUncheckedCreateInput>
    /**
     * In case the Feature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureUpdateInput, FeatureUncheckedUpdateInput>
  }

  /**
   * Feature delete
   */
  export type FeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter which Feature to delete.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature deleteMany
   */
  export type FeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Features to delete
     */
    where?: FeatureWhereInput
    /**
     * Limit how many Features to delete.
     */
    limit?: number
  }

  /**
   * Feature.defaults
   */
  export type Feature$defaultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeDefault
     */
    select?: BusinessTypeDefaultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypeDefault
     */
    omit?: BusinessTypeDefaultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeDefaultInclude<ExtArgs> | null
    where?: BusinessTypeDefaultWhereInput
    orderBy?: BusinessTypeDefaultOrderByWithRelationInput | BusinessTypeDefaultOrderByWithRelationInput[]
    cursor?: BusinessTypeDefaultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessTypeDefaultScalarFieldEnum | BusinessTypeDefaultScalarFieldEnum[]
  }

  /**
   * Feature.calculations
   */
  export type Feature$calculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationFeature
     */
    select?: CalculationFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationFeature
     */
    omit?: CalculationFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationFeatureInclude<ExtArgs> | null
    where?: CalculationFeatureWhereInput
    orderBy?: CalculationFeatureOrderByWithRelationInput | CalculationFeatureOrderByWithRelationInput[]
    cursor?: CalculationFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalculationFeatureScalarFieldEnum | CalculationFeatureScalarFieldEnum[]
  }

  /**
   * Feature.tiers
   */
  export type Feature$tiersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureTier
     */
    select?: FeatureTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureTier
     */
    omit?: FeatureTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureTierInclude<ExtArgs> | null
    where?: FeatureTierWhereInput
    orderBy?: FeatureTierOrderByWithRelationInput | FeatureTierOrderByWithRelationInput[]
    cursor?: FeatureTierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeatureTierScalarFieldEnum | FeatureTierScalarFieldEnum[]
  }

  /**
   * Feature without action
   */
  export type FeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
  }


  /**
   * Model FeatureTier
   */

  export type AggregateFeatureTier = {
    _count: FeatureTierCountAggregateOutputType | null
    _avg: FeatureTierAvgAggregateOutputType | null
    _sum: FeatureTierSumAggregateOutputType | null
    _min: FeatureTierMinAggregateOutputType | null
    _max: FeatureTierMaxAggregateOutputType | null
  }

  export type FeatureTierAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type FeatureTierSumAggregateOutputType = {
    price: Decimal | null
  }

  export type FeatureTierMinAggregateOutputType = {
    id: string | null
    featureId: string | null
    tierName: string | null
    description: string | null
    price: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureTierMaxAggregateOutputType = {
    id: string | null
    featureId: string | null
    tierName: string | null
    description: string | null
    price: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureTierCountAggregateOutputType = {
    id: number
    featureId: number
    tierName: number
    description: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeatureTierAvgAggregateInputType = {
    price?: true
  }

  export type FeatureTierSumAggregateInputType = {
    price?: true
  }

  export type FeatureTierMinAggregateInputType = {
    id?: true
    featureId?: true
    tierName?: true
    description?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureTierMaxAggregateInputType = {
    id?: true
    featureId?: true
    tierName?: true
    description?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureTierCountAggregateInputType = {
    id?: true
    featureId?: true
    tierName?: true
    description?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeatureTierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureTier to aggregate.
     */
    where?: FeatureTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureTiers to fetch.
     */
    orderBy?: FeatureTierOrderByWithRelationInput | FeatureTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeatureTiers
    **/
    _count?: true | FeatureTierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatureTierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatureTierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureTierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureTierMaxAggregateInputType
  }

  export type GetFeatureTierAggregateType<T extends FeatureTierAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatureTier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatureTier[P]>
      : GetScalarType<T[P], AggregateFeatureTier[P]>
  }




  export type FeatureTierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureTierWhereInput
    orderBy?: FeatureTierOrderByWithAggregationInput | FeatureTierOrderByWithAggregationInput[]
    by: FeatureTierScalarFieldEnum[] | FeatureTierScalarFieldEnum
    having?: FeatureTierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureTierCountAggregateInputType | true
    _avg?: FeatureTierAvgAggregateInputType
    _sum?: FeatureTierSumAggregateInputType
    _min?: FeatureTierMinAggregateInputType
    _max?: FeatureTierMaxAggregateInputType
  }

  export type FeatureTierGroupByOutputType = {
    id: string
    featureId: string
    tierName: string
    description: string | null
    price: Decimal
    createdAt: Date
    updatedAt: Date
    _count: FeatureTierCountAggregateOutputType | null
    _avg: FeatureTierAvgAggregateOutputType | null
    _sum: FeatureTierSumAggregateOutputType | null
    _min: FeatureTierMinAggregateOutputType | null
    _max: FeatureTierMaxAggregateOutputType | null
  }

  type GetFeatureTierGroupByPayload<T extends FeatureTierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureTierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureTierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureTierGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureTierGroupByOutputType[P]>
        }
      >
    >


  export type FeatureTierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    featureId?: boolean
    tierName?: boolean
    description?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calculations?: boolean | FeatureTier$calculationsArgs<ExtArgs>
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    _count?: boolean | FeatureTierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featureTier"]>

  export type FeatureTierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    featureId?: boolean
    tierName?: boolean
    description?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featureTier"]>

  export type FeatureTierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    featureId?: boolean
    tierName?: boolean
    description?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featureTier"]>

  export type FeatureTierSelectScalar = {
    id?: boolean
    featureId?: boolean
    tierName?: boolean
    description?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeatureTierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "featureId" | "tierName" | "description" | "price" | "createdAt" | "updatedAt", ExtArgs["result"]["featureTier"]>
  export type FeatureTierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calculations?: boolean | FeatureTier$calculationsArgs<ExtArgs>
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    _count?: boolean | FeatureTierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeatureTierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
  }
  export type FeatureTierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
  }

  export type $FeatureTierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeatureTier"
    objects: {
      calculations: Prisma.$CalculationFeaturePayload<ExtArgs>[]
      feature: Prisma.$FeaturePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      featureId: string
      tierName: string
      description: string | null
      price: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["featureTier"]>
    composites: {}
  }

  type FeatureTierGetPayload<S extends boolean | null | undefined | FeatureTierDefaultArgs> = $Result.GetResult<Prisma.$FeatureTierPayload, S>

  type FeatureTierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatureTierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatureTierCountAggregateInputType | true
    }

  export interface FeatureTierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeatureTier'], meta: { name: 'FeatureTier' } }
    /**
     * Find zero or one FeatureTier that matches the filter.
     * @param {FeatureTierFindUniqueArgs} args - Arguments to find a FeatureTier
     * @example
     * // Get one FeatureTier
     * const featureTier = await prisma.featureTier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatureTierFindUniqueArgs>(args: SelectSubset<T, FeatureTierFindUniqueArgs<ExtArgs>>): Prisma__FeatureTierClient<$Result.GetResult<Prisma.$FeatureTierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeatureTier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatureTierFindUniqueOrThrowArgs} args - Arguments to find a FeatureTier
     * @example
     * // Get one FeatureTier
     * const featureTier = await prisma.featureTier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatureTierFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatureTierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatureTierClient<$Result.GetResult<Prisma.$FeatureTierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatureTier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureTierFindFirstArgs} args - Arguments to find a FeatureTier
     * @example
     * // Get one FeatureTier
     * const featureTier = await prisma.featureTier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatureTierFindFirstArgs>(args?: SelectSubset<T, FeatureTierFindFirstArgs<ExtArgs>>): Prisma__FeatureTierClient<$Result.GetResult<Prisma.$FeatureTierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatureTier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureTierFindFirstOrThrowArgs} args - Arguments to find a FeatureTier
     * @example
     * // Get one FeatureTier
     * const featureTier = await prisma.featureTier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatureTierFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatureTierFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatureTierClient<$Result.GetResult<Prisma.$FeatureTierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeatureTiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureTierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeatureTiers
     * const featureTiers = await prisma.featureTier.findMany()
     * 
     * // Get first 10 FeatureTiers
     * const featureTiers = await prisma.featureTier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featureTierWithIdOnly = await prisma.featureTier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeatureTierFindManyArgs>(args?: SelectSubset<T, FeatureTierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureTierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeatureTier.
     * @param {FeatureTierCreateArgs} args - Arguments to create a FeatureTier.
     * @example
     * // Create one FeatureTier
     * const FeatureTier = await prisma.featureTier.create({
     *   data: {
     *     // ... data to create a FeatureTier
     *   }
     * })
     * 
     */
    create<T extends FeatureTierCreateArgs>(args: SelectSubset<T, FeatureTierCreateArgs<ExtArgs>>): Prisma__FeatureTierClient<$Result.GetResult<Prisma.$FeatureTierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeatureTiers.
     * @param {FeatureTierCreateManyArgs} args - Arguments to create many FeatureTiers.
     * @example
     * // Create many FeatureTiers
     * const featureTier = await prisma.featureTier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatureTierCreateManyArgs>(args?: SelectSubset<T, FeatureTierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeatureTiers and returns the data saved in the database.
     * @param {FeatureTierCreateManyAndReturnArgs} args - Arguments to create many FeatureTiers.
     * @example
     * // Create many FeatureTiers
     * const featureTier = await prisma.featureTier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeatureTiers and only return the `id`
     * const featureTierWithIdOnly = await prisma.featureTier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatureTierCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatureTierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureTierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeatureTier.
     * @param {FeatureTierDeleteArgs} args - Arguments to delete one FeatureTier.
     * @example
     * // Delete one FeatureTier
     * const FeatureTier = await prisma.featureTier.delete({
     *   where: {
     *     // ... filter to delete one FeatureTier
     *   }
     * })
     * 
     */
    delete<T extends FeatureTierDeleteArgs>(args: SelectSubset<T, FeatureTierDeleteArgs<ExtArgs>>): Prisma__FeatureTierClient<$Result.GetResult<Prisma.$FeatureTierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeatureTier.
     * @param {FeatureTierUpdateArgs} args - Arguments to update one FeatureTier.
     * @example
     * // Update one FeatureTier
     * const featureTier = await prisma.featureTier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatureTierUpdateArgs>(args: SelectSubset<T, FeatureTierUpdateArgs<ExtArgs>>): Prisma__FeatureTierClient<$Result.GetResult<Prisma.$FeatureTierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeatureTiers.
     * @param {FeatureTierDeleteManyArgs} args - Arguments to filter FeatureTiers to delete.
     * @example
     * // Delete a few FeatureTiers
     * const { count } = await prisma.featureTier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatureTierDeleteManyArgs>(args?: SelectSubset<T, FeatureTierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureTierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeatureTiers
     * const featureTier = await prisma.featureTier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatureTierUpdateManyArgs>(args: SelectSubset<T, FeatureTierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureTiers and returns the data updated in the database.
     * @param {FeatureTierUpdateManyAndReturnArgs} args - Arguments to update many FeatureTiers.
     * @example
     * // Update many FeatureTiers
     * const featureTier = await prisma.featureTier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeatureTiers and only return the `id`
     * const featureTierWithIdOnly = await prisma.featureTier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeatureTierUpdateManyAndReturnArgs>(args: SelectSubset<T, FeatureTierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureTierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeatureTier.
     * @param {FeatureTierUpsertArgs} args - Arguments to update or create a FeatureTier.
     * @example
     * // Update or create a FeatureTier
     * const featureTier = await prisma.featureTier.upsert({
     *   create: {
     *     // ... data to create a FeatureTier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeatureTier we want to update
     *   }
     * })
     */
    upsert<T extends FeatureTierUpsertArgs>(args: SelectSubset<T, FeatureTierUpsertArgs<ExtArgs>>): Prisma__FeatureTierClient<$Result.GetResult<Prisma.$FeatureTierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeatureTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureTierCountArgs} args - Arguments to filter FeatureTiers to count.
     * @example
     * // Count the number of FeatureTiers
     * const count = await prisma.featureTier.count({
     *   where: {
     *     // ... the filter for the FeatureTiers we want to count
     *   }
     * })
    **/
    count<T extends FeatureTierCountArgs>(
      args?: Subset<T, FeatureTierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureTierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeatureTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureTierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureTierAggregateArgs>(args: Subset<T, FeatureTierAggregateArgs>): Prisma.PrismaPromise<GetFeatureTierAggregateType<T>>

    /**
     * Group by FeatureTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureTierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureTierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureTierGroupByArgs['orderBy'] }
        : { orderBy?: FeatureTierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureTierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureTierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeatureTier model
   */
  readonly fields: FeatureTierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeatureTier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureTierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    calculations<T extends FeatureTier$calculationsArgs<ExtArgs> = {}>(args?: Subset<T, FeatureTier$calculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalculationFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feature<T extends FeatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatureDefaultArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeatureTier model
   */
  interface FeatureTierFieldRefs {
    readonly id: FieldRef<"FeatureTier", 'String'>
    readonly featureId: FieldRef<"FeatureTier", 'String'>
    readonly tierName: FieldRef<"FeatureTier", 'String'>
    readonly description: FieldRef<"FeatureTier", 'String'>
    readonly price: FieldRef<"FeatureTier", 'Decimal'>
    readonly createdAt: FieldRef<"FeatureTier", 'DateTime'>
    readonly updatedAt: FieldRef<"FeatureTier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeatureTier findUnique
   */
  export type FeatureTierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureTier
     */
    select?: FeatureTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureTier
     */
    omit?: FeatureTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureTierInclude<ExtArgs> | null
    /**
     * Filter, which FeatureTier to fetch.
     */
    where: FeatureTierWhereUniqueInput
  }

  /**
   * FeatureTier findUniqueOrThrow
   */
  export type FeatureTierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureTier
     */
    select?: FeatureTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureTier
     */
    omit?: FeatureTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureTierInclude<ExtArgs> | null
    /**
     * Filter, which FeatureTier to fetch.
     */
    where: FeatureTierWhereUniqueInput
  }

  /**
   * FeatureTier findFirst
   */
  export type FeatureTierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureTier
     */
    select?: FeatureTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureTier
     */
    omit?: FeatureTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureTierInclude<ExtArgs> | null
    /**
     * Filter, which FeatureTier to fetch.
     */
    where?: FeatureTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureTiers to fetch.
     */
    orderBy?: FeatureTierOrderByWithRelationInput | FeatureTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureTiers.
     */
    cursor?: FeatureTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureTiers.
     */
    distinct?: FeatureTierScalarFieldEnum | FeatureTierScalarFieldEnum[]
  }

  /**
   * FeatureTier findFirstOrThrow
   */
  export type FeatureTierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureTier
     */
    select?: FeatureTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureTier
     */
    omit?: FeatureTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureTierInclude<ExtArgs> | null
    /**
     * Filter, which FeatureTier to fetch.
     */
    where?: FeatureTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureTiers to fetch.
     */
    orderBy?: FeatureTierOrderByWithRelationInput | FeatureTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureTiers.
     */
    cursor?: FeatureTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureTiers.
     */
    distinct?: FeatureTierScalarFieldEnum | FeatureTierScalarFieldEnum[]
  }

  /**
   * FeatureTier findMany
   */
  export type FeatureTierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureTier
     */
    select?: FeatureTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureTier
     */
    omit?: FeatureTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureTierInclude<ExtArgs> | null
    /**
     * Filter, which FeatureTiers to fetch.
     */
    where?: FeatureTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureTiers to fetch.
     */
    orderBy?: FeatureTierOrderByWithRelationInput | FeatureTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeatureTiers.
     */
    cursor?: FeatureTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureTiers.
     */
    skip?: number
    distinct?: FeatureTierScalarFieldEnum | FeatureTierScalarFieldEnum[]
  }

  /**
   * FeatureTier create
   */
  export type FeatureTierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureTier
     */
    select?: FeatureTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureTier
     */
    omit?: FeatureTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureTierInclude<ExtArgs> | null
    /**
     * The data needed to create a FeatureTier.
     */
    data: XOR<FeatureTierCreateInput, FeatureTierUncheckedCreateInput>
  }

  /**
   * FeatureTier createMany
   */
  export type FeatureTierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeatureTiers.
     */
    data: FeatureTierCreateManyInput | FeatureTierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatureTier createManyAndReturn
   */
  export type FeatureTierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureTier
     */
    select?: FeatureTierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureTier
     */
    omit?: FeatureTierOmit<ExtArgs> | null
    /**
     * The data used to create many FeatureTiers.
     */
    data: FeatureTierCreateManyInput | FeatureTierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureTierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeatureTier update
   */
  export type FeatureTierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureTier
     */
    select?: FeatureTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureTier
     */
    omit?: FeatureTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureTierInclude<ExtArgs> | null
    /**
     * The data needed to update a FeatureTier.
     */
    data: XOR<FeatureTierUpdateInput, FeatureTierUncheckedUpdateInput>
    /**
     * Choose, which FeatureTier to update.
     */
    where: FeatureTierWhereUniqueInput
  }

  /**
   * FeatureTier updateMany
   */
  export type FeatureTierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeatureTiers.
     */
    data: XOR<FeatureTierUpdateManyMutationInput, FeatureTierUncheckedUpdateManyInput>
    /**
     * Filter which FeatureTiers to update
     */
    where?: FeatureTierWhereInput
    /**
     * Limit how many FeatureTiers to update.
     */
    limit?: number
  }

  /**
   * FeatureTier updateManyAndReturn
   */
  export type FeatureTierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureTier
     */
    select?: FeatureTierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureTier
     */
    omit?: FeatureTierOmit<ExtArgs> | null
    /**
     * The data used to update FeatureTiers.
     */
    data: XOR<FeatureTierUpdateManyMutationInput, FeatureTierUncheckedUpdateManyInput>
    /**
     * Filter which FeatureTiers to update
     */
    where?: FeatureTierWhereInput
    /**
     * Limit how many FeatureTiers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureTierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeatureTier upsert
   */
  export type FeatureTierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureTier
     */
    select?: FeatureTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureTier
     */
    omit?: FeatureTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureTierInclude<ExtArgs> | null
    /**
     * The filter to search for the FeatureTier to update in case it exists.
     */
    where: FeatureTierWhereUniqueInput
    /**
     * In case the FeatureTier found by the `where` argument doesn't exist, create a new FeatureTier with this data.
     */
    create: XOR<FeatureTierCreateInput, FeatureTierUncheckedCreateInput>
    /**
     * In case the FeatureTier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureTierUpdateInput, FeatureTierUncheckedUpdateInput>
  }

  /**
   * FeatureTier delete
   */
  export type FeatureTierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureTier
     */
    select?: FeatureTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureTier
     */
    omit?: FeatureTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureTierInclude<ExtArgs> | null
    /**
     * Filter which FeatureTier to delete.
     */
    where: FeatureTierWhereUniqueInput
  }

  /**
   * FeatureTier deleteMany
   */
  export type FeatureTierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureTiers to delete
     */
    where?: FeatureTierWhereInput
    /**
     * Limit how many FeatureTiers to delete.
     */
    limit?: number
  }

  /**
   * FeatureTier.calculations
   */
  export type FeatureTier$calculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationFeature
     */
    select?: CalculationFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationFeature
     */
    omit?: CalculationFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationFeatureInclude<ExtArgs> | null
    where?: CalculationFeatureWhereInput
    orderBy?: CalculationFeatureOrderByWithRelationInput | CalculationFeatureOrderByWithRelationInput[]
    cursor?: CalculationFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalculationFeatureScalarFieldEnum | CalculationFeatureScalarFieldEnum[]
  }

  /**
   * FeatureTier without action
   */
  export type FeatureTierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureTier
     */
    select?: FeatureTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureTier
     */
    omit?: FeatureTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureTierInclude<ExtArgs> | null
  }


  /**
   * Model BusinessType
   */

  export type AggregateBusinessType = {
    _count: BusinessTypeCountAggregateOutputType | null
    _avg: BusinessTypeAvgAggregateOutputType | null
    _sum: BusinessTypeSumAggregateOutputType | null
    _min: BusinessTypeMinAggregateOutputType | null
    _max: BusinessTypeMaxAggregateOutputType | null
  }

  export type BusinessTypeAvgAggregateOutputType = {
    basePrice: Decimal | null
    timelineDays: number | null
  }

  export type BusinessTypeSumAggregateOutputType = {
    basePrice: Decimal | null
    timelineDays: number | null
  }

  export type BusinessTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    basePrice: Decimal | null
    timelineDays: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    basePrice: Decimal | null
    timelineDays: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessTypeCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    basePrice: number
    timelineDays: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessTypeAvgAggregateInputType = {
    basePrice?: true
    timelineDays?: true
  }

  export type BusinessTypeSumAggregateInputType = {
    basePrice?: true
    timelineDays?: true
  }

  export type BusinessTypeMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    basePrice?: true
    timelineDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessTypeMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    basePrice?: true
    timelineDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessTypeCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    basePrice?: true
    timelineDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessType to aggregate.
     */
    where?: BusinessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypes to fetch.
     */
    orderBy?: BusinessTypeOrderByWithRelationInput | BusinessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessTypes
    **/
    _count?: true | BusinessTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessTypeMaxAggregateInputType
  }

  export type GetBusinessTypeAggregateType<T extends BusinessTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessType[P]>
      : GetScalarType<T[P], AggregateBusinessType[P]>
  }




  export type BusinessTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessTypeWhereInput
    orderBy?: BusinessTypeOrderByWithAggregationInput | BusinessTypeOrderByWithAggregationInput[]
    by: BusinessTypeScalarFieldEnum[] | BusinessTypeScalarFieldEnum
    having?: BusinessTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessTypeCountAggregateInputType | true
    _avg?: BusinessTypeAvgAggregateInputType
    _sum?: BusinessTypeSumAggregateInputType
    _min?: BusinessTypeMinAggregateInputType
    _max?: BusinessTypeMaxAggregateInputType
  }

  export type BusinessTypeGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    basePrice: Decimal
    timelineDays: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BusinessTypeCountAggregateOutputType | null
    _avg: BusinessTypeAvgAggregateOutputType | null
    _sum: BusinessTypeSumAggregateOutputType | null
    _min: BusinessTypeMinAggregateOutputType | null
    _max: BusinessTypeMaxAggregateOutputType | null
  }

  type GetBusinessTypeGroupByPayload<T extends BusinessTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessTypeGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessTypeGroupByOutputType[P]>
        }
      >
    >


  export type BusinessTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    basePrice?: boolean
    timelineDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    defaults?: boolean | BusinessType$defaultsArgs<ExtArgs>
    pages?: boolean | BusinessType$pagesArgs<ExtArgs>
    calculations?: boolean | BusinessType$calculationsArgs<ExtArgs>
    _count?: boolean | BusinessTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessType"]>

  export type BusinessTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    basePrice?: boolean
    timelineDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["businessType"]>

  export type BusinessTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    basePrice?: boolean
    timelineDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["businessType"]>

  export type BusinessTypeSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    basePrice?: boolean
    timelineDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "basePrice" | "timelineDays" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["businessType"]>
  export type BusinessTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaults?: boolean | BusinessType$defaultsArgs<ExtArgs>
    pages?: boolean | BusinessType$pagesArgs<ExtArgs>
    calculations?: boolean | BusinessType$calculationsArgs<ExtArgs>
    _count?: boolean | BusinessTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusinessTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BusinessTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BusinessTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessType"
    objects: {
      defaults: Prisma.$BusinessTypeDefaultPayload<ExtArgs>[]
      pages: Prisma.$BusinessTypePagePayload<ExtArgs>[]
      calculations: Prisma.$PricingCalculationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      basePrice: Prisma.Decimal
      timelineDays: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["businessType"]>
    composites: {}
  }

  type BusinessTypeGetPayload<S extends boolean | null | undefined | BusinessTypeDefaultArgs> = $Result.GetResult<Prisma.$BusinessTypePayload, S>

  type BusinessTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusinessTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusinessTypeCountAggregateInputType | true
    }

  export interface BusinessTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessType'], meta: { name: 'BusinessType' } }
    /**
     * Find zero or one BusinessType that matches the filter.
     * @param {BusinessTypeFindUniqueArgs} args - Arguments to find a BusinessType
     * @example
     * // Get one BusinessType
     * const businessType = await prisma.businessType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessTypeFindUniqueArgs>(args: SelectSubset<T, BusinessTypeFindUniqueArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BusinessType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusinessTypeFindUniqueOrThrowArgs} args - Arguments to find a BusinessType
     * @example
     * // Get one BusinessType
     * const businessType = await prisma.businessType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeFindFirstArgs} args - Arguments to find a BusinessType
     * @example
     * // Get one BusinessType
     * const businessType = await prisma.businessType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessTypeFindFirstArgs>(args?: SelectSubset<T, BusinessTypeFindFirstArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeFindFirstOrThrowArgs} args - Arguments to find a BusinessType
     * @example
     * // Get one BusinessType
     * const businessType = await prisma.businessType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BusinessTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessTypes
     * const businessTypes = await prisma.businessType.findMany()
     * 
     * // Get first 10 BusinessTypes
     * const businessTypes = await prisma.businessType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessTypeWithIdOnly = await prisma.businessType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessTypeFindManyArgs>(args?: SelectSubset<T, BusinessTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BusinessType.
     * @param {BusinessTypeCreateArgs} args - Arguments to create a BusinessType.
     * @example
     * // Create one BusinessType
     * const BusinessType = await prisma.businessType.create({
     *   data: {
     *     // ... data to create a BusinessType
     *   }
     * })
     * 
     */
    create<T extends BusinessTypeCreateArgs>(args: SelectSubset<T, BusinessTypeCreateArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BusinessTypes.
     * @param {BusinessTypeCreateManyArgs} args - Arguments to create many BusinessTypes.
     * @example
     * // Create many BusinessTypes
     * const businessType = await prisma.businessType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessTypeCreateManyArgs>(args?: SelectSubset<T, BusinessTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessTypes and returns the data saved in the database.
     * @param {BusinessTypeCreateManyAndReturnArgs} args - Arguments to create many BusinessTypes.
     * @example
     * // Create many BusinessTypes
     * const businessType = await prisma.businessType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessTypes and only return the `id`
     * const businessTypeWithIdOnly = await prisma.businessType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BusinessType.
     * @param {BusinessTypeDeleteArgs} args - Arguments to delete one BusinessType.
     * @example
     * // Delete one BusinessType
     * const BusinessType = await prisma.businessType.delete({
     *   where: {
     *     // ... filter to delete one BusinessType
     *   }
     * })
     * 
     */
    delete<T extends BusinessTypeDeleteArgs>(args: SelectSubset<T, BusinessTypeDeleteArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BusinessType.
     * @param {BusinessTypeUpdateArgs} args - Arguments to update one BusinessType.
     * @example
     * // Update one BusinessType
     * const businessType = await prisma.businessType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessTypeUpdateArgs>(args: SelectSubset<T, BusinessTypeUpdateArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BusinessTypes.
     * @param {BusinessTypeDeleteManyArgs} args - Arguments to filter BusinessTypes to delete.
     * @example
     * // Delete a few BusinessTypes
     * const { count } = await prisma.businessType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessTypeDeleteManyArgs>(args?: SelectSubset<T, BusinessTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessTypes
     * const businessType = await prisma.businessType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessTypeUpdateManyArgs>(args: SelectSubset<T, BusinessTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessTypes and returns the data updated in the database.
     * @param {BusinessTypeUpdateManyAndReturnArgs} args - Arguments to update many BusinessTypes.
     * @example
     * // Update many BusinessTypes
     * const businessType = await prisma.businessType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BusinessTypes and only return the `id`
     * const businessTypeWithIdOnly = await prisma.businessType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusinessTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, BusinessTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BusinessType.
     * @param {BusinessTypeUpsertArgs} args - Arguments to update or create a BusinessType.
     * @example
     * // Update or create a BusinessType
     * const businessType = await prisma.businessType.upsert({
     *   create: {
     *     // ... data to create a BusinessType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessType we want to update
     *   }
     * })
     */
    upsert<T extends BusinessTypeUpsertArgs>(args: SelectSubset<T, BusinessTypeUpsertArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BusinessTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeCountArgs} args - Arguments to filter BusinessTypes to count.
     * @example
     * // Count the number of BusinessTypes
     * const count = await prisma.businessType.count({
     *   where: {
     *     // ... the filter for the BusinessTypes we want to count
     *   }
     * })
    **/
    count<T extends BusinessTypeCountArgs>(
      args?: Subset<T, BusinessTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessTypeAggregateArgs>(args: Subset<T, BusinessTypeAggregateArgs>): Prisma.PrismaPromise<GetBusinessTypeAggregateType<T>>

    /**
     * Group by BusinessType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessTypeGroupByArgs['orderBy'] }
        : { orderBy?: BusinessTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessType model
   */
  readonly fields: BusinessTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    defaults<T extends BusinessType$defaultsArgs<ExtArgs> = {}>(args?: Subset<T, BusinessType$defaultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypeDefaultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pages<T extends BusinessType$pagesArgs<ExtArgs> = {}>(args?: Subset<T, BusinessType$pagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypePagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calculations<T extends BusinessType$calculationsArgs<ExtArgs> = {}>(args?: Subset<T, BusinessType$calculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingCalculationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessType model
   */
  interface BusinessTypeFieldRefs {
    readonly id: FieldRef<"BusinessType", 'String'>
    readonly name: FieldRef<"BusinessType", 'String'>
    readonly slug: FieldRef<"BusinessType", 'String'>
    readonly description: FieldRef<"BusinessType", 'String'>
    readonly basePrice: FieldRef<"BusinessType", 'Decimal'>
    readonly timelineDays: FieldRef<"BusinessType", 'Int'>
    readonly isActive: FieldRef<"BusinessType", 'Boolean'>
    readonly createdAt: FieldRef<"BusinessType", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessType findUnique
   */
  export type BusinessTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessType
     */
    omit?: BusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessType to fetch.
     */
    where: BusinessTypeWhereUniqueInput
  }

  /**
   * BusinessType findUniqueOrThrow
   */
  export type BusinessTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessType
     */
    omit?: BusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessType to fetch.
     */
    where: BusinessTypeWhereUniqueInput
  }

  /**
   * BusinessType findFirst
   */
  export type BusinessTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessType
     */
    omit?: BusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessType to fetch.
     */
    where?: BusinessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypes to fetch.
     */
    orderBy?: BusinessTypeOrderByWithRelationInput | BusinessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessTypes.
     */
    cursor?: BusinessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessTypes.
     */
    distinct?: BusinessTypeScalarFieldEnum | BusinessTypeScalarFieldEnum[]
  }

  /**
   * BusinessType findFirstOrThrow
   */
  export type BusinessTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessType
     */
    omit?: BusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessType to fetch.
     */
    where?: BusinessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypes to fetch.
     */
    orderBy?: BusinessTypeOrderByWithRelationInput | BusinessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessTypes.
     */
    cursor?: BusinessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessTypes.
     */
    distinct?: BusinessTypeScalarFieldEnum | BusinessTypeScalarFieldEnum[]
  }

  /**
   * BusinessType findMany
   */
  export type BusinessTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessType
     */
    omit?: BusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypes to fetch.
     */
    where?: BusinessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypes to fetch.
     */
    orderBy?: BusinessTypeOrderByWithRelationInput | BusinessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessTypes.
     */
    cursor?: BusinessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypes.
     */
    skip?: number
    distinct?: BusinessTypeScalarFieldEnum | BusinessTypeScalarFieldEnum[]
  }

  /**
   * BusinessType create
   */
  export type BusinessTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessType
     */
    omit?: BusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessType.
     */
    data: XOR<BusinessTypeCreateInput, BusinessTypeUncheckedCreateInput>
  }

  /**
   * BusinessType createMany
   */
  export type BusinessTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessTypes.
     */
    data: BusinessTypeCreateManyInput | BusinessTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessType createManyAndReturn
   */
  export type BusinessTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessType
     */
    omit?: BusinessTypeOmit<ExtArgs> | null
    /**
     * The data used to create many BusinessTypes.
     */
    data: BusinessTypeCreateManyInput | BusinessTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessType update
   */
  export type BusinessTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessType
     */
    omit?: BusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessType.
     */
    data: XOR<BusinessTypeUpdateInput, BusinessTypeUncheckedUpdateInput>
    /**
     * Choose, which BusinessType to update.
     */
    where: BusinessTypeWhereUniqueInput
  }

  /**
   * BusinessType updateMany
   */
  export type BusinessTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessTypes.
     */
    data: XOR<BusinessTypeUpdateManyMutationInput, BusinessTypeUncheckedUpdateManyInput>
    /**
     * Filter which BusinessTypes to update
     */
    where?: BusinessTypeWhereInput
    /**
     * Limit how many BusinessTypes to update.
     */
    limit?: number
  }

  /**
   * BusinessType updateManyAndReturn
   */
  export type BusinessTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessType
     */
    omit?: BusinessTypeOmit<ExtArgs> | null
    /**
     * The data used to update BusinessTypes.
     */
    data: XOR<BusinessTypeUpdateManyMutationInput, BusinessTypeUncheckedUpdateManyInput>
    /**
     * Filter which BusinessTypes to update
     */
    where?: BusinessTypeWhereInput
    /**
     * Limit how many BusinessTypes to update.
     */
    limit?: number
  }

  /**
   * BusinessType upsert
   */
  export type BusinessTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessType
     */
    omit?: BusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessType to update in case it exists.
     */
    where: BusinessTypeWhereUniqueInput
    /**
     * In case the BusinessType found by the `where` argument doesn't exist, create a new BusinessType with this data.
     */
    create: XOR<BusinessTypeCreateInput, BusinessTypeUncheckedCreateInput>
    /**
     * In case the BusinessType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessTypeUpdateInput, BusinessTypeUncheckedUpdateInput>
  }

  /**
   * BusinessType delete
   */
  export type BusinessTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessType
     */
    omit?: BusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
    /**
     * Filter which BusinessType to delete.
     */
    where: BusinessTypeWhereUniqueInput
  }

  /**
   * BusinessType deleteMany
   */
  export type BusinessTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessTypes to delete
     */
    where?: BusinessTypeWhereInput
    /**
     * Limit how many BusinessTypes to delete.
     */
    limit?: number
  }

  /**
   * BusinessType.defaults
   */
  export type BusinessType$defaultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeDefault
     */
    select?: BusinessTypeDefaultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypeDefault
     */
    omit?: BusinessTypeDefaultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeDefaultInclude<ExtArgs> | null
    where?: BusinessTypeDefaultWhereInput
    orderBy?: BusinessTypeDefaultOrderByWithRelationInput | BusinessTypeDefaultOrderByWithRelationInput[]
    cursor?: BusinessTypeDefaultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessTypeDefaultScalarFieldEnum | BusinessTypeDefaultScalarFieldEnum[]
  }

  /**
   * BusinessType.pages
   */
  export type BusinessType$pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypePage
     */
    select?: BusinessTypePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypePage
     */
    omit?: BusinessTypePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypePageInclude<ExtArgs> | null
    where?: BusinessTypePageWhereInput
    orderBy?: BusinessTypePageOrderByWithRelationInput | BusinessTypePageOrderByWithRelationInput[]
    cursor?: BusinessTypePageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessTypePageScalarFieldEnum | BusinessTypePageScalarFieldEnum[]
  }

  /**
   * BusinessType.calculations
   */
  export type BusinessType$calculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingCalculation
     */
    select?: PricingCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingCalculation
     */
    omit?: PricingCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingCalculationInclude<ExtArgs> | null
    where?: PricingCalculationWhereInput
    orderBy?: PricingCalculationOrderByWithRelationInput | PricingCalculationOrderByWithRelationInput[]
    cursor?: PricingCalculationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PricingCalculationScalarFieldEnum | PricingCalculationScalarFieldEnum[]
  }

  /**
   * BusinessType without action
   */
  export type BusinessTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessType
     */
    select?: BusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessType
     */
    omit?: BusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeInclude<ExtArgs> | null
  }


  /**
   * Model BusinessTypeDefault
   */

  export type AggregateBusinessTypeDefault = {
    _count: BusinessTypeDefaultCountAggregateOutputType | null
    _avg: BusinessTypeDefaultAvgAggregateOutputType | null
    _sum: BusinessTypeDefaultSumAggregateOutputType | null
    _min: BusinessTypeDefaultMinAggregateOutputType | null
    _max: BusinessTypeDefaultMaxAggregateOutputType | null
  }

  export type BusinessTypeDefaultAvgAggregateOutputType = {
    defaultCount: number | null
  }

  export type BusinessTypeDefaultSumAggregateOutputType = {
    defaultCount: number | null
  }

  export type BusinessTypeDefaultMinAggregateOutputType = {
    id: string | null
    businessTypeId: string | null
    featureId: string | null
    defaultTier: string | null
    defaultCount: number | null
    createdAt: Date | null
  }

  export type BusinessTypeDefaultMaxAggregateOutputType = {
    id: string | null
    businessTypeId: string | null
    featureId: string | null
    defaultTier: string | null
    defaultCount: number | null
    createdAt: Date | null
  }

  export type BusinessTypeDefaultCountAggregateOutputType = {
    id: number
    businessTypeId: number
    featureId: number
    defaultTier: number
    defaultCount: number
    createdAt: number
    _all: number
  }


  export type BusinessTypeDefaultAvgAggregateInputType = {
    defaultCount?: true
  }

  export type BusinessTypeDefaultSumAggregateInputType = {
    defaultCount?: true
  }

  export type BusinessTypeDefaultMinAggregateInputType = {
    id?: true
    businessTypeId?: true
    featureId?: true
    defaultTier?: true
    defaultCount?: true
    createdAt?: true
  }

  export type BusinessTypeDefaultMaxAggregateInputType = {
    id?: true
    businessTypeId?: true
    featureId?: true
    defaultTier?: true
    defaultCount?: true
    createdAt?: true
  }

  export type BusinessTypeDefaultCountAggregateInputType = {
    id?: true
    businessTypeId?: true
    featureId?: true
    defaultTier?: true
    defaultCount?: true
    createdAt?: true
    _all?: true
  }

  export type BusinessTypeDefaultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessTypeDefault to aggregate.
     */
    where?: BusinessTypeDefaultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypeDefaults to fetch.
     */
    orderBy?: BusinessTypeDefaultOrderByWithRelationInput | BusinessTypeDefaultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessTypeDefaultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypeDefaults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypeDefaults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessTypeDefaults
    **/
    _count?: true | BusinessTypeDefaultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessTypeDefaultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessTypeDefaultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessTypeDefaultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessTypeDefaultMaxAggregateInputType
  }

  export type GetBusinessTypeDefaultAggregateType<T extends BusinessTypeDefaultAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessTypeDefault]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessTypeDefault[P]>
      : GetScalarType<T[P], AggregateBusinessTypeDefault[P]>
  }




  export type BusinessTypeDefaultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessTypeDefaultWhereInput
    orderBy?: BusinessTypeDefaultOrderByWithAggregationInput | BusinessTypeDefaultOrderByWithAggregationInput[]
    by: BusinessTypeDefaultScalarFieldEnum[] | BusinessTypeDefaultScalarFieldEnum
    having?: BusinessTypeDefaultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessTypeDefaultCountAggregateInputType | true
    _avg?: BusinessTypeDefaultAvgAggregateInputType
    _sum?: BusinessTypeDefaultSumAggregateInputType
    _min?: BusinessTypeDefaultMinAggregateInputType
    _max?: BusinessTypeDefaultMaxAggregateInputType
  }

  export type BusinessTypeDefaultGroupByOutputType = {
    id: string
    businessTypeId: string
    featureId: string
    defaultTier: string
    defaultCount: number
    createdAt: Date
    _count: BusinessTypeDefaultCountAggregateOutputType | null
    _avg: BusinessTypeDefaultAvgAggregateOutputType | null
    _sum: BusinessTypeDefaultSumAggregateOutputType | null
    _min: BusinessTypeDefaultMinAggregateOutputType | null
    _max: BusinessTypeDefaultMaxAggregateOutputType | null
  }

  type GetBusinessTypeDefaultGroupByPayload<T extends BusinessTypeDefaultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessTypeDefaultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessTypeDefaultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessTypeDefaultGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessTypeDefaultGroupByOutputType[P]>
        }
      >
    >


  export type BusinessTypeDefaultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    featureId?: boolean
    defaultTier?: boolean
    defaultCount?: boolean
    createdAt?: boolean
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessTypeDefault"]>

  export type BusinessTypeDefaultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    featureId?: boolean
    defaultTier?: boolean
    defaultCount?: boolean
    createdAt?: boolean
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessTypeDefault"]>

  export type BusinessTypeDefaultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    featureId?: boolean
    defaultTier?: boolean
    defaultCount?: boolean
    createdAt?: boolean
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessTypeDefault"]>

  export type BusinessTypeDefaultSelectScalar = {
    id?: boolean
    businessTypeId?: boolean
    featureId?: boolean
    defaultTier?: boolean
    defaultCount?: boolean
    createdAt?: boolean
  }

  export type BusinessTypeDefaultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessTypeId" | "featureId" | "defaultTier" | "defaultCount" | "createdAt", ExtArgs["result"]["businessTypeDefault"]>
  export type BusinessTypeDefaultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
  }
  export type BusinessTypeDefaultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
  }
  export type BusinessTypeDefaultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
  }

  export type $BusinessTypeDefaultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessTypeDefault"
    objects: {
      businessType: Prisma.$BusinessTypePayload<ExtArgs>
      feature: Prisma.$FeaturePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessTypeId: string
      featureId: string
      defaultTier: string
      defaultCount: number
      createdAt: Date
    }, ExtArgs["result"]["businessTypeDefault"]>
    composites: {}
  }

  type BusinessTypeDefaultGetPayload<S extends boolean | null | undefined | BusinessTypeDefaultDefaultArgs> = $Result.GetResult<Prisma.$BusinessTypeDefaultPayload, S>

  type BusinessTypeDefaultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusinessTypeDefaultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusinessTypeDefaultCountAggregateInputType | true
    }

  export interface BusinessTypeDefaultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessTypeDefault'], meta: { name: 'BusinessTypeDefault' } }
    /**
     * Find zero or one BusinessTypeDefault that matches the filter.
     * @param {BusinessTypeDefaultFindUniqueArgs} args - Arguments to find a BusinessTypeDefault
     * @example
     * // Get one BusinessTypeDefault
     * const businessTypeDefault = await prisma.businessTypeDefault.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessTypeDefaultFindUniqueArgs>(args: SelectSubset<T, BusinessTypeDefaultFindUniqueArgs<ExtArgs>>): Prisma__BusinessTypeDefaultClient<$Result.GetResult<Prisma.$BusinessTypeDefaultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BusinessTypeDefault that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusinessTypeDefaultFindUniqueOrThrowArgs} args - Arguments to find a BusinessTypeDefault
     * @example
     * // Get one BusinessTypeDefault
     * const businessTypeDefault = await prisma.businessTypeDefault.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessTypeDefaultFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessTypeDefaultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessTypeDefaultClient<$Result.GetResult<Prisma.$BusinessTypeDefaultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessTypeDefault that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeDefaultFindFirstArgs} args - Arguments to find a BusinessTypeDefault
     * @example
     * // Get one BusinessTypeDefault
     * const businessTypeDefault = await prisma.businessTypeDefault.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessTypeDefaultFindFirstArgs>(args?: SelectSubset<T, BusinessTypeDefaultFindFirstArgs<ExtArgs>>): Prisma__BusinessTypeDefaultClient<$Result.GetResult<Prisma.$BusinessTypeDefaultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessTypeDefault that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeDefaultFindFirstOrThrowArgs} args - Arguments to find a BusinessTypeDefault
     * @example
     * // Get one BusinessTypeDefault
     * const businessTypeDefault = await prisma.businessTypeDefault.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessTypeDefaultFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessTypeDefaultFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessTypeDefaultClient<$Result.GetResult<Prisma.$BusinessTypeDefaultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BusinessTypeDefaults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeDefaultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessTypeDefaults
     * const businessTypeDefaults = await prisma.businessTypeDefault.findMany()
     * 
     * // Get first 10 BusinessTypeDefaults
     * const businessTypeDefaults = await prisma.businessTypeDefault.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessTypeDefaultWithIdOnly = await prisma.businessTypeDefault.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessTypeDefaultFindManyArgs>(args?: SelectSubset<T, BusinessTypeDefaultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypeDefaultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BusinessTypeDefault.
     * @param {BusinessTypeDefaultCreateArgs} args - Arguments to create a BusinessTypeDefault.
     * @example
     * // Create one BusinessTypeDefault
     * const BusinessTypeDefault = await prisma.businessTypeDefault.create({
     *   data: {
     *     // ... data to create a BusinessTypeDefault
     *   }
     * })
     * 
     */
    create<T extends BusinessTypeDefaultCreateArgs>(args: SelectSubset<T, BusinessTypeDefaultCreateArgs<ExtArgs>>): Prisma__BusinessTypeDefaultClient<$Result.GetResult<Prisma.$BusinessTypeDefaultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BusinessTypeDefaults.
     * @param {BusinessTypeDefaultCreateManyArgs} args - Arguments to create many BusinessTypeDefaults.
     * @example
     * // Create many BusinessTypeDefaults
     * const businessTypeDefault = await prisma.businessTypeDefault.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessTypeDefaultCreateManyArgs>(args?: SelectSubset<T, BusinessTypeDefaultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessTypeDefaults and returns the data saved in the database.
     * @param {BusinessTypeDefaultCreateManyAndReturnArgs} args - Arguments to create many BusinessTypeDefaults.
     * @example
     * // Create many BusinessTypeDefaults
     * const businessTypeDefault = await prisma.businessTypeDefault.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessTypeDefaults and only return the `id`
     * const businessTypeDefaultWithIdOnly = await prisma.businessTypeDefault.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessTypeDefaultCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessTypeDefaultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypeDefaultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BusinessTypeDefault.
     * @param {BusinessTypeDefaultDeleteArgs} args - Arguments to delete one BusinessTypeDefault.
     * @example
     * // Delete one BusinessTypeDefault
     * const BusinessTypeDefault = await prisma.businessTypeDefault.delete({
     *   where: {
     *     // ... filter to delete one BusinessTypeDefault
     *   }
     * })
     * 
     */
    delete<T extends BusinessTypeDefaultDeleteArgs>(args: SelectSubset<T, BusinessTypeDefaultDeleteArgs<ExtArgs>>): Prisma__BusinessTypeDefaultClient<$Result.GetResult<Prisma.$BusinessTypeDefaultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BusinessTypeDefault.
     * @param {BusinessTypeDefaultUpdateArgs} args - Arguments to update one BusinessTypeDefault.
     * @example
     * // Update one BusinessTypeDefault
     * const businessTypeDefault = await prisma.businessTypeDefault.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessTypeDefaultUpdateArgs>(args: SelectSubset<T, BusinessTypeDefaultUpdateArgs<ExtArgs>>): Prisma__BusinessTypeDefaultClient<$Result.GetResult<Prisma.$BusinessTypeDefaultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BusinessTypeDefaults.
     * @param {BusinessTypeDefaultDeleteManyArgs} args - Arguments to filter BusinessTypeDefaults to delete.
     * @example
     * // Delete a few BusinessTypeDefaults
     * const { count } = await prisma.businessTypeDefault.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessTypeDefaultDeleteManyArgs>(args?: SelectSubset<T, BusinessTypeDefaultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessTypeDefaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeDefaultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessTypeDefaults
     * const businessTypeDefault = await prisma.businessTypeDefault.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessTypeDefaultUpdateManyArgs>(args: SelectSubset<T, BusinessTypeDefaultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessTypeDefaults and returns the data updated in the database.
     * @param {BusinessTypeDefaultUpdateManyAndReturnArgs} args - Arguments to update many BusinessTypeDefaults.
     * @example
     * // Update many BusinessTypeDefaults
     * const businessTypeDefault = await prisma.businessTypeDefault.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BusinessTypeDefaults and only return the `id`
     * const businessTypeDefaultWithIdOnly = await prisma.businessTypeDefault.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusinessTypeDefaultUpdateManyAndReturnArgs>(args: SelectSubset<T, BusinessTypeDefaultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypeDefaultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BusinessTypeDefault.
     * @param {BusinessTypeDefaultUpsertArgs} args - Arguments to update or create a BusinessTypeDefault.
     * @example
     * // Update or create a BusinessTypeDefault
     * const businessTypeDefault = await prisma.businessTypeDefault.upsert({
     *   create: {
     *     // ... data to create a BusinessTypeDefault
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessTypeDefault we want to update
     *   }
     * })
     */
    upsert<T extends BusinessTypeDefaultUpsertArgs>(args: SelectSubset<T, BusinessTypeDefaultUpsertArgs<ExtArgs>>): Prisma__BusinessTypeDefaultClient<$Result.GetResult<Prisma.$BusinessTypeDefaultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BusinessTypeDefaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeDefaultCountArgs} args - Arguments to filter BusinessTypeDefaults to count.
     * @example
     * // Count the number of BusinessTypeDefaults
     * const count = await prisma.businessTypeDefault.count({
     *   where: {
     *     // ... the filter for the BusinessTypeDefaults we want to count
     *   }
     * })
    **/
    count<T extends BusinessTypeDefaultCountArgs>(
      args?: Subset<T, BusinessTypeDefaultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessTypeDefaultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessTypeDefault.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeDefaultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessTypeDefaultAggregateArgs>(args: Subset<T, BusinessTypeDefaultAggregateArgs>): Prisma.PrismaPromise<GetBusinessTypeDefaultAggregateType<T>>

    /**
     * Group by BusinessTypeDefault.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypeDefaultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessTypeDefaultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessTypeDefaultGroupByArgs['orderBy'] }
        : { orderBy?: BusinessTypeDefaultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessTypeDefaultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessTypeDefaultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessTypeDefault model
   */
  readonly fields: BusinessTypeDefaultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessTypeDefault.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessTypeDefaultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessType<T extends BusinessTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessTypeDefaultArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    feature<T extends FeatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatureDefaultArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessTypeDefault model
   */
  interface BusinessTypeDefaultFieldRefs {
    readonly id: FieldRef<"BusinessTypeDefault", 'String'>
    readonly businessTypeId: FieldRef<"BusinessTypeDefault", 'String'>
    readonly featureId: FieldRef<"BusinessTypeDefault", 'String'>
    readonly defaultTier: FieldRef<"BusinessTypeDefault", 'String'>
    readonly defaultCount: FieldRef<"BusinessTypeDefault", 'Int'>
    readonly createdAt: FieldRef<"BusinessTypeDefault", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessTypeDefault findUnique
   */
  export type BusinessTypeDefaultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeDefault
     */
    select?: BusinessTypeDefaultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypeDefault
     */
    omit?: BusinessTypeDefaultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeDefaultInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypeDefault to fetch.
     */
    where: BusinessTypeDefaultWhereUniqueInput
  }

  /**
   * BusinessTypeDefault findUniqueOrThrow
   */
  export type BusinessTypeDefaultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeDefault
     */
    select?: BusinessTypeDefaultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypeDefault
     */
    omit?: BusinessTypeDefaultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeDefaultInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypeDefault to fetch.
     */
    where: BusinessTypeDefaultWhereUniqueInput
  }

  /**
   * BusinessTypeDefault findFirst
   */
  export type BusinessTypeDefaultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeDefault
     */
    select?: BusinessTypeDefaultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypeDefault
     */
    omit?: BusinessTypeDefaultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeDefaultInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypeDefault to fetch.
     */
    where?: BusinessTypeDefaultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypeDefaults to fetch.
     */
    orderBy?: BusinessTypeDefaultOrderByWithRelationInput | BusinessTypeDefaultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessTypeDefaults.
     */
    cursor?: BusinessTypeDefaultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypeDefaults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypeDefaults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessTypeDefaults.
     */
    distinct?: BusinessTypeDefaultScalarFieldEnum | BusinessTypeDefaultScalarFieldEnum[]
  }

  /**
   * BusinessTypeDefault findFirstOrThrow
   */
  export type BusinessTypeDefaultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeDefault
     */
    select?: BusinessTypeDefaultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypeDefault
     */
    omit?: BusinessTypeDefaultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeDefaultInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypeDefault to fetch.
     */
    where?: BusinessTypeDefaultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypeDefaults to fetch.
     */
    orderBy?: BusinessTypeDefaultOrderByWithRelationInput | BusinessTypeDefaultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessTypeDefaults.
     */
    cursor?: BusinessTypeDefaultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypeDefaults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypeDefaults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessTypeDefaults.
     */
    distinct?: BusinessTypeDefaultScalarFieldEnum | BusinessTypeDefaultScalarFieldEnum[]
  }

  /**
   * BusinessTypeDefault findMany
   */
  export type BusinessTypeDefaultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeDefault
     */
    select?: BusinessTypeDefaultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypeDefault
     */
    omit?: BusinessTypeDefaultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeDefaultInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypeDefaults to fetch.
     */
    where?: BusinessTypeDefaultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypeDefaults to fetch.
     */
    orderBy?: BusinessTypeDefaultOrderByWithRelationInput | BusinessTypeDefaultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessTypeDefaults.
     */
    cursor?: BusinessTypeDefaultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypeDefaults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypeDefaults.
     */
    skip?: number
    distinct?: BusinessTypeDefaultScalarFieldEnum | BusinessTypeDefaultScalarFieldEnum[]
  }

  /**
   * BusinessTypeDefault create
   */
  export type BusinessTypeDefaultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeDefault
     */
    select?: BusinessTypeDefaultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypeDefault
     */
    omit?: BusinessTypeDefaultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeDefaultInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessTypeDefault.
     */
    data: XOR<BusinessTypeDefaultCreateInput, BusinessTypeDefaultUncheckedCreateInput>
  }

  /**
   * BusinessTypeDefault createMany
   */
  export type BusinessTypeDefaultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessTypeDefaults.
     */
    data: BusinessTypeDefaultCreateManyInput | BusinessTypeDefaultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessTypeDefault createManyAndReturn
   */
  export type BusinessTypeDefaultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeDefault
     */
    select?: BusinessTypeDefaultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypeDefault
     */
    omit?: BusinessTypeDefaultOmit<ExtArgs> | null
    /**
     * The data used to create many BusinessTypeDefaults.
     */
    data: BusinessTypeDefaultCreateManyInput | BusinessTypeDefaultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeDefaultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessTypeDefault update
   */
  export type BusinessTypeDefaultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeDefault
     */
    select?: BusinessTypeDefaultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypeDefault
     */
    omit?: BusinessTypeDefaultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeDefaultInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessTypeDefault.
     */
    data: XOR<BusinessTypeDefaultUpdateInput, BusinessTypeDefaultUncheckedUpdateInput>
    /**
     * Choose, which BusinessTypeDefault to update.
     */
    where: BusinessTypeDefaultWhereUniqueInput
  }

  /**
   * BusinessTypeDefault updateMany
   */
  export type BusinessTypeDefaultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessTypeDefaults.
     */
    data: XOR<BusinessTypeDefaultUpdateManyMutationInput, BusinessTypeDefaultUncheckedUpdateManyInput>
    /**
     * Filter which BusinessTypeDefaults to update
     */
    where?: BusinessTypeDefaultWhereInput
    /**
     * Limit how many BusinessTypeDefaults to update.
     */
    limit?: number
  }

  /**
   * BusinessTypeDefault updateManyAndReturn
   */
  export type BusinessTypeDefaultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeDefault
     */
    select?: BusinessTypeDefaultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypeDefault
     */
    omit?: BusinessTypeDefaultOmit<ExtArgs> | null
    /**
     * The data used to update BusinessTypeDefaults.
     */
    data: XOR<BusinessTypeDefaultUpdateManyMutationInput, BusinessTypeDefaultUncheckedUpdateManyInput>
    /**
     * Filter which BusinessTypeDefaults to update
     */
    where?: BusinessTypeDefaultWhereInput
    /**
     * Limit how many BusinessTypeDefaults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeDefaultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessTypeDefault upsert
   */
  export type BusinessTypeDefaultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeDefault
     */
    select?: BusinessTypeDefaultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypeDefault
     */
    omit?: BusinessTypeDefaultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeDefaultInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessTypeDefault to update in case it exists.
     */
    where: BusinessTypeDefaultWhereUniqueInput
    /**
     * In case the BusinessTypeDefault found by the `where` argument doesn't exist, create a new BusinessTypeDefault with this data.
     */
    create: XOR<BusinessTypeDefaultCreateInput, BusinessTypeDefaultUncheckedCreateInput>
    /**
     * In case the BusinessTypeDefault was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessTypeDefaultUpdateInput, BusinessTypeDefaultUncheckedUpdateInput>
  }

  /**
   * BusinessTypeDefault delete
   */
  export type BusinessTypeDefaultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeDefault
     */
    select?: BusinessTypeDefaultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypeDefault
     */
    omit?: BusinessTypeDefaultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeDefaultInclude<ExtArgs> | null
    /**
     * Filter which BusinessTypeDefault to delete.
     */
    where: BusinessTypeDefaultWhereUniqueInput
  }

  /**
   * BusinessTypeDefault deleteMany
   */
  export type BusinessTypeDefaultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessTypeDefaults to delete
     */
    where?: BusinessTypeDefaultWhereInput
    /**
     * Limit how many BusinessTypeDefaults to delete.
     */
    limit?: number
  }

  /**
   * BusinessTypeDefault without action
   */
  export type BusinessTypeDefaultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypeDefault
     */
    select?: BusinessTypeDefaultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypeDefault
     */
    omit?: BusinessTypeDefaultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypeDefaultInclude<ExtArgs> | null
  }


  /**
   * Model BusinessTypePage
   */

  export type AggregateBusinessTypePage = {
    _count: BusinessTypePageCountAggregateOutputType | null
    _avg: BusinessTypePageAvgAggregateOutputType | null
    _sum: BusinessTypePageSumAggregateOutputType | null
    _min: BusinessTypePageMinAggregateOutputType | null
    _max: BusinessTypePageMaxAggregateOutputType | null
  }

  export type BusinessTypePageAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type BusinessTypePageSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type BusinessTypePageMinAggregateOutputType = {
    id: string | null
    businessTypeId: string | null
    pageType: string | null
    pageName: string | null
    isDefault: boolean | null
    displayOrder: number | null
    createdAt: Date | null
  }

  export type BusinessTypePageMaxAggregateOutputType = {
    id: string | null
    businessTypeId: string | null
    pageType: string | null
    pageName: string | null
    isDefault: boolean | null
    displayOrder: number | null
    createdAt: Date | null
  }

  export type BusinessTypePageCountAggregateOutputType = {
    id: number
    businessTypeId: number
    pageType: number
    pageName: number
    isDefault: number
    displayOrder: number
    createdAt: number
    _all: number
  }


  export type BusinessTypePageAvgAggregateInputType = {
    displayOrder?: true
  }

  export type BusinessTypePageSumAggregateInputType = {
    displayOrder?: true
  }

  export type BusinessTypePageMinAggregateInputType = {
    id?: true
    businessTypeId?: true
    pageType?: true
    pageName?: true
    isDefault?: true
    displayOrder?: true
    createdAt?: true
  }

  export type BusinessTypePageMaxAggregateInputType = {
    id?: true
    businessTypeId?: true
    pageType?: true
    pageName?: true
    isDefault?: true
    displayOrder?: true
    createdAt?: true
  }

  export type BusinessTypePageCountAggregateInputType = {
    id?: true
    businessTypeId?: true
    pageType?: true
    pageName?: true
    isDefault?: true
    displayOrder?: true
    createdAt?: true
    _all?: true
  }

  export type BusinessTypePageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessTypePage to aggregate.
     */
    where?: BusinessTypePageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypePages to fetch.
     */
    orderBy?: BusinessTypePageOrderByWithRelationInput | BusinessTypePageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessTypePageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypePages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypePages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessTypePages
    **/
    _count?: true | BusinessTypePageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessTypePageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessTypePageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessTypePageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessTypePageMaxAggregateInputType
  }

  export type GetBusinessTypePageAggregateType<T extends BusinessTypePageAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessTypePage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessTypePage[P]>
      : GetScalarType<T[P], AggregateBusinessTypePage[P]>
  }




  export type BusinessTypePageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessTypePageWhereInput
    orderBy?: BusinessTypePageOrderByWithAggregationInput | BusinessTypePageOrderByWithAggregationInput[]
    by: BusinessTypePageScalarFieldEnum[] | BusinessTypePageScalarFieldEnum
    having?: BusinessTypePageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessTypePageCountAggregateInputType | true
    _avg?: BusinessTypePageAvgAggregateInputType
    _sum?: BusinessTypePageSumAggregateInputType
    _min?: BusinessTypePageMinAggregateInputType
    _max?: BusinessTypePageMaxAggregateInputType
  }

  export type BusinessTypePageGroupByOutputType = {
    id: string
    businessTypeId: string
    pageType: string
    pageName: string
    isDefault: boolean
    displayOrder: number | null
    createdAt: Date
    _count: BusinessTypePageCountAggregateOutputType | null
    _avg: BusinessTypePageAvgAggregateOutputType | null
    _sum: BusinessTypePageSumAggregateOutputType | null
    _min: BusinessTypePageMinAggregateOutputType | null
    _max: BusinessTypePageMaxAggregateOutputType | null
  }

  type GetBusinessTypePageGroupByPayload<T extends BusinessTypePageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessTypePageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessTypePageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessTypePageGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessTypePageGroupByOutputType[P]>
        }
      >
    >


  export type BusinessTypePageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    pageType?: boolean
    pageName?: boolean
    isDefault?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessTypePage"]>

  export type BusinessTypePageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    pageType?: boolean
    pageName?: boolean
    isDefault?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessTypePage"]>

  export type BusinessTypePageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessTypeId?: boolean
    pageType?: boolean
    pageName?: boolean
    isDefault?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessTypePage"]>

  export type BusinessTypePageSelectScalar = {
    id?: boolean
    businessTypeId?: boolean
    pageType?: boolean
    pageName?: boolean
    isDefault?: boolean
    displayOrder?: boolean
    createdAt?: boolean
  }

  export type BusinessTypePageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessTypeId" | "pageType" | "pageName" | "isDefault" | "displayOrder" | "createdAt", ExtArgs["result"]["businessTypePage"]>
  export type BusinessTypePageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
  }
  export type BusinessTypePageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
  }
  export type BusinessTypePageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
  }

  export type $BusinessTypePagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessTypePage"
    objects: {
      businessType: Prisma.$BusinessTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessTypeId: string
      pageType: string
      pageName: string
      isDefault: boolean
      displayOrder: number | null
      createdAt: Date
    }, ExtArgs["result"]["businessTypePage"]>
    composites: {}
  }

  type BusinessTypePageGetPayload<S extends boolean | null | undefined | BusinessTypePageDefaultArgs> = $Result.GetResult<Prisma.$BusinessTypePagePayload, S>

  type BusinessTypePageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusinessTypePageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusinessTypePageCountAggregateInputType | true
    }

  export interface BusinessTypePageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessTypePage'], meta: { name: 'BusinessTypePage' } }
    /**
     * Find zero or one BusinessTypePage that matches the filter.
     * @param {BusinessTypePageFindUniqueArgs} args - Arguments to find a BusinessTypePage
     * @example
     * // Get one BusinessTypePage
     * const businessTypePage = await prisma.businessTypePage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessTypePageFindUniqueArgs>(args: SelectSubset<T, BusinessTypePageFindUniqueArgs<ExtArgs>>): Prisma__BusinessTypePageClient<$Result.GetResult<Prisma.$BusinessTypePagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BusinessTypePage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusinessTypePageFindUniqueOrThrowArgs} args - Arguments to find a BusinessTypePage
     * @example
     * // Get one BusinessTypePage
     * const businessTypePage = await prisma.businessTypePage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessTypePageFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessTypePageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessTypePageClient<$Result.GetResult<Prisma.$BusinessTypePagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessTypePage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypePageFindFirstArgs} args - Arguments to find a BusinessTypePage
     * @example
     * // Get one BusinessTypePage
     * const businessTypePage = await prisma.businessTypePage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessTypePageFindFirstArgs>(args?: SelectSubset<T, BusinessTypePageFindFirstArgs<ExtArgs>>): Prisma__BusinessTypePageClient<$Result.GetResult<Prisma.$BusinessTypePagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessTypePage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypePageFindFirstOrThrowArgs} args - Arguments to find a BusinessTypePage
     * @example
     * // Get one BusinessTypePage
     * const businessTypePage = await prisma.businessTypePage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessTypePageFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessTypePageFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessTypePageClient<$Result.GetResult<Prisma.$BusinessTypePagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BusinessTypePages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypePageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessTypePages
     * const businessTypePages = await prisma.businessTypePage.findMany()
     * 
     * // Get first 10 BusinessTypePages
     * const businessTypePages = await prisma.businessTypePage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessTypePageWithIdOnly = await prisma.businessTypePage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessTypePageFindManyArgs>(args?: SelectSubset<T, BusinessTypePageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypePagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BusinessTypePage.
     * @param {BusinessTypePageCreateArgs} args - Arguments to create a BusinessTypePage.
     * @example
     * // Create one BusinessTypePage
     * const BusinessTypePage = await prisma.businessTypePage.create({
     *   data: {
     *     // ... data to create a BusinessTypePage
     *   }
     * })
     * 
     */
    create<T extends BusinessTypePageCreateArgs>(args: SelectSubset<T, BusinessTypePageCreateArgs<ExtArgs>>): Prisma__BusinessTypePageClient<$Result.GetResult<Prisma.$BusinessTypePagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BusinessTypePages.
     * @param {BusinessTypePageCreateManyArgs} args - Arguments to create many BusinessTypePages.
     * @example
     * // Create many BusinessTypePages
     * const businessTypePage = await prisma.businessTypePage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessTypePageCreateManyArgs>(args?: SelectSubset<T, BusinessTypePageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessTypePages and returns the data saved in the database.
     * @param {BusinessTypePageCreateManyAndReturnArgs} args - Arguments to create many BusinessTypePages.
     * @example
     * // Create many BusinessTypePages
     * const businessTypePage = await prisma.businessTypePage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessTypePages and only return the `id`
     * const businessTypePageWithIdOnly = await prisma.businessTypePage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessTypePageCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessTypePageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypePagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BusinessTypePage.
     * @param {BusinessTypePageDeleteArgs} args - Arguments to delete one BusinessTypePage.
     * @example
     * // Delete one BusinessTypePage
     * const BusinessTypePage = await prisma.businessTypePage.delete({
     *   where: {
     *     // ... filter to delete one BusinessTypePage
     *   }
     * })
     * 
     */
    delete<T extends BusinessTypePageDeleteArgs>(args: SelectSubset<T, BusinessTypePageDeleteArgs<ExtArgs>>): Prisma__BusinessTypePageClient<$Result.GetResult<Prisma.$BusinessTypePagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BusinessTypePage.
     * @param {BusinessTypePageUpdateArgs} args - Arguments to update one BusinessTypePage.
     * @example
     * // Update one BusinessTypePage
     * const businessTypePage = await prisma.businessTypePage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessTypePageUpdateArgs>(args: SelectSubset<T, BusinessTypePageUpdateArgs<ExtArgs>>): Prisma__BusinessTypePageClient<$Result.GetResult<Prisma.$BusinessTypePagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BusinessTypePages.
     * @param {BusinessTypePageDeleteManyArgs} args - Arguments to filter BusinessTypePages to delete.
     * @example
     * // Delete a few BusinessTypePages
     * const { count } = await prisma.businessTypePage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessTypePageDeleteManyArgs>(args?: SelectSubset<T, BusinessTypePageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessTypePages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypePageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessTypePages
     * const businessTypePage = await prisma.businessTypePage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessTypePageUpdateManyArgs>(args: SelectSubset<T, BusinessTypePageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessTypePages and returns the data updated in the database.
     * @param {BusinessTypePageUpdateManyAndReturnArgs} args - Arguments to update many BusinessTypePages.
     * @example
     * // Update many BusinessTypePages
     * const businessTypePage = await prisma.businessTypePage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BusinessTypePages and only return the `id`
     * const businessTypePageWithIdOnly = await prisma.businessTypePage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusinessTypePageUpdateManyAndReturnArgs>(args: SelectSubset<T, BusinessTypePageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessTypePagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BusinessTypePage.
     * @param {BusinessTypePageUpsertArgs} args - Arguments to update or create a BusinessTypePage.
     * @example
     * // Update or create a BusinessTypePage
     * const businessTypePage = await prisma.businessTypePage.upsert({
     *   create: {
     *     // ... data to create a BusinessTypePage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessTypePage we want to update
     *   }
     * })
     */
    upsert<T extends BusinessTypePageUpsertArgs>(args: SelectSubset<T, BusinessTypePageUpsertArgs<ExtArgs>>): Prisma__BusinessTypePageClient<$Result.GetResult<Prisma.$BusinessTypePagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BusinessTypePages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypePageCountArgs} args - Arguments to filter BusinessTypePages to count.
     * @example
     * // Count the number of BusinessTypePages
     * const count = await prisma.businessTypePage.count({
     *   where: {
     *     // ... the filter for the BusinessTypePages we want to count
     *   }
     * })
    **/
    count<T extends BusinessTypePageCountArgs>(
      args?: Subset<T, BusinessTypePageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessTypePageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessTypePage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypePageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessTypePageAggregateArgs>(args: Subset<T, BusinessTypePageAggregateArgs>): Prisma.PrismaPromise<GetBusinessTypePageAggregateType<T>>

    /**
     * Group by BusinessTypePage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessTypePageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessTypePageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessTypePageGroupByArgs['orderBy'] }
        : { orderBy?: BusinessTypePageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessTypePageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessTypePageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessTypePage model
   */
  readonly fields: BusinessTypePageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessTypePage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessTypePageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessType<T extends BusinessTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessTypeDefaultArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessTypePage model
   */
  interface BusinessTypePageFieldRefs {
    readonly id: FieldRef<"BusinessTypePage", 'String'>
    readonly businessTypeId: FieldRef<"BusinessTypePage", 'String'>
    readonly pageType: FieldRef<"BusinessTypePage", 'String'>
    readonly pageName: FieldRef<"BusinessTypePage", 'String'>
    readonly isDefault: FieldRef<"BusinessTypePage", 'Boolean'>
    readonly displayOrder: FieldRef<"BusinessTypePage", 'Int'>
    readonly createdAt: FieldRef<"BusinessTypePage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessTypePage findUnique
   */
  export type BusinessTypePageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypePage
     */
    select?: BusinessTypePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypePage
     */
    omit?: BusinessTypePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypePageInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypePage to fetch.
     */
    where: BusinessTypePageWhereUniqueInput
  }

  /**
   * BusinessTypePage findUniqueOrThrow
   */
  export type BusinessTypePageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypePage
     */
    select?: BusinessTypePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypePage
     */
    omit?: BusinessTypePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypePageInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypePage to fetch.
     */
    where: BusinessTypePageWhereUniqueInput
  }

  /**
   * BusinessTypePage findFirst
   */
  export type BusinessTypePageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypePage
     */
    select?: BusinessTypePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypePage
     */
    omit?: BusinessTypePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypePageInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypePage to fetch.
     */
    where?: BusinessTypePageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypePages to fetch.
     */
    orderBy?: BusinessTypePageOrderByWithRelationInput | BusinessTypePageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessTypePages.
     */
    cursor?: BusinessTypePageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypePages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypePages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessTypePages.
     */
    distinct?: BusinessTypePageScalarFieldEnum | BusinessTypePageScalarFieldEnum[]
  }

  /**
   * BusinessTypePage findFirstOrThrow
   */
  export type BusinessTypePageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypePage
     */
    select?: BusinessTypePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypePage
     */
    omit?: BusinessTypePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypePageInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypePage to fetch.
     */
    where?: BusinessTypePageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypePages to fetch.
     */
    orderBy?: BusinessTypePageOrderByWithRelationInput | BusinessTypePageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessTypePages.
     */
    cursor?: BusinessTypePageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypePages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypePages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessTypePages.
     */
    distinct?: BusinessTypePageScalarFieldEnum | BusinessTypePageScalarFieldEnum[]
  }

  /**
   * BusinessTypePage findMany
   */
  export type BusinessTypePageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypePage
     */
    select?: BusinessTypePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypePage
     */
    omit?: BusinessTypePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypePageInclude<ExtArgs> | null
    /**
     * Filter, which BusinessTypePages to fetch.
     */
    where?: BusinessTypePageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessTypePages to fetch.
     */
    orderBy?: BusinessTypePageOrderByWithRelationInput | BusinessTypePageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessTypePages.
     */
    cursor?: BusinessTypePageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessTypePages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessTypePages.
     */
    skip?: number
    distinct?: BusinessTypePageScalarFieldEnum | BusinessTypePageScalarFieldEnum[]
  }

  /**
   * BusinessTypePage create
   */
  export type BusinessTypePageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypePage
     */
    select?: BusinessTypePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypePage
     */
    omit?: BusinessTypePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypePageInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessTypePage.
     */
    data: XOR<BusinessTypePageCreateInput, BusinessTypePageUncheckedCreateInput>
  }

  /**
   * BusinessTypePage createMany
   */
  export type BusinessTypePageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessTypePages.
     */
    data: BusinessTypePageCreateManyInput | BusinessTypePageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessTypePage createManyAndReturn
   */
  export type BusinessTypePageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypePage
     */
    select?: BusinessTypePageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypePage
     */
    omit?: BusinessTypePageOmit<ExtArgs> | null
    /**
     * The data used to create many BusinessTypePages.
     */
    data: BusinessTypePageCreateManyInput | BusinessTypePageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypePageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessTypePage update
   */
  export type BusinessTypePageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypePage
     */
    select?: BusinessTypePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypePage
     */
    omit?: BusinessTypePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypePageInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessTypePage.
     */
    data: XOR<BusinessTypePageUpdateInput, BusinessTypePageUncheckedUpdateInput>
    /**
     * Choose, which BusinessTypePage to update.
     */
    where: BusinessTypePageWhereUniqueInput
  }

  /**
   * BusinessTypePage updateMany
   */
  export type BusinessTypePageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessTypePages.
     */
    data: XOR<BusinessTypePageUpdateManyMutationInput, BusinessTypePageUncheckedUpdateManyInput>
    /**
     * Filter which BusinessTypePages to update
     */
    where?: BusinessTypePageWhereInput
    /**
     * Limit how many BusinessTypePages to update.
     */
    limit?: number
  }

  /**
   * BusinessTypePage updateManyAndReturn
   */
  export type BusinessTypePageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypePage
     */
    select?: BusinessTypePageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypePage
     */
    omit?: BusinessTypePageOmit<ExtArgs> | null
    /**
     * The data used to update BusinessTypePages.
     */
    data: XOR<BusinessTypePageUpdateManyMutationInput, BusinessTypePageUncheckedUpdateManyInput>
    /**
     * Filter which BusinessTypePages to update
     */
    where?: BusinessTypePageWhereInput
    /**
     * Limit how many BusinessTypePages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypePageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessTypePage upsert
   */
  export type BusinessTypePageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypePage
     */
    select?: BusinessTypePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypePage
     */
    omit?: BusinessTypePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypePageInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessTypePage to update in case it exists.
     */
    where: BusinessTypePageWhereUniqueInput
    /**
     * In case the BusinessTypePage found by the `where` argument doesn't exist, create a new BusinessTypePage with this data.
     */
    create: XOR<BusinessTypePageCreateInput, BusinessTypePageUncheckedCreateInput>
    /**
     * In case the BusinessTypePage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessTypePageUpdateInput, BusinessTypePageUncheckedUpdateInput>
  }

  /**
   * BusinessTypePage delete
   */
  export type BusinessTypePageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypePage
     */
    select?: BusinessTypePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypePage
     */
    omit?: BusinessTypePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypePageInclude<ExtArgs> | null
    /**
     * Filter which BusinessTypePage to delete.
     */
    where: BusinessTypePageWhereUniqueInput
  }

  /**
   * BusinessTypePage deleteMany
   */
  export type BusinessTypePageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessTypePages to delete
     */
    where?: BusinessTypePageWhereInput
    /**
     * Limit how many BusinessTypePages to delete.
     */
    limit?: number
  }

  /**
   * BusinessTypePage without action
   */
  export type BusinessTypePageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessTypePage
     */
    select?: BusinessTypePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessTypePage
     */
    omit?: BusinessTypePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessTypePageInclude<ExtArgs> | null
  }


  /**
   * Model ServiceCategory
   */

  export type AggregateServiceCategory = {
    _count: ServiceCategoryCountAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  export type ServiceCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    createdAt: Date | null
  }

  export type ServiceCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    createdAt: Date | null
  }

  export type ServiceCategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    createdAt: number
    _all: number
  }


  export type ServiceCategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
  }

  export type ServiceCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
  }

  export type ServiceCategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategory to aggregate.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceCategories
    **/
    _count?: true | ServiceCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type GetServiceCategoryAggregateType<T extends ServiceCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceCategory[P]>
      : GetScalarType<T[P], AggregateServiceCategory[P]>
  }




  export type ServiceCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceCategoryWhereInput
    orderBy?: ServiceCategoryOrderByWithAggregationInput | ServiceCategoryOrderByWithAggregationInput[]
    by: ServiceCategoryScalarFieldEnum[] | ServiceCategoryScalarFieldEnum
    having?: ServiceCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCategoryCountAggregateInputType | true
    _min?: ServiceCategoryMinAggregateInputType
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type ServiceCategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    createdAt: Date
    _count: ServiceCategoryCountAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  type GetServiceCategoryGroupByPayload<T extends ServiceCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ServiceCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    services?: boolean | ServiceCategory$servicesArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type ServiceCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "createdAt", ExtArgs["result"]["serviceCategory"]>
  export type ServiceCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceCategory$servicesArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceCategory"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["serviceCategory"]>
    composites: {}
  }

  type ServiceCategoryGetPayload<S extends boolean | null | undefined | ServiceCategoryDefaultArgs> = $Result.GetResult<Prisma.$ServiceCategoryPayload, S>

  type ServiceCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCategoryCountAggregateInputType | true
    }

  export interface ServiceCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceCategory'], meta: { name: 'ServiceCategory' } }
    /**
     * Find zero or one ServiceCategory that matches the filter.
     * @param {ServiceCategoryFindUniqueArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceCategoryFindUniqueArgs>(args: SelectSubset<T, ServiceCategoryFindUniqueArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceCategoryFindUniqueOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceCategoryFindFirstArgs>(args?: SelectSubset<T, ServiceCategoryFindFirstArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany()
     * 
     * // Get first 10 ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceCategoryFindManyArgs>(args?: SelectSubset<T, ServiceCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceCategory.
     * @param {ServiceCategoryCreateArgs} args - Arguments to create a ServiceCategory.
     * @example
     * // Create one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.create({
     *   data: {
     *     // ... data to create a ServiceCategory
     *   }
     * })
     * 
     */
    create<T extends ServiceCategoryCreateArgs>(args: SelectSubset<T, ServiceCategoryCreateArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceCategories.
     * @param {ServiceCategoryCreateManyArgs} args - Arguments to create many ServiceCategories.
     * @example
     * // Create many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCategoryCreateManyArgs>(args?: SelectSubset<T, ServiceCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceCategories and returns the data saved in the database.
     * @param {ServiceCategoryCreateManyAndReturnArgs} args - Arguments to create many ServiceCategories.
     * @example
     * // Create many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceCategories and only return the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceCategory.
     * @param {ServiceCategoryDeleteArgs} args - Arguments to delete one ServiceCategory.
     * @example
     * // Delete one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.delete({
     *   where: {
     *     // ... filter to delete one ServiceCategory
     *   }
     * })
     * 
     */
    delete<T extends ServiceCategoryDeleteArgs>(args: SelectSubset<T, ServiceCategoryDeleteArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceCategory.
     * @param {ServiceCategoryUpdateArgs} args - Arguments to update one ServiceCategory.
     * @example
     * // Update one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceCategoryUpdateArgs>(args: SelectSubset<T, ServiceCategoryUpdateArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceCategories.
     * @param {ServiceCategoryDeleteManyArgs} args - Arguments to filter ServiceCategories to delete.
     * @example
     * // Delete a few ServiceCategories
     * const { count } = await prisma.serviceCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceCategoryDeleteManyArgs>(args?: SelectSubset<T, ServiceCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceCategoryUpdateManyArgs>(args: SelectSubset<T, ServiceCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategories and returns the data updated in the database.
     * @param {ServiceCategoryUpdateManyAndReturnArgs} args - Arguments to update many ServiceCategories.
     * @example
     * // Update many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceCategories and only return the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceCategory.
     * @param {ServiceCategoryUpsertArgs} args - Arguments to update or create a ServiceCategory.
     * @example
     * // Update or create a ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.upsert({
     *   create: {
     *     // ... data to create a ServiceCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceCategory we want to update
     *   }
     * })
     */
    upsert<T extends ServiceCategoryUpsertArgs>(args: SelectSubset<T, ServiceCategoryUpsertArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryCountArgs} args - Arguments to filter ServiceCategories to count.
     * @example
     * // Count the number of ServiceCategories
     * const count = await prisma.serviceCategory.count({
     *   where: {
     *     // ... the filter for the ServiceCategories we want to count
     *   }
     * })
    **/
    count<T extends ServiceCategoryCountArgs>(
      args?: Subset<T, ServiceCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceCategoryAggregateArgs>(args: Subset<T, ServiceCategoryAggregateArgs>): Prisma.PrismaPromise<GetServiceCategoryAggregateType<T>>

    /**
     * Group by ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ServiceCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceCategory model
   */
  readonly fields: ServiceCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends ServiceCategory$servicesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategory$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceCategory model
   */
  interface ServiceCategoryFieldRefs {
    readonly id: FieldRef<"ServiceCategory", 'String'>
    readonly name: FieldRef<"ServiceCategory", 'String'>
    readonly slug: FieldRef<"ServiceCategory", 'String'>
    readonly description: FieldRef<"ServiceCategory", 'String'>
    readonly createdAt: FieldRef<"ServiceCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceCategory findUnique
   */
  export type ServiceCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findUniqueOrThrow
   */
  export type ServiceCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findFirst
   */
  export type ServiceCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory findFirstOrThrow
   */
  export type ServiceCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory findMany
   */
  export type ServiceCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategories to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory create
   */
  export type ServiceCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceCategory.
     */
    data: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
  }

  /**
   * ServiceCategory createMany
   */
  export type ServiceCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceCategories.
     */
    data: ServiceCategoryCreateManyInput | ServiceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCategory createManyAndReturn
   */
  export type ServiceCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceCategories.
     */
    data: ServiceCategoryCreateManyInput | ServiceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCategory update
   */
  export type ServiceCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceCategory.
     */
    data: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
    /**
     * Choose, which ServiceCategory to update.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory updateMany
   */
  export type ServiceCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceCategories.
     */
    data: XOR<ServiceCategoryUpdateManyMutationInput, ServiceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCategories to update
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to update.
     */
    limit?: number
  }

  /**
   * ServiceCategory updateManyAndReturn
   */
  export type ServiceCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ServiceCategories.
     */
    data: XOR<ServiceCategoryUpdateManyMutationInput, ServiceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCategories to update
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to update.
     */
    limit?: number
  }

  /**
   * ServiceCategory upsert
   */
  export type ServiceCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceCategory to update in case it exists.
     */
    where: ServiceCategoryWhereUniqueInput
    /**
     * In case the ServiceCategory found by the `where` argument doesn't exist, create a new ServiceCategory with this data.
     */
    create: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
    /**
     * In case the ServiceCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
  }

  /**
   * ServiceCategory delete
   */
  export type ServiceCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter which ServiceCategory to delete.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory deleteMany
   */
  export type ServiceCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategories to delete
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to delete.
     */
    limit?: number
  }

  /**
   * ServiceCategory.services
   */
  export type ServiceCategory$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * ServiceCategory without action
   */
  export type ServiceCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    priceMin: Decimal | null
    priceMax: Decimal | null
  }

  export type ServiceSumAggregateOutputType = {
    priceMin: Decimal | null
    priceMax: Decimal | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    categoryId: string | null
    priceMin: Decimal | null
    priceMax: Decimal | null
    demoUrl: string | null
    iconName: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    categoryId: string | null
    priceMin: Decimal | null
    priceMax: Decimal | null
    demoUrl: string | null
    iconName: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    categoryId: number
    priceMin: number
    priceMax: number
    demoUrl: number
    iconName: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    priceMin?: true
    priceMax?: true
  }

  export type ServiceSumAggregateInputType = {
    priceMin?: true
    priceMax?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    categoryId?: true
    priceMin?: true
    priceMax?: true
    demoUrl?: true
    iconName?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    categoryId?: true
    priceMin?: true
    priceMax?: true
    demoUrl?: true
    iconName?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    categoryId?: true
    priceMin?: true
    priceMax?: true
    demoUrl?: true
    iconName?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    categoryId: string
    priceMin: Decimal | null
    priceMax: Decimal | null
    demoUrl: string | null
    iconName: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    categoryId?: boolean
    priceMin?: boolean
    priceMax?: boolean
    demoUrl?: boolean
    iconName?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    categoryId?: boolean
    priceMin?: boolean
    priceMax?: boolean
    demoUrl?: boolean
    iconName?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    categoryId?: boolean
    priceMin?: boolean
    priceMax?: boolean
    demoUrl?: boolean
    iconName?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    categoryId?: boolean
    priceMin?: boolean
    priceMax?: boolean
    demoUrl?: boolean
    iconName?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "categoryId" | "priceMin" | "priceMax" | "demoUrl" | "iconName" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      category: Prisma.$ServiceCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      categoryId: string
      priceMin: Prisma.Decimal | null
      priceMax: Prisma.Decimal | null
      demoUrl: string | null
      iconName: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends ServiceCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategoryDefaultArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly slug: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly categoryId: FieldRef<"Service", 'String'>
    readonly priceMin: FieldRef<"Service", 'Decimal'>
    readonly priceMax: FieldRef<"Service", 'Decimal'>
    readonly demoUrl: FieldRef<"Service", 'String'>
    readonly iconName: FieldRef<"Service", 'String'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    company: string | null
    projectType: string | null
    budgetRange: string | null
    timeline: string | null
    description: string | null
    preferredPackage: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    company: string | null
    projectType: string | null
    budgetRange: string | null
    timeline: string | null
    description: string | null
    preferredPackage: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    company: number
    projectType: number
    budgetRange: number
    timeline: number
    description: number
    preferredPackage: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    projectType?: true
    budgetRange?: true
    timeline?: true
    description?: true
    preferredPackage?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    projectType?: true
    budgetRange?: true
    timeline?: true
    description?: true
    preferredPackage?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    projectType?: true
    budgetRange?: true
    timeline?: true
    description?: true
    preferredPackage?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    company: string | null
    projectType: string | null
    budgetRange: string | null
    timeline: string | null
    description: string | null
    preferredPackage: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    projectType?: boolean
    budgetRange?: boolean
    timeline?: boolean
    description?: boolean
    preferredPackage?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    formSteps?: boolean | Contact$formStepsArgs<ExtArgs>
    calculations?: boolean | Contact$calculationsArgs<ExtArgs>
    timeSlots?: boolean | Contact$timeSlotsArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    projectType?: boolean
    budgetRange?: boolean
    timeline?: boolean
    description?: boolean
    preferredPackage?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    projectType?: boolean
    budgetRange?: boolean
    timeline?: boolean
    description?: boolean
    preferredPackage?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    projectType?: boolean
    budgetRange?: boolean
    timeline?: boolean
    description?: boolean
    preferredPackage?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "company" | "projectType" | "budgetRange" | "timeline" | "description" | "preferredPackage" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formSteps?: boolean | Contact$formStepsArgs<ExtArgs>
    calculations?: boolean | Contact$calculationsArgs<ExtArgs>
    timeSlots?: boolean | Contact$timeSlotsArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      formSteps: Prisma.$ContactFormStepPayload<ExtArgs>[]
      calculations: Prisma.$PricingCalculationPayload<ExtArgs>[]
      timeSlots: Prisma.$TimeSlotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      company: string | null
      projectType: string | null
      budgetRange: string | null
      timeline: string | null
      description: string | null
      preferredPackage: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    formSteps<T extends Contact$formStepsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$formStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactFormStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calculations<T extends Contact$calculationsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$calculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingCalculationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeSlots<T extends Contact$timeSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$timeSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly company: FieldRef<"Contact", 'String'>
    readonly projectType: FieldRef<"Contact", 'String'>
    readonly budgetRange: FieldRef<"Contact", 'String'>
    readonly timeline: FieldRef<"Contact", 'String'>
    readonly description: FieldRef<"Contact", 'String'>
    readonly preferredPackage: FieldRef<"Contact", 'String'>
    readonly status: FieldRef<"Contact", 'String'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.formSteps
   */
  export type Contact$formStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFormStep
     */
    select?: ContactFormStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFormStep
     */
    omit?: ContactFormStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormStepInclude<ExtArgs> | null
    where?: ContactFormStepWhereInput
    orderBy?: ContactFormStepOrderByWithRelationInput | ContactFormStepOrderByWithRelationInput[]
    cursor?: ContactFormStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactFormStepScalarFieldEnum | ContactFormStepScalarFieldEnum[]
  }

  /**
   * Contact.calculations
   */
  export type Contact$calculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingCalculation
     */
    select?: PricingCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingCalculation
     */
    omit?: PricingCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingCalculationInclude<ExtArgs> | null
    where?: PricingCalculationWhereInput
    orderBy?: PricingCalculationOrderByWithRelationInput | PricingCalculationOrderByWithRelationInput[]
    cursor?: PricingCalculationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PricingCalculationScalarFieldEnum | PricingCalculationScalarFieldEnum[]
  }

  /**
   * Contact.timeSlots
   */
  export type Contact$timeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    where?: TimeSlotWhereInput
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    cursor?: TimeSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model TimeSlot
   */

  export type AggregateTimeSlot = {
    _count: TimeSlotCountAggregateOutputType | null
    _min: TimeSlotMinAggregateOutputType | null
    _max: TimeSlotMaxAggregateOutputType | null
  }

  export type TimeSlotMinAggregateOutputType = {
    id: string | null
    date: Date | null
    time: Date | null
    isAvailable: boolean | null
    contactId: string | null
    createdAt: Date | null
  }

  export type TimeSlotMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    time: Date | null
    isAvailable: boolean | null
    contactId: string | null
    createdAt: Date | null
  }

  export type TimeSlotCountAggregateOutputType = {
    id: number
    date: number
    time: number
    isAvailable: number
    contactId: number
    createdAt: number
    _all: number
  }


  export type TimeSlotMinAggregateInputType = {
    id?: true
    date?: true
    time?: true
    isAvailable?: true
    contactId?: true
    createdAt?: true
  }

  export type TimeSlotMaxAggregateInputType = {
    id?: true
    date?: true
    time?: true
    isAvailable?: true
    contactId?: true
    createdAt?: true
  }

  export type TimeSlotCountAggregateInputType = {
    id?: true
    date?: true
    time?: true
    isAvailable?: true
    contactId?: true
    createdAt?: true
    _all?: true
  }

  export type TimeSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSlot to aggregate.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeSlots
    **/
    _count?: true | TimeSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeSlotMaxAggregateInputType
  }

  export type GetTimeSlotAggregateType<T extends TimeSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeSlot[P]>
      : GetScalarType<T[P], AggregateTimeSlot[P]>
  }




  export type TimeSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSlotWhereInput
    orderBy?: TimeSlotOrderByWithAggregationInput | TimeSlotOrderByWithAggregationInput[]
    by: TimeSlotScalarFieldEnum[] | TimeSlotScalarFieldEnum
    having?: TimeSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeSlotCountAggregateInputType | true
    _min?: TimeSlotMinAggregateInputType
    _max?: TimeSlotMaxAggregateInputType
  }

  export type TimeSlotGroupByOutputType = {
    id: string
    date: Date
    time: Date
    isAvailable: boolean
    contactId: string | null
    createdAt: Date
    _count: TimeSlotCountAggregateOutputType | null
    _min: TimeSlotMinAggregateOutputType | null
    _max: TimeSlotMaxAggregateOutputType | null
  }

  type GetTimeSlotGroupByPayload<T extends TimeSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeSlotGroupByOutputType[P]>
            : GetScalarType<T[P], TimeSlotGroupByOutputType[P]>
        }
      >
    >


  export type TimeSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    isAvailable?: boolean
    contactId?: boolean
    createdAt?: boolean
    contact?: boolean | TimeSlot$contactArgs<ExtArgs>
  }, ExtArgs["result"]["timeSlot"]>

  export type TimeSlotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    isAvailable?: boolean
    contactId?: boolean
    createdAt?: boolean
    contact?: boolean | TimeSlot$contactArgs<ExtArgs>
  }, ExtArgs["result"]["timeSlot"]>

  export type TimeSlotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    isAvailable?: boolean
    contactId?: boolean
    createdAt?: boolean
    contact?: boolean | TimeSlot$contactArgs<ExtArgs>
  }, ExtArgs["result"]["timeSlot"]>

  export type TimeSlotSelectScalar = {
    id?: boolean
    date?: boolean
    time?: boolean
    isAvailable?: boolean
    contactId?: boolean
    createdAt?: boolean
  }

  export type TimeSlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "time" | "isAvailable" | "contactId" | "createdAt", ExtArgs["result"]["timeSlot"]>
  export type TimeSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | TimeSlot$contactArgs<ExtArgs>
  }
  export type TimeSlotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | TimeSlot$contactArgs<ExtArgs>
  }
  export type TimeSlotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | TimeSlot$contactArgs<ExtArgs>
  }

  export type $TimeSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeSlot"
    objects: {
      contact: Prisma.$ContactPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      time: Date
      isAvailable: boolean
      contactId: string | null
      createdAt: Date
    }, ExtArgs["result"]["timeSlot"]>
    composites: {}
  }

  type TimeSlotGetPayload<S extends boolean | null | undefined | TimeSlotDefaultArgs> = $Result.GetResult<Prisma.$TimeSlotPayload, S>

  type TimeSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimeSlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimeSlotCountAggregateInputType | true
    }

  export interface TimeSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeSlot'], meta: { name: 'TimeSlot' } }
    /**
     * Find zero or one TimeSlot that matches the filter.
     * @param {TimeSlotFindUniqueArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeSlotFindUniqueArgs>(args: SelectSubset<T, TimeSlotFindUniqueArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimeSlot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimeSlotFindUniqueOrThrowArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotFindFirstArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeSlotFindFirstArgs>(args?: SelectSubset<T, TimeSlotFindFirstArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotFindFirstOrThrowArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimeSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeSlots
     * const timeSlots = await prisma.timeSlot.findMany()
     * 
     * // Get first 10 TimeSlots
     * const timeSlots = await prisma.timeSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeSlotWithIdOnly = await prisma.timeSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeSlotFindManyArgs>(args?: SelectSubset<T, TimeSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimeSlot.
     * @param {TimeSlotCreateArgs} args - Arguments to create a TimeSlot.
     * @example
     * // Create one TimeSlot
     * const TimeSlot = await prisma.timeSlot.create({
     *   data: {
     *     // ... data to create a TimeSlot
     *   }
     * })
     * 
     */
    create<T extends TimeSlotCreateArgs>(args: SelectSubset<T, TimeSlotCreateArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimeSlots.
     * @param {TimeSlotCreateManyArgs} args - Arguments to create many TimeSlots.
     * @example
     * // Create many TimeSlots
     * const timeSlot = await prisma.timeSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeSlotCreateManyArgs>(args?: SelectSubset<T, TimeSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeSlots and returns the data saved in the database.
     * @param {TimeSlotCreateManyAndReturnArgs} args - Arguments to create many TimeSlots.
     * @example
     * // Create many TimeSlots
     * const timeSlot = await prisma.timeSlot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeSlots and only return the `id`
     * const timeSlotWithIdOnly = await prisma.timeSlot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeSlotCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeSlotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TimeSlot.
     * @param {TimeSlotDeleteArgs} args - Arguments to delete one TimeSlot.
     * @example
     * // Delete one TimeSlot
     * const TimeSlot = await prisma.timeSlot.delete({
     *   where: {
     *     // ... filter to delete one TimeSlot
     *   }
     * })
     * 
     */
    delete<T extends TimeSlotDeleteArgs>(args: SelectSubset<T, TimeSlotDeleteArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimeSlot.
     * @param {TimeSlotUpdateArgs} args - Arguments to update one TimeSlot.
     * @example
     * // Update one TimeSlot
     * const timeSlot = await prisma.timeSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeSlotUpdateArgs>(args: SelectSubset<T, TimeSlotUpdateArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimeSlots.
     * @param {TimeSlotDeleteManyArgs} args - Arguments to filter TimeSlots to delete.
     * @example
     * // Delete a few TimeSlots
     * const { count } = await prisma.timeSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeSlotDeleteManyArgs>(args?: SelectSubset<T, TimeSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeSlots
     * const timeSlot = await prisma.timeSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeSlotUpdateManyArgs>(args: SelectSubset<T, TimeSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSlots and returns the data updated in the database.
     * @param {TimeSlotUpdateManyAndReturnArgs} args - Arguments to update many TimeSlots.
     * @example
     * // Update many TimeSlots
     * const timeSlot = await prisma.timeSlot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TimeSlots and only return the `id`
     * const timeSlotWithIdOnly = await prisma.timeSlot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimeSlotUpdateManyAndReturnArgs>(args: SelectSubset<T, TimeSlotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TimeSlot.
     * @param {TimeSlotUpsertArgs} args - Arguments to update or create a TimeSlot.
     * @example
     * // Update or create a TimeSlot
     * const timeSlot = await prisma.timeSlot.upsert({
     *   create: {
     *     // ... data to create a TimeSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeSlot we want to update
     *   }
     * })
     */
    upsert<T extends TimeSlotUpsertArgs>(args: SelectSubset<T, TimeSlotUpsertArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotCountArgs} args - Arguments to filter TimeSlots to count.
     * @example
     * // Count the number of TimeSlots
     * const count = await prisma.timeSlot.count({
     *   where: {
     *     // ... the filter for the TimeSlots we want to count
     *   }
     * })
    **/
    count<T extends TimeSlotCountArgs>(
      args?: Subset<T, TimeSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeSlotAggregateArgs>(args: Subset<T, TimeSlotAggregateArgs>): Prisma.PrismaPromise<GetTimeSlotAggregateType<T>>

    /**
     * Group by TimeSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeSlotGroupByArgs['orderBy'] }
        : { orderBy?: TimeSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeSlot model
   */
  readonly fields: TimeSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends TimeSlot$contactArgs<ExtArgs> = {}>(args?: Subset<T, TimeSlot$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeSlot model
   */
  interface TimeSlotFieldRefs {
    readonly id: FieldRef<"TimeSlot", 'String'>
    readonly date: FieldRef<"TimeSlot", 'DateTime'>
    readonly time: FieldRef<"TimeSlot", 'DateTime'>
    readonly isAvailable: FieldRef<"TimeSlot", 'Boolean'>
    readonly contactId: FieldRef<"TimeSlot", 'String'>
    readonly createdAt: FieldRef<"TimeSlot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TimeSlot findUnique
   */
  export type TimeSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot findUniqueOrThrow
   */
  export type TimeSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot findFirst
   */
  export type TimeSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSlots.
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSlots.
     */
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * TimeSlot findFirstOrThrow
   */
  export type TimeSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSlots.
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSlots.
     */
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * TimeSlot findMany
   */
  export type TimeSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlots to fetch.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeSlots.
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * TimeSlot create
   */
  export type TimeSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeSlot.
     */
    data: XOR<TimeSlotCreateInput, TimeSlotUncheckedCreateInput>
  }

  /**
   * TimeSlot createMany
   */
  export type TimeSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeSlots.
     */
    data: TimeSlotCreateManyInput | TimeSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeSlot createManyAndReturn
   */
  export type TimeSlotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * The data used to create many TimeSlots.
     */
    data: TimeSlotCreateManyInput | TimeSlotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeSlot update
   */
  export type TimeSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeSlot.
     */
    data: XOR<TimeSlotUpdateInput, TimeSlotUncheckedUpdateInput>
    /**
     * Choose, which TimeSlot to update.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot updateMany
   */
  export type TimeSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeSlots.
     */
    data: XOR<TimeSlotUpdateManyMutationInput, TimeSlotUncheckedUpdateManyInput>
    /**
     * Filter which TimeSlots to update
     */
    where?: TimeSlotWhereInput
    /**
     * Limit how many TimeSlots to update.
     */
    limit?: number
  }

  /**
   * TimeSlot updateManyAndReturn
   */
  export type TimeSlotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * The data used to update TimeSlots.
     */
    data: XOR<TimeSlotUpdateManyMutationInput, TimeSlotUncheckedUpdateManyInput>
    /**
     * Filter which TimeSlots to update
     */
    where?: TimeSlotWhereInput
    /**
     * Limit how many TimeSlots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeSlot upsert
   */
  export type TimeSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeSlot to update in case it exists.
     */
    where: TimeSlotWhereUniqueInput
    /**
     * In case the TimeSlot found by the `where` argument doesn't exist, create a new TimeSlot with this data.
     */
    create: XOR<TimeSlotCreateInput, TimeSlotUncheckedCreateInput>
    /**
     * In case the TimeSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeSlotUpdateInput, TimeSlotUncheckedUpdateInput>
  }

  /**
   * TimeSlot delete
   */
  export type TimeSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter which TimeSlot to delete.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot deleteMany
   */
  export type TimeSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSlots to delete
     */
    where?: TimeSlotWhereInput
    /**
     * Limit how many TimeSlots to delete.
     */
    limit?: number
  }

  /**
   * TimeSlot.contact
   */
  export type TimeSlot$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * TimeSlot without action
   */
  export type TimeSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
  }


  /**
   * Model ContactFormStep
   */

  export type AggregateContactFormStep = {
    _count: ContactFormStepCountAggregateOutputType | null
    _avg: ContactFormStepAvgAggregateOutputType | null
    _sum: ContactFormStepSumAggregateOutputType | null
    _min: ContactFormStepMinAggregateOutputType | null
    _max: ContactFormStepMaxAggregateOutputType | null
  }

  export type ContactFormStepAvgAggregateOutputType = {
    stepNumber: number | null
  }

  export type ContactFormStepSumAggregateOutputType = {
    stepNumber: number | null
  }

  export type ContactFormStepMinAggregateOutputType = {
    id: string | null
    contactId: string | null
    stepNumber: number | null
    completedAt: Date | null
  }

  export type ContactFormStepMaxAggregateOutputType = {
    id: string | null
    contactId: string | null
    stepNumber: number | null
    completedAt: Date | null
  }

  export type ContactFormStepCountAggregateOutputType = {
    id: number
    contactId: number
    stepNumber: number
    stepData: number
    completedAt: number
    _all: number
  }


  export type ContactFormStepAvgAggregateInputType = {
    stepNumber?: true
  }

  export type ContactFormStepSumAggregateInputType = {
    stepNumber?: true
  }

  export type ContactFormStepMinAggregateInputType = {
    id?: true
    contactId?: true
    stepNumber?: true
    completedAt?: true
  }

  export type ContactFormStepMaxAggregateInputType = {
    id?: true
    contactId?: true
    stepNumber?: true
    completedAt?: true
  }

  export type ContactFormStepCountAggregateInputType = {
    id?: true
    contactId?: true
    stepNumber?: true
    stepData?: true
    completedAt?: true
    _all?: true
  }

  export type ContactFormStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactFormStep to aggregate.
     */
    where?: ContactFormStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactFormSteps to fetch.
     */
    orderBy?: ContactFormStepOrderByWithRelationInput | ContactFormStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactFormStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactFormSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactFormSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactFormSteps
    **/
    _count?: true | ContactFormStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactFormStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactFormStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactFormStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactFormStepMaxAggregateInputType
  }

  export type GetContactFormStepAggregateType<T extends ContactFormStepAggregateArgs> = {
        [P in keyof T & keyof AggregateContactFormStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactFormStep[P]>
      : GetScalarType<T[P], AggregateContactFormStep[P]>
  }




  export type ContactFormStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactFormStepWhereInput
    orderBy?: ContactFormStepOrderByWithAggregationInput | ContactFormStepOrderByWithAggregationInput[]
    by: ContactFormStepScalarFieldEnum[] | ContactFormStepScalarFieldEnum
    having?: ContactFormStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactFormStepCountAggregateInputType | true
    _avg?: ContactFormStepAvgAggregateInputType
    _sum?: ContactFormStepSumAggregateInputType
    _min?: ContactFormStepMinAggregateInputType
    _max?: ContactFormStepMaxAggregateInputType
  }

  export type ContactFormStepGroupByOutputType = {
    id: string
    contactId: string
    stepNumber: number
    stepData: JsonValue
    completedAt: Date
    _count: ContactFormStepCountAggregateOutputType | null
    _avg: ContactFormStepAvgAggregateOutputType | null
    _sum: ContactFormStepSumAggregateOutputType | null
    _min: ContactFormStepMinAggregateOutputType | null
    _max: ContactFormStepMaxAggregateOutputType | null
  }

  type GetContactFormStepGroupByPayload<T extends ContactFormStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactFormStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactFormStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactFormStepGroupByOutputType[P]>
            : GetScalarType<T[P], ContactFormStepGroupByOutputType[P]>
        }
      >
    >


  export type ContactFormStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contactId?: boolean
    stepNumber?: boolean
    stepData?: boolean
    completedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactFormStep"]>

  export type ContactFormStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contactId?: boolean
    stepNumber?: boolean
    stepData?: boolean
    completedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactFormStep"]>

  export type ContactFormStepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contactId?: boolean
    stepNumber?: boolean
    stepData?: boolean
    completedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactFormStep"]>

  export type ContactFormStepSelectScalar = {
    id?: boolean
    contactId?: boolean
    stepNumber?: boolean
    stepData?: boolean
    completedAt?: boolean
  }

  export type ContactFormStepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contactId" | "stepNumber" | "stepData" | "completedAt", ExtArgs["result"]["contactFormStep"]>
  export type ContactFormStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type ContactFormStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type ContactFormStepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }

  export type $ContactFormStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactFormStep"
    objects: {
      contact: Prisma.$ContactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contactId: string
      stepNumber: number
      stepData: Prisma.JsonValue
      completedAt: Date
    }, ExtArgs["result"]["contactFormStep"]>
    composites: {}
  }

  type ContactFormStepGetPayload<S extends boolean | null | undefined | ContactFormStepDefaultArgs> = $Result.GetResult<Prisma.$ContactFormStepPayload, S>

  type ContactFormStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFormStepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactFormStepCountAggregateInputType | true
    }

  export interface ContactFormStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactFormStep'], meta: { name: 'ContactFormStep' } }
    /**
     * Find zero or one ContactFormStep that matches the filter.
     * @param {ContactFormStepFindUniqueArgs} args - Arguments to find a ContactFormStep
     * @example
     * // Get one ContactFormStep
     * const contactFormStep = await prisma.contactFormStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFormStepFindUniqueArgs>(args: SelectSubset<T, ContactFormStepFindUniqueArgs<ExtArgs>>): Prisma__ContactFormStepClient<$Result.GetResult<Prisma.$ContactFormStepPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactFormStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFormStepFindUniqueOrThrowArgs} args - Arguments to find a ContactFormStep
     * @example
     * // Get one ContactFormStep
     * const contactFormStep = await prisma.contactFormStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFormStepFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFormStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactFormStepClient<$Result.GetResult<Prisma.$ContactFormStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactFormStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormStepFindFirstArgs} args - Arguments to find a ContactFormStep
     * @example
     * // Get one ContactFormStep
     * const contactFormStep = await prisma.contactFormStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFormStepFindFirstArgs>(args?: SelectSubset<T, ContactFormStepFindFirstArgs<ExtArgs>>): Prisma__ContactFormStepClient<$Result.GetResult<Prisma.$ContactFormStepPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactFormStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormStepFindFirstOrThrowArgs} args - Arguments to find a ContactFormStep
     * @example
     * // Get one ContactFormStep
     * const contactFormStep = await prisma.contactFormStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFormStepFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFormStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactFormStepClient<$Result.GetResult<Prisma.$ContactFormStepPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactFormSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactFormSteps
     * const contactFormSteps = await prisma.contactFormStep.findMany()
     * 
     * // Get first 10 ContactFormSteps
     * const contactFormSteps = await prisma.contactFormStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactFormStepWithIdOnly = await prisma.contactFormStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFormStepFindManyArgs>(args?: SelectSubset<T, ContactFormStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactFormStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactFormStep.
     * @param {ContactFormStepCreateArgs} args - Arguments to create a ContactFormStep.
     * @example
     * // Create one ContactFormStep
     * const ContactFormStep = await prisma.contactFormStep.create({
     *   data: {
     *     // ... data to create a ContactFormStep
     *   }
     * })
     * 
     */
    create<T extends ContactFormStepCreateArgs>(args: SelectSubset<T, ContactFormStepCreateArgs<ExtArgs>>): Prisma__ContactFormStepClient<$Result.GetResult<Prisma.$ContactFormStepPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactFormSteps.
     * @param {ContactFormStepCreateManyArgs} args - Arguments to create many ContactFormSteps.
     * @example
     * // Create many ContactFormSteps
     * const contactFormStep = await prisma.contactFormStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactFormStepCreateManyArgs>(args?: SelectSubset<T, ContactFormStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactFormSteps and returns the data saved in the database.
     * @param {ContactFormStepCreateManyAndReturnArgs} args - Arguments to create many ContactFormSteps.
     * @example
     * // Create many ContactFormSteps
     * const contactFormStep = await prisma.contactFormStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactFormSteps and only return the `id`
     * const contactFormStepWithIdOnly = await prisma.contactFormStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactFormStepCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactFormStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactFormStepPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactFormStep.
     * @param {ContactFormStepDeleteArgs} args - Arguments to delete one ContactFormStep.
     * @example
     * // Delete one ContactFormStep
     * const ContactFormStep = await prisma.contactFormStep.delete({
     *   where: {
     *     // ... filter to delete one ContactFormStep
     *   }
     * })
     * 
     */
    delete<T extends ContactFormStepDeleteArgs>(args: SelectSubset<T, ContactFormStepDeleteArgs<ExtArgs>>): Prisma__ContactFormStepClient<$Result.GetResult<Prisma.$ContactFormStepPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactFormStep.
     * @param {ContactFormStepUpdateArgs} args - Arguments to update one ContactFormStep.
     * @example
     * // Update one ContactFormStep
     * const contactFormStep = await prisma.contactFormStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactFormStepUpdateArgs>(args: SelectSubset<T, ContactFormStepUpdateArgs<ExtArgs>>): Prisma__ContactFormStepClient<$Result.GetResult<Prisma.$ContactFormStepPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactFormSteps.
     * @param {ContactFormStepDeleteManyArgs} args - Arguments to filter ContactFormSteps to delete.
     * @example
     * // Delete a few ContactFormSteps
     * const { count } = await prisma.contactFormStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactFormStepDeleteManyArgs>(args?: SelectSubset<T, ContactFormStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactFormSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactFormSteps
     * const contactFormStep = await prisma.contactFormStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactFormStepUpdateManyArgs>(args: SelectSubset<T, ContactFormStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactFormSteps and returns the data updated in the database.
     * @param {ContactFormStepUpdateManyAndReturnArgs} args - Arguments to update many ContactFormSteps.
     * @example
     * // Update many ContactFormSteps
     * const contactFormStep = await prisma.contactFormStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactFormSteps and only return the `id`
     * const contactFormStepWithIdOnly = await prisma.contactFormStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactFormStepUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactFormStepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactFormStepPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactFormStep.
     * @param {ContactFormStepUpsertArgs} args - Arguments to update or create a ContactFormStep.
     * @example
     * // Update or create a ContactFormStep
     * const contactFormStep = await prisma.contactFormStep.upsert({
     *   create: {
     *     // ... data to create a ContactFormStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactFormStep we want to update
     *   }
     * })
     */
    upsert<T extends ContactFormStepUpsertArgs>(args: SelectSubset<T, ContactFormStepUpsertArgs<ExtArgs>>): Prisma__ContactFormStepClient<$Result.GetResult<Prisma.$ContactFormStepPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactFormSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormStepCountArgs} args - Arguments to filter ContactFormSteps to count.
     * @example
     * // Count the number of ContactFormSteps
     * const count = await prisma.contactFormStep.count({
     *   where: {
     *     // ... the filter for the ContactFormSteps we want to count
     *   }
     * })
    **/
    count<T extends ContactFormStepCountArgs>(
      args?: Subset<T, ContactFormStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactFormStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactFormStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactFormStepAggregateArgs>(args: Subset<T, ContactFormStepAggregateArgs>): Prisma.PrismaPromise<GetContactFormStepAggregateType<T>>

    /**
     * Group by ContactFormStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactFormStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactFormStepGroupByArgs['orderBy'] }
        : { orderBy?: ContactFormStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactFormStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactFormStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactFormStep model
   */
  readonly fields: ContactFormStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactFormStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactFormStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactFormStep model
   */
  interface ContactFormStepFieldRefs {
    readonly id: FieldRef<"ContactFormStep", 'String'>
    readonly contactId: FieldRef<"ContactFormStep", 'String'>
    readonly stepNumber: FieldRef<"ContactFormStep", 'Int'>
    readonly stepData: FieldRef<"ContactFormStep", 'Json'>
    readonly completedAt: FieldRef<"ContactFormStep", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactFormStep findUnique
   */
  export type ContactFormStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFormStep
     */
    select?: ContactFormStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFormStep
     */
    omit?: ContactFormStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormStepInclude<ExtArgs> | null
    /**
     * Filter, which ContactFormStep to fetch.
     */
    where: ContactFormStepWhereUniqueInput
  }

  /**
   * ContactFormStep findUniqueOrThrow
   */
  export type ContactFormStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFormStep
     */
    select?: ContactFormStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFormStep
     */
    omit?: ContactFormStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormStepInclude<ExtArgs> | null
    /**
     * Filter, which ContactFormStep to fetch.
     */
    where: ContactFormStepWhereUniqueInput
  }

  /**
   * ContactFormStep findFirst
   */
  export type ContactFormStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFormStep
     */
    select?: ContactFormStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFormStep
     */
    omit?: ContactFormStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormStepInclude<ExtArgs> | null
    /**
     * Filter, which ContactFormStep to fetch.
     */
    where?: ContactFormStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactFormSteps to fetch.
     */
    orderBy?: ContactFormStepOrderByWithRelationInput | ContactFormStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactFormSteps.
     */
    cursor?: ContactFormStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactFormSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactFormSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactFormSteps.
     */
    distinct?: ContactFormStepScalarFieldEnum | ContactFormStepScalarFieldEnum[]
  }

  /**
   * ContactFormStep findFirstOrThrow
   */
  export type ContactFormStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFormStep
     */
    select?: ContactFormStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFormStep
     */
    omit?: ContactFormStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormStepInclude<ExtArgs> | null
    /**
     * Filter, which ContactFormStep to fetch.
     */
    where?: ContactFormStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactFormSteps to fetch.
     */
    orderBy?: ContactFormStepOrderByWithRelationInput | ContactFormStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactFormSteps.
     */
    cursor?: ContactFormStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactFormSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactFormSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactFormSteps.
     */
    distinct?: ContactFormStepScalarFieldEnum | ContactFormStepScalarFieldEnum[]
  }

  /**
   * ContactFormStep findMany
   */
  export type ContactFormStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFormStep
     */
    select?: ContactFormStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFormStep
     */
    omit?: ContactFormStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormStepInclude<ExtArgs> | null
    /**
     * Filter, which ContactFormSteps to fetch.
     */
    where?: ContactFormStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactFormSteps to fetch.
     */
    orderBy?: ContactFormStepOrderByWithRelationInput | ContactFormStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactFormSteps.
     */
    cursor?: ContactFormStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactFormSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactFormSteps.
     */
    skip?: number
    distinct?: ContactFormStepScalarFieldEnum | ContactFormStepScalarFieldEnum[]
  }

  /**
   * ContactFormStep create
   */
  export type ContactFormStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFormStep
     */
    select?: ContactFormStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFormStep
     */
    omit?: ContactFormStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormStepInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactFormStep.
     */
    data: XOR<ContactFormStepCreateInput, ContactFormStepUncheckedCreateInput>
  }

  /**
   * ContactFormStep createMany
   */
  export type ContactFormStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactFormSteps.
     */
    data: ContactFormStepCreateManyInput | ContactFormStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactFormStep createManyAndReturn
   */
  export type ContactFormStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFormStep
     */
    select?: ContactFormStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFormStep
     */
    omit?: ContactFormStepOmit<ExtArgs> | null
    /**
     * The data used to create many ContactFormSteps.
     */
    data: ContactFormStepCreateManyInput | ContactFormStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactFormStep update
   */
  export type ContactFormStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFormStep
     */
    select?: ContactFormStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFormStep
     */
    omit?: ContactFormStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormStepInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactFormStep.
     */
    data: XOR<ContactFormStepUpdateInput, ContactFormStepUncheckedUpdateInput>
    /**
     * Choose, which ContactFormStep to update.
     */
    where: ContactFormStepWhereUniqueInput
  }

  /**
   * ContactFormStep updateMany
   */
  export type ContactFormStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactFormSteps.
     */
    data: XOR<ContactFormStepUpdateManyMutationInput, ContactFormStepUncheckedUpdateManyInput>
    /**
     * Filter which ContactFormSteps to update
     */
    where?: ContactFormStepWhereInput
    /**
     * Limit how many ContactFormSteps to update.
     */
    limit?: number
  }

  /**
   * ContactFormStep updateManyAndReturn
   */
  export type ContactFormStepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFormStep
     */
    select?: ContactFormStepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFormStep
     */
    omit?: ContactFormStepOmit<ExtArgs> | null
    /**
     * The data used to update ContactFormSteps.
     */
    data: XOR<ContactFormStepUpdateManyMutationInput, ContactFormStepUncheckedUpdateManyInput>
    /**
     * Filter which ContactFormSteps to update
     */
    where?: ContactFormStepWhereInput
    /**
     * Limit how many ContactFormSteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormStepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactFormStep upsert
   */
  export type ContactFormStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFormStep
     */
    select?: ContactFormStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFormStep
     */
    omit?: ContactFormStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormStepInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactFormStep to update in case it exists.
     */
    where: ContactFormStepWhereUniqueInput
    /**
     * In case the ContactFormStep found by the `where` argument doesn't exist, create a new ContactFormStep with this data.
     */
    create: XOR<ContactFormStepCreateInput, ContactFormStepUncheckedCreateInput>
    /**
     * In case the ContactFormStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactFormStepUpdateInput, ContactFormStepUncheckedUpdateInput>
  }

  /**
   * ContactFormStep delete
   */
  export type ContactFormStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFormStep
     */
    select?: ContactFormStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFormStep
     */
    omit?: ContactFormStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormStepInclude<ExtArgs> | null
    /**
     * Filter which ContactFormStep to delete.
     */
    where: ContactFormStepWhereUniqueInput
  }

  /**
   * ContactFormStep deleteMany
   */
  export type ContactFormStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactFormSteps to delete
     */
    where?: ContactFormStepWhereInput
    /**
     * Limit how many ContactFormSteps to delete.
     */
    limit?: number
  }

  /**
   * ContactFormStep without action
   */
  export type ContactFormStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFormStep
     */
    select?: ContactFormStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFormStep
     */
    omit?: ContactFormStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormStepInclude<ExtArgs> | null
  }


  /**
   * Model PricingCalculation
   */

  export type AggregatePricingCalculation = {
    _count: PricingCalculationCountAggregateOutputType | null
    _avg: PricingCalculationAvgAggregateOutputType | null
    _sum: PricingCalculationSumAggregateOutputType | null
    _min: PricingCalculationMinAggregateOutputType | null
    _max: PricingCalculationMaxAggregateOutputType | null
  }

  export type PricingCalculationAvgAggregateOutputType = {
    totalPrice: Decimal | null
  }

  export type PricingCalculationSumAggregateOutputType = {
    totalPrice: Decimal | null
  }

  export type PricingCalculationMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    businessTypeId: string | null
    totalPrice: Decimal | null
    contactId: string | null
    createdAt: Date | null
  }

  export type PricingCalculationMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    businessTypeId: string | null
    totalPrice: Decimal | null
    contactId: string | null
    createdAt: Date | null
  }

  export type PricingCalculationCountAggregateOutputType = {
    id: number
    sessionId: number
    businessTypeId: number
    totalPrice: number
    calculationData: number
    contactId: number
    createdAt: number
    _all: number
  }


  export type PricingCalculationAvgAggregateInputType = {
    totalPrice?: true
  }

  export type PricingCalculationSumAggregateInputType = {
    totalPrice?: true
  }

  export type PricingCalculationMinAggregateInputType = {
    id?: true
    sessionId?: true
    businessTypeId?: true
    totalPrice?: true
    contactId?: true
    createdAt?: true
  }

  export type PricingCalculationMaxAggregateInputType = {
    id?: true
    sessionId?: true
    businessTypeId?: true
    totalPrice?: true
    contactId?: true
    createdAt?: true
  }

  export type PricingCalculationCountAggregateInputType = {
    id?: true
    sessionId?: true
    businessTypeId?: true
    totalPrice?: true
    calculationData?: true
    contactId?: true
    createdAt?: true
    _all?: true
  }

  export type PricingCalculationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PricingCalculation to aggregate.
     */
    where?: PricingCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingCalculations to fetch.
     */
    orderBy?: PricingCalculationOrderByWithRelationInput | PricingCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PricingCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PricingCalculations
    **/
    _count?: true | PricingCalculationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricingCalculationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricingCalculationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricingCalculationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricingCalculationMaxAggregateInputType
  }

  export type GetPricingCalculationAggregateType<T extends PricingCalculationAggregateArgs> = {
        [P in keyof T & keyof AggregatePricingCalculation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePricingCalculation[P]>
      : GetScalarType<T[P], AggregatePricingCalculation[P]>
  }




  export type PricingCalculationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PricingCalculationWhereInput
    orderBy?: PricingCalculationOrderByWithAggregationInput | PricingCalculationOrderByWithAggregationInput[]
    by: PricingCalculationScalarFieldEnum[] | PricingCalculationScalarFieldEnum
    having?: PricingCalculationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricingCalculationCountAggregateInputType | true
    _avg?: PricingCalculationAvgAggregateInputType
    _sum?: PricingCalculationSumAggregateInputType
    _min?: PricingCalculationMinAggregateInputType
    _max?: PricingCalculationMaxAggregateInputType
  }

  export type PricingCalculationGroupByOutputType = {
    id: string
    sessionId: string | null
    businessTypeId: string
    totalPrice: Decimal
    calculationData: JsonValue
    contactId: string | null
    createdAt: Date
    _count: PricingCalculationCountAggregateOutputType | null
    _avg: PricingCalculationAvgAggregateOutputType | null
    _sum: PricingCalculationSumAggregateOutputType | null
    _min: PricingCalculationMinAggregateOutputType | null
    _max: PricingCalculationMaxAggregateOutputType | null
  }

  type GetPricingCalculationGroupByPayload<T extends PricingCalculationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PricingCalculationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricingCalculationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricingCalculationGroupByOutputType[P]>
            : GetScalarType<T[P], PricingCalculationGroupByOutputType[P]>
        }
      >
    >


  export type PricingCalculationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    businessTypeId?: boolean
    totalPrice?: boolean
    calculationData?: boolean
    contactId?: boolean
    createdAt?: boolean
    features?: boolean | PricingCalculation$featuresArgs<ExtArgs>
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    contact?: boolean | PricingCalculation$contactArgs<ExtArgs>
    _count?: boolean | PricingCalculationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pricingCalculation"]>

  export type PricingCalculationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    businessTypeId?: boolean
    totalPrice?: boolean
    calculationData?: boolean
    contactId?: boolean
    createdAt?: boolean
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    contact?: boolean | PricingCalculation$contactArgs<ExtArgs>
  }, ExtArgs["result"]["pricingCalculation"]>

  export type PricingCalculationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    businessTypeId?: boolean
    totalPrice?: boolean
    calculationData?: boolean
    contactId?: boolean
    createdAt?: boolean
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    contact?: boolean | PricingCalculation$contactArgs<ExtArgs>
  }, ExtArgs["result"]["pricingCalculation"]>

  export type PricingCalculationSelectScalar = {
    id?: boolean
    sessionId?: boolean
    businessTypeId?: boolean
    totalPrice?: boolean
    calculationData?: boolean
    contactId?: boolean
    createdAt?: boolean
  }

  export type PricingCalculationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "businessTypeId" | "totalPrice" | "calculationData" | "contactId" | "createdAt", ExtArgs["result"]["pricingCalculation"]>
  export type PricingCalculationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | PricingCalculation$featuresArgs<ExtArgs>
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    contact?: boolean | PricingCalculation$contactArgs<ExtArgs>
    _count?: boolean | PricingCalculationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PricingCalculationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    contact?: boolean | PricingCalculation$contactArgs<ExtArgs>
  }
  export type PricingCalculationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | BusinessTypeDefaultArgs<ExtArgs>
    contact?: boolean | PricingCalculation$contactArgs<ExtArgs>
  }

  export type $PricingCalculationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PricingCalculation"
    objects: {
      features: Prisma.$CalculationFeaturePayload<ExtArgs>[]
      businessType: Prisma.$BusinessTypePayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string | null
      businessTypeId: string
      totalPrice: Prisma.Decimal
      calculationData: Prisma.JsonValue
      contactId: string | null
      createdAt: Date
    }, ExtArgs["result"]["pricingCalculation"]>
    composites: {}
  }

  type PricingCalculationGetPayload<S extends boolean | null | undefined | PricingCalculationDefaultArgs> = $Result.GetResult<Prisma.$PricingCalculationPayload, S>

  type PricingCalculationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PricingCalculationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PricingCalculationCountAggregateInputType | true
    }

  export interface PricingCalculationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PricingCalculation'], meta: { name: 'PricingCalculation' } }
    /**
     * Find zero or one PricingCalculation that matches the filter.
     * @param {PricingCalculationFindUniqueArgs} args - Arguments to find a PricingCalculation
     * @example
     * // Get one PricingCalculation
     * const pricingCalculation = await prisma.pricingCalculation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PricingCalculationFindUniqueArgs>(args: SelectSubset<T, PricingCalculationFindUniqueArgs<ExtArgs>>): Prisma__PricingCalculationClient<$Result.GetResult<Prisma.$PricingCalculationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PricingCalculation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PricingCalculationFindUniqueOrThrowArgs} args - Arguments to find a PricingCalculation
     * @example
     * // Get one PricingCalculation
     * const pricingCalculation = await prisma.pricingCalculation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PricingCalculationFindUniqueOrThrowArgs>(args: SelectSubset<T, PricingCalculationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PricingCalculationClient<$Result.GetResult<Prisma.$PricingCalculationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PricingCalculation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingCalculationFindFirstArgs} args - Arguments to find a PricingCalculation
     * @example
     * // Get one PricingCalculation
     * const pricingCalculation = await prisma.pricingCalculation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PricingCalculationFindFirstArgs>(args?: SelectSubset<T, PricingCalculationFindFirstArgs<ExtArgs>>): Prisma__PricingCalculationClient<$Result.GetResult<Prisma.$PricingCalculationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PricingCalculation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingCalculationFindFirstOrThrowArgs} args - Arguments to find a PricingCalculation
     * @example
     * // Get one PricingCalculation
     * const pricingCalculation = await prisma.pricingCalculation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PricingCalculationFindFirstOrThrowArgs>(args?: SelectSubset<T, PricingCalculationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PricingCalculationClient<$Result.GetResult<Prisma.$PricingCalculationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PricingCalculations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingCalculationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PricingCalculations
     * const pricingCalculations = await prisma.pricingCalculation.findMany()
     * 
     * // Get first 10 PricingCalculations
     * const pricingCalculations = await prisma.pricingCalculation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pricingCalculationWithIdOnly = await prisma.pricingCalculation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PricingCalculationFindManyArgs>(args?: SelectSubset<T, PricingCalculationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingCalculationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PricingCalculation.
     * @param {PricingCalculationCreateArgs} args - Arguments to create a PricingCalculation.
     * @example
     * // Create one PricingCalculation
     * const PricingCalculation = await prisma.pricingCalculation.create({
     *   data: {
     *     // ... data to create a PricingCalculation
     *   }
     * })
     * 
     */
    create<T extends PricingCalculationCreateArgs>(args: SelectSubset<T, PricingCalculationCreateArgs<ExtArgs>>): Prisma__PricingCalculationClient<$Result.GetResult<Prisma.$PricingCalculationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PricingCalculations.
     * @param {PricingCalculationCreateManyArgs} args - Arguments to create many PricingCalculations.
     * @example
     * // Create many PricingCalculations
     * const pricingCalculation = await prisma.pricingCalculation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PricingCalculationCreateManyArgs>(args?: SelectSubset<T, PricingCalculationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PricingCalculations and returns the data saved in the database.
     * @param {PricingCalculationCreateManyAndReturnArgs} args - Arguments to create many PricingCalculations.
     * @example
     * // Create many PricingCalculations
     * const pricingCalculation = await prisma.pricingCalculation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PricingCalculations and only return the `id`
     * const pricingCalculationWithIdOnly = await prisma.pricingCalculation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PricingCalculationCreateManyAndReturnArgs>(args?: SelectSubset<T, PricingCalculationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingCalculationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PricingCalculation.
     * @param {PricingCalculationDeleteArgs} args - Arguments to delete one PricingCalculation.
     * @example
     * // Delete one PricingCalculation
     * const PricingCalculation = await prisma.pricingCalculation.delete({
     *   where: {
     *     // ... filter to delete one PricingCalculation
     *   }
     * })
     * 
     */
    delete<T extends PricingCalculationDeleteArgs>(args: SelectSubset<T, PricingCalculationDeleteArgs<ExtArgs>>): Prisma__PricingCalculationClient<$Result.GetResult<Prisma.$PricingCalculationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PricingCalculation.
     * @param {PricingCalculationUpdateArgs} args - Arguments to update one PricingCalculation.
     * @example
     * // Update one PricingCalculation
     * const pricingCalculation = await prisma.pricingCalculation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PricingCalculationUpdateArgs>(args: SelectSubset<T, PricingCalculationUpdateArgs<ExtArgs>>): Prisma__PricingCalculationClient<$Result.GetResult<Prisma.$PricingCalculationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PricingCalculations.
     * @param {PricingCalculationDeleteManyArgs} args - Arguments to filter PricingCalculations to delete.
     * @example
     * // Delete a few PricingCalculations
     * const { count } = await prisma.pricingCalculation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PricingCalculationDeleteManyArgs>(args?: SelectSubset<T, PricingCalculationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PricingCalculations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingCalculationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PricingCalculations
     * const pricingCalculation = await prisma.pricingCalculation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PricingCalculationUpdateManyArgs>(args: SelectSubset<T, PricingCalculationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PricingCalculations and returns the data updated in the database.
     * @param {PricingCalculationUpdateManyAndReturnArgs} args - Arguments to update many PricingCalculations.
     * @example
     * // Update many PricingCalculations
     * const pricingCalculation = await prisma.pricingCalculation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PricingCalculations and only return the `id`
     * const pricingCalculationWithIdOnly = await prisma.pricingCalculation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PricingCalculationUpdateManyAndReturnArgs>(args: SelectSubset<T, PricingCalculationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingCalculationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PricingCalculation.
     * @param {PricingCalculationUpsertArgs} args - Arguments to update or create a PricingCalculation.
     * @example
     * // Update or create a PricingCalculation
     * const pricingCalculation = await prisma.pricingCalculation.upsert({
     *   create: {
     *     // ... data to create a PricingCalculation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PricingCalculation we want to update
     *   }
     * })
     */
    upsert<T extends PricingCalculationUpsertArgs>(args: SelectSubset<T, PricingCalculationUpsertArgs<ExtArgs>>): Prisma__PricingCalculationClient<$Result.GetResult<Prisma.$PricingCalculationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PricingCalculations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingCalculationCountArgs} args - Arguments to filter PricingCalculations to count.
     * @example
     * // Count the number of PricingCalculations
     * const count = await prisma.pricingCalculation.count({
     *   where: {
     *     // ... the filter for the PricingCalculations we want to count
     *   }
     * })
    **/
    count<T extends PricingCalculationCountArgs>(
      args?: Subset<T, PricingCalculationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricingCalculationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PricingCalculation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingCalculationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricingCalculationAggregateArgs>(args: Subset<T, PricingCalculationAggregateArgs>): Prisma.PrismaPromise<GetPricingCalculationAggregateType<T>>

    /**
     * Group by PricingCalculation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingCalculationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PricingCalculationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PricingCalculationGroupByArgs['orderBy'] }
        : { orderBy?: PricingCalculationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PricingCalculationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricingCalculationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PricingCalculation model
   */
  readonly fields: PricingCalculationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PricingCalculation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PricingCalculationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    features<T extends PricingCalculation$featuresArgs<ExtArgs> = {}>(args?: Subset<T, PricingCalculation$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalculationFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businessType<T extends BusinessTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessTypeDefaultArgs<ExtArgs>>): Prisma__BusinessTypeClient<$Result.GetResult<Prisma.$BusinessTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends PricingCalculation$contactArgs<ExtArgs> = {}>(args?: Subset<T, PricingCalculation$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PricingCalculation model
   */
  interface PricingCalculationFieldRefs {
    readonly id: FieldRef<"PricingCalculation", 'String'>
    readonly sessionId: FieldRef<"PricingCalculation", 'String'>
    readonly businessTypeId: FieldRef<"PricingCalculation", 'String'>
    readonly totalPrice: FieldRef<"PricingCalculation", 'Decimal'>
    readonly calculationData: FieldRef<"PricingCalculation", 'Json'>
    readonly contactId: FieldRef<"PricingCalculation", 'String'>
    readonly createdAt: FieldRef<"PricingCalculation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PricingCalculation findUnique
   */
  export type PricingCalculationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingCalculation
     */
    select?: PricingCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingCalculation
     */
    omit?: PricingCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingCalculationInclude<ExtArgs> | null
    /**
     * Filter, which PricingCalculation to fetch.
     */
    where: PricingCalculationWhereUniqueInput
  }

  /**
   * PricingCalculation findUniqueOrThrow
   */
  export type PricingCalculationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingCalculation
     */
    select?: PricingCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingCalculation
     */
    omit?: PricingCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingCalculationInclude<ExtArgs> | null
    /**
     * Filter, which PricingCalculation to fetch.
     */
    where: PricingCalculationWhereUniqueInput
  }

  /**
   * PricingCalculation findFirst
   */
  export type PricingCalculationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingCalculation
     */
    select?: PricingCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingCalculation
     */
    omit?: PricingCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingCalculationInclude<ExtArgs> | null
    /**
     * Filter, which PricingCalculation to fetch.
     */
    where?: PricingCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingCalculations to fetch.
     */
    orderBy?: PricingCalculationOrderByWithRelationInput | PricingCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PricingCalculations.
     */
    cursor?: PricingCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PricingCalculations.
     */
    distinct?: PricingCalculationScalarFieldEnum | PricingCalculationScalarFieldEnum[]
  }

  /**
   * PricingCalculation findFirstOrThrow
   */
  export type PricingCalculationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingCalculation
     */
    select?: PricingCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingCalculation
     */
    omit?: PricingCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingCalculationInclude<ExtArgs> | null
    /**
     * Filter, which PricingCalculation to fetch.
     */
    where?: PricingCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingCalculations to fetch.
     */
    orderBy?: PricingCalculationOrderByWithRelationInput | PricingCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PricingCalculations.
     */
    cursor?: PricingCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PricingCalculations.
     */
    distinct?: PricingCalculationScalarFieldEnum | PricingCalculationScalarFieldEnum[]
  }

  /**
   * PricingCalculation findMany
   */
  export type PricingCalculationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingCalculation
     */
    select?: PricingCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingCalculation
     */
    omit?: PricingCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingCalculationInclude<ExtArgs> | null
    /**
     * Filter, which PricingCalculations to fetch.
     */
    where?: PricingCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingCalculations to fetch.
     */
    orderBy?: PricingCalculationOrderByWithRelationInput | PricingCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PricingCalculations.
     */
    cursor?: PricingCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingCalculations.
     */
    skip?: number
    distinct?: PricingCalculationScalarFieldEnum | PricingCalculationScalarFieldEnum[]
  }

  /**
   * PricingCalculation create
   */
  export type PricingCalculationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingCalculation
     */
    select?: PricingCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingCalculation
     */
    omit?: PricingCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingCalculationInclude<ExtArgs> | null
    /**
     * The data needed to create a PricingCalculation.
     */
    data: XOR<PricingCalculationCreateInput, PricingCalculationUncheckedCreateInput>
  }

  /**
   * PricingCalculation createMany
   */
  export type PricingCalculationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PricingCalculations.
     */
    data: PricingCalculationCreateManyInput | PricingCalculationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PricingCalculation createManyAndReturn
   */
  export type PricingCalculationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingCalculation
     */
    select?: PricingCalculationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PricingCalculation
     */
    omit?: PricingCalculationOmit<ExtArgs> | null
    /**
     * The data used to create many PricingCalculations.
     */
    data: PricingCalculationCreateManyInput | PricingCalculationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingCalculationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PricingCalculation update
   */
  export type PricingCalculationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingCalculation
     */
    select?: PricingCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingCalculation
     */
    omit?: PricingCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingCalculationInclude<ExtArgs> | null
    /**
     * The data needed to update a PricingCalculation.
     */
    data: XOR<PricingCalculationUpdateInput, PricingCalculationUncheckedUpdateInput>
    /**
     * Choose, which PricingCalculation to update.
     */
    where: PricingCalculationWhereUniqueInput
  }

  /**
   * PricingCalculation updateMany
   */
  export type PricingCalculationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PricingCalculations.
     */
    data: XOR<PricingCalculationUpdateManyMutationInput, PricingCalculationUncheckedUpdateManyInput>
    /**
     * Filter which PricingCalculations to update
     */
    where?: PricingCalculationWhereInput
    /**
     * Limit how many PricingCalculations to update.
     */
    limit?: number
  }

  /**
   * PricingCalculation updateManyAndReturn
   */
  export type PricingCalculationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingCalculation
     */
    select?: PricingCalculationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PricingCalculation
     */
    omit?: PricingCalculationOmit<ExtArgs> | null
    /**
     * The data used to update PricingCalculations.
     */
    data: XOR<PricingCalculationUpdateManyMutationInput, PricingCalculationUncheckedUpdateManyInput>
    /**
     * Filter which PricingCalculations to update
     */
    where?: PricingCalculationWhereInput
    /**
     * Limit how many PricingCalculations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingCalculationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PricingCalculation upsert
   */
  export type PricingCalculationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingCalculation
     */
    select?: PricingCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingCalculation
     */
    omit?: PricingCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingCalculationInclude<ExtArgs> | null
    /**
     * The filter to search for the PricingCalculation to update in case it exists.
     */
    where: PricingCalculationWhereUniqueInput
    /**
     * In case the PricingCalculation found by the `where` argument doesn't exist, create a new PricingCalculation with this data.
     */
    create: XOR<PricingCalculationCreateInput, PricingCalculationUncheckedCreateInput>
    /**
     * In case the PricingCalculation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PricingCalculationUpdateInput, PricingCalculationUncheckedUpdateInput>
  }

  /**
   * PricingCalculation delete
   */
  export type PricingCalculationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingCalculation
     */
    select?: PricingCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingCalculation
     */
    omit?: PricingCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingCalculationInclude<ExtArgs> | null
    /**
     * Filter which PricingCalculation to delete.
     */
    where: PricingCalculationWhereUniqueInput
  }

  /**
   * PricingCalculation deleteMany
   */
  export type PricingCalculationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PricingCalculations to delete
     */
    where?: PricingCalculationWhereInput
    /**
     * Limit how many PricingCalculations to delete.
     */
    limit?: number
  }

  /**
   * PricingCalculation.features
   */
  export type PricingCalculation$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationFeature
     */
    select?: CalculationFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationFeature
     */
    omit?: CalculationFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationFeatureInclude<ExtArgs> | null
    where?: CalculationFeatureWhereInput
    orderBy?: CalculationFeatureOrderByWithRelationInput | CalculationFeatureOrderByWithRelationInput[]
    cursor?: CalculationFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalculationFeatureScalarFieldEnum | CalculationFeatureScalarFieldEnum[]
  }

  /**
   * PricingCalculation.contact
   */
  export type PricingCalculation$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * PricingCalculation without action
   */
  export type PricingCalculationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingCalculation
     */
    select?: PricingCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingCalculation
     */
    omit?: PricingCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingCalculationInclude<ExtArgs> | null
  }


  /**
   * Model CalculationFeature
   */

  export type AggregateCalculationFeature = {
    _count: CalculationFeatureCountAggregateOutputType | null
    _avg: CalculationFeatureAvgAggregateOutputType | null
    _sum: CalculationFeatureSumAggregateOutputType | null
    _min: CalculationFeatureMinAggregateOutputType | null
    _max: CalculationFeatureMaxAggregateOutputType | null
  }

  export type CalculationFeatureAvgAggregateOutputType = {
    count: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type CalculationFeatureSumAggregateOutputType = {
    count: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type CalculationFeatureMinAggregateOutputType = {
    id: string | null
    calculationId: string | null
    featureId: string | null
    tierName: string | null
    count: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type CalculationFeatureMaxAggregateOutputType = {
    id: string | null
    calculationId: string | null
    featureId: string | null
    tierName: string | null
    count: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type CalculationFeatureCountAggregateOutputType = {
    id: number
    calculationId: number
    featureId: number
    tierName: number
    count: number
    unitPrice: number
    totalPrice: number
    _all: number
  }


  export type CalculationFeatureAvgAggregateInputType = {
    count?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type CalculationFeatureSumAggregateInputType = {
    count?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type CalculationFeatureMinAggregateInputType = {
    id?: true
    calculationId?: true
    featureId?: true
    tierName?: true
    count?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type CalculationFeatureMaxAggregateInputType = {
    id?: true
    calculationId?: true
    featureId?: true
    tierName?: true
    count?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type CalculationFeatureCountAggregateInputType = {
    id?: true
    calculationId?: true
    featureId?: true
    tierName?: true
    count?: true
    unitPrice?: true
    totalPrice?: true
    _all?: true
  }

  export type CalculationFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalculationFeature to aggregate.
     */
    where?: CalculationFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalculationFeatures to fetch.
     */
    orderBy?: CalculationFeatureOrderByWithRelationInput | CalculationFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalculationFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalculationFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalculationFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalculationFeatures
    **/
    _count?: true | CalculationFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalculationFeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalculationFeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalculationFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalculationFeatureMaxAggregateInputType
  }

  export type GetCalculationFeatureAggregateType<T extends CalculationFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateCalculationFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalculationFeature[P]>
      : GetScalarType<T[P], AggregateCalculationFeature[P]>
  }




  export type CalculationFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalculationFeatureWhereInput
    orderBy?: CalculationFeatureOrderByWithAggregationInput | CalculationFeatureOrderByWithAggregationInput[]
    by: CalculationFeatureScalarFieldEnum[] | CalculationFeatureScalarFieldEnum
    having?: CalculationFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalculationFeatureCountAggregateInputType | true
    _avg?: CalculationFeatureAvgAggregateInputType
    _sum?: CalculationFeatureSumAggregateInputType
    _min?: CalculationFeatureMinAggregateInputType
    _max?: CalculationFeatureMaxAggregateInputType
  }

  export type CalculationFeatureGroupByOutputType = {
    id: string
    calculationId: string
    featureId: string
    tierName: string
    count: number
    unitPrice: Decimal
    totalPrice: Decimal
    _count: CalculationFeatureCountAggregateOutputType | null
    _avg: CalculationFeatureAvgAggregateOutputType | null
    _sum: CalculationFeatureSumAggregateOutputType | null
    _min: CalculationFeatureMinAggregateOutputType | null
    _max: CalculationFeatureMaxAggregateOutputType | null
  }

  type GetCalculationFeatureGroupByPayload<T extends CalculationFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalculationFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalculationFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalculationFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], CalculationFeatureGroupByOutputType[P]>
        }
      >
    >


  export type CalculationFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calculationId?: boolean
    featureId?: boolean
    tierName?: boolean
    count?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    calculation?: boolean | PricingCalculationDefaultArgs<ExtArgs>
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    tier?: boolean | FeatureTierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calculationFeature"]>

  export type CalculationFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calculationId?: boolean
    featureId?: boolean
    tierName?: boolean
    count?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    calculation?: boolean | PricingCalculationDefaultArgs<ExtArgs>
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    tier?: boolean | FeatureTierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calculationFeature"]>

  export type CalculationFeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calculationId?: boolean
    featureId?: boolean
    tierName?: boolean
    count?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    calculation?: boolean | PricingCalculationDefaultArgs<ExtArgs>
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    tier?: boolean | FeatureTierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calculationFeature"]>

  export type CalculationFeatureSelectScalar = {
    id?: boolean
    calculationId?: boolean
    featureId?: boolean
    tierName?: boolean
    count?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
  }

  export type CalculationFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "calculationId" | "featureId" | "tierName" | "count" | "unitPrice" | "totalPrice", ExtArgs["result"]["calculationFeature"]>
  export type CalculationFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calculation?: boolean | PricingCalculationDefaultArgs<ExtArgs>
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    tier?: boolean | FeatureTierDefaultArgs<ExtArgs>
  }
  export type CalculationFeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calculation?: boolean | PricingCalculationDefaultArgs<ExtArgs>
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    tier?: boolean | FeatureTierDefaultArgs<ExtArgs>
  }
  export type CalculationFeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calculation?: boolean | PricingCalculationDefaultArgs<ExtArgs>
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    tier?: boolean | FeatureTierDefaultArgs<ExtArgs>
  }

  export type $CalculationFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalculationFeature"
    objects: {
      calculation: Prisma.$PricingCalculationPayload<ExtArgs>
      feature: Prisma.$FeaturePayload<ExtArgs>
      tier: Prisma.$FeatureTierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      calculationId: string
      featureId: string
      tierName: string
      count: number
      unitPrice: Prisma.Decimal
      totalPrice: Prisma.Decimal
    }, ExtArgs["result"]["calculationFeature"]>
    composites: {}
  }

  type CalculationFeatureGetPayload<S extends boolean | null | undefined | CalculationFeatureDefaultArgs> = $Result.GetResult<Prisma.$CalculationFeaturePayload, S>

  type CalculationFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalculationFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalculationFeatureCountAggregateInputType | true
    }

  export interface CalculationFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalculationFeature'], meta: { name: 'CalculationFeature' } }
    /**
     * Find zero or one CalculationFeature that matches the filter.
     * @param {CalculationFeatureFindUniqueArgs} args - Arguments to find a CalculationFeature
     * @example
     * // Get one CalculationFeature
     * const calculationFeature = await prisma.calculationFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalculationFeatureFindUniqueArgs>(args: SelectSubset<T, CalculationFeatureFindUniqueArgs<ExtArgs>>): Prisma__CalculationFeatureClient<$Result.GetResult<Prisma.$CalculationFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CalculationFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalculationFeatureFindUniqueOrThrowArgs} args - Arguments to find a CalculationFeature
     * @example
     * // Get one CalculationFeature
     * const calculationFeature = await prisma.calculationFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalculationFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, CalculationFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalculationFeatureClient<$Result.GetResult<Prisma.$CalculationFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalculationFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationFeatureFindFirstArgs} args - Arguments to find a CalculationFeature
     * @example
     * // Get one CalculationFeature
     * const calculationFeature = await prisma.calculationFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalculationFeatureFindFirstArgs>(args?: SelectSubset<T, CalculationFeatureFindFirstArgs<ExtArgs>>): Prisma__CalculationFeatureClient<$Result.GetResult<Prisma.$CalculationFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalculationFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationFeatureFindFirstOrThrowArgs} args - Arguments to find a CalculationFeature
     * @example
     * // Get one CalculationFeature
     * const calculationFeature = await prisma.calculationFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalculationFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, CalculationFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalculationFeatureClient<$Result.GetResult<Prisma.$CalculationFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CalculationFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalculationFeatures
     * const calculationFeatures = await prisma.calculationFeature.findMany()
     * 
     * // Get first 10 CalculationFeatures
     * const calculationFeatures = await prisma.calculationFeature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calculationFeatureWithIdOnly = await prisma.calculationFeature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalculationFeatureFindManyArgs>(args?: SelectSubset<T, CalculationFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalculationFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CalculationFeature.
     * @param {CalculationFeatureCreateArgs} args - Arguments to create a CalculationFeature.
     * @example
     * // Create one CalculationFeature
     * const CalculationFeature = await prisma.calculationFeature.create({
     *   data: {
     *     // ... data to create a CalculationFeature
     *   }
     * })
     * 
     */
    create<T extends CalculationFeatureCreateArgs>(args: SelectSubset<T, CalculationFeatureCreateArgs<ExtArgs>>): Prisma__CalculationFeatureClient<$Result.GetResult<Prisma.$CalculationFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CalculationFeatures.
     * @param {CalculationFeatureCreateManyArgs} args - Arguments to create many CalculationFeatures.
     * @example
     * // Create many CalculationFeatures
     * const calculationFeature = await prisma.calculationFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalculationFeatureCreateManyArgs>(args?: SelectSubset<T, CalculationFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalculationFeatures and returns the data saved in the database.
     * @param {CalculationFeatureCreateManyAndReturnArgs} args - Arguments to create many CalculationFeatures.
     * @example
     * // Create many CalculationFeatures
     * const calculationFeature = await prisma.calculationFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalculationFeatures and only return the `id`
     * const calculationFeatureWithIdOnly = await prisma.calculationFeature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalculationFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, CalculationFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalculationFeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CalculationFeature.
     * @param {CalculationFeatureDeleteArgs} args - Arguments to delete one CalculationFeature.
     * @example
     * // Delete one CalculationFeature
     * const CalculationFeature = await prisma.calculationFeature.delete({
     *   where: {
     *     // ... filter to delete one CalculationFeature
     *   }
     * })
     * 
     */
    delete<T extends CalculationFeatureDeleteArgs>(args: SelectSubset<T, CalculationFeatureDeleteArgs<ExtArgs>>): Prisma__CalculationFeatureClient<$Result.GetResult<Prisma.$CalculationFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CalculationFeature.
     * @param {CalculationFeatureUpdateArgs} args - Arguments to update one CalculationFeature.
     * @example
     * // Update one CalculationFeature
     * const calculationFeature = await prisma.calculationFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalculationFeatureUpdateArgs>(args: SelectSubset<T, CalculationFeatureUpdateArgs<ExtArgs>>): Prisma__CalculationFeatureClient<$Result.GetResult<Prisma.$CalculationFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CalculationFeatures.
     * @param {CalculationFeatureDeleteManyArgs} args - Arguments to filter CalculationFeatures to delete.
     * @example
     * // Delete a few CalculationFeatures
     * const { count } = await prisma.calculationFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalculationFeatureDeleteManyArgs>(args?: SelectSubset<T, CalculationFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalculationFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalculationFeatures
     * const calculationFeature = await prisma.calculationFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalculationFeatureUpdateManyArgs>(args: SelectSubset<T, CalculationFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalculationFeatures and returns the data updated in the database.
     * @param {CalculationFeatureUpdateManyAndReturnArgs} args - Arguments to update many CalculationFeatures.
     * @example
     * // Update many CalculationFeatures
     * const calculationFeature = await prisma.calculationFeature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CalculationFeatures and only return the `id`
     * const calculationFeatureWithIdOnly = await prisma.calculationFeature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CalculationFeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, CalculationFeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalculationFeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CalculationFeature.
     * @param {CalculationFeatureUpsertArgs} args - Arguments to update or create a CalculationFeature.
     * @example
     * // Update or create a CalculationFeature
     * const calculationFeature = await prisma.calculationFeature.upsert({
     *   create: {
     *     // ... data to create a CalculationFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalculationFeature we want to update
     *   }
     * })
     */
    upsert<T extends CalculationFeatureUpsertArgs>(args: SelectSubset<T, CalculationFeatureUpsertArgs<ExtArgs>>): Prisma__CalculationFeatureClient<$Result.GetResult<Prisma.$CalculationFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CalculationFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationFeatureCountArgs} args - Arguments to filter CalculationFeatures to count.
     * @example
     * // Count the number of CalculationFeatures
     * const count = await prisma.calculationFeature.count({
     *   where: {
     *     // ... the filter for the CalculationFeatures we want to count
     *   }
     * })
    **/
    count<T extends CalculationFeatureCountArgs>(
      args?: Subset<T, CalculationFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalculationFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalculationFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalculationFeatureAggregateArgs>(args: Subset<T, CalculationFeatureAggregateArgs>): Prisma.PrismaPromise<GetCalculationFeatureAggregateType<T>>

    /**
     * Group by CalculationFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalculationFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalculationFeatureGroupByArgs['orderBy'] }
        : { orderBy?: CalculationFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalculationFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalculationFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalculationFeature model
   */
  readonly fields: CalculationFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalculationFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalculationFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    calculation<T extends PricingCalculationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PricingCalculationDefaultArgs<ExtArgs>>): Prisma__PricingCalculationClient<$Result.GetResult<Prisma.$PricingCalculationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    feature<T extends FeatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatureDefaultArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tier<T extends FeatureTierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatureTierDefaultArgs<ExtArgs>>): Prisma__FeatureTierClient<$Result.GetResult<Prisma.$FeatureTierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalculationFeature model
   */
  interface CalculationFeatureFieldRefs {
    readonly id: FieldRef<"CalculationFeature", 'String'>
    readonly calculationId: FieldRef<"CalculationFeature", 'String'>
    readonly featureId: FieldRef<"CalculationFeature", 'String'>
    readonly tierName: FieldRef<"CalculationFeature", 'String'>
    readonly count: FieldRef<"CalculationFeature", 'Int'>
    readonly unitPrice: FieldRef<"CalculationFeature", 'Decimal'>
    readonly totalPrice: FieldRef<"CalculationFeature", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * CalculationFeature findUnique
   */
  export type CalculationFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationFeature
     */
    select?: CalculationFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationFeature
     */
    omit?: CalculationFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationFeatureInclude<ExtArgs> | null
    /**
     * Filter, which CalculationFeature to fetch.
     */
    where: CalculationFeatureWhereUniqueInput
  }

  /**
   * CalculationFeature findUniqueOrThrow
   */
  export type CalculationFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationFeature
     */
    select?: CalculationFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationFeature
     */
    omit?: CalculationFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationFeatureInclude<ExtArgs> | null
    /**
     * Filter, which CalculationFeature to fetch.
     */
    where: CalculationFeatureWhereUniqueInput
  }

  /**
   * CalculationFeature findFirst
   */
  export type CalculationFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationFeature
     */
    select?: CalculationFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationFeature
     */
    omit?: CalculationFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationFeatureInclude<ExtArgs> | null
    /**
     * Filter, which CalculationFeature to fetch.
     */
    where?: CalculationFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalculationFeatures to fetch.
     */
    orderBy?: CalculationFeatureOrderByWithRelationInput | CalculationFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalculationFeatures.
     */
    cursor?: CalculationFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalculationFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalculationFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalculationFeatures.
     */
    distinct?: CalculationFeatureScalarFieldEnum | CalculationFeatureScalarFieldEnum[]
  }

  /**
   * CalculationFeature findFirstOrThrow
   */
  export type CalculationFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationFeature
     */
    select?: CalculationFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationFeature
     */
    omit?: CalculationFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationFeatureInclude<ExtArgs> | null
    /**
     * Filter, which CalculationFeature to fetch.
     */
    where?: CalculationFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalculationFeatures to fetch.
     */
    orderBy?: CalculationFeatureOrderByWithRelationInput | CalculationFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalculationFeatures.
     */
    cursor?: CalculationFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalculationFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalculationFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalculationFeatures.
     */
    distinct?: CalculationFeatureScalarFieldEnum | CalculationFeatureScalarFieldEnum[]
  }

  /**
   * CalculationFeature findMany
   */
  export type CalculationFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationFeature
     */
    select?: CalculationFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationFeature
     */
    omit?: CalculationFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationFeatureInclude<ExtArgs> | null
    /**
     * Filter, which CalculationFeatures to fetch.
     */
    where?: CalculationFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalculationFeatures to fetch.
     */
    orderBy?: CalculationFeatureOrderByWithRelationInput | CalculationFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalculationFeatures.
     */
    cursor?: CalculationFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalculationFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalculationFeatures.
     */
    skip?: number
    distinct?: CalculationFeatureScalarFieldEnum | CalculationFeatureScalarFieldEnum[]
  }

  /**
   * CalculationFeature create
   */
  export type CalculationFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationFeature
     */
    select?: CalculationFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationFeature
     */
    omit?: CalculationFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a CalculationFeature.
     */
    data: XOR<CalculationFeatureCreateInput, CalculationFeatureUncheckedCreateInput>
  }

  /**
   * CalculationFeature createMany
   */
  export type CalculationFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalculationFeatures.
     */
    data: CalculationFeatureCreateManyInput | CalculationFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalculationFeature createManyAndReturn
   */
  export type CalculationFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationFeature
     */
    select?: CalculationFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationFeature
     */
    omit?: CalculationFeatureOmit<ExtArgs> | null
    /**
     * The data used to create many CalculationFeatures.
     */
    data: CalculationFeatureCreateManyInput | CalculationFeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationFeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalculationFeature update
   */
  export type CalculationFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationFeature
     */
    select?: CalculationFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationFeature
     */
    omit?: CalculationFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a CalculationFeature.
     */
    data: XOR<CalculationFeatureUpdateInput, CalculationFeatureUncheckedUpdateInput>
    /**
     * Choose, which CalculationFeature to update.
     */
    where: CalculationFeatureWhereUniqueInput
  }

  /**
   * CalculationFeature updateMany
   */
  export type CalculationFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalculationFeatures.
     */
    data: XOR<CalculationFeatureUpdateManyMutationInput, CalculationFeatureUncheckedUpdateManyInput>
    /**
     * Filter which CalculationFeatures to update
     */
    where?: CalculationFeatureWhereInput
    /**
     * Limit how many CalculationFeatures to update.
     */
    limit?: number
  }

  /**
   * CalculationFeature updateManyAndReturn
   */
  export type CalculationFeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationFeature
     */
    select?: CalculationFeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationFeature
     */
    omit?: CalculationFeatureOmit<ExtArgs> | null
    /**
     * The data used to update CalculationFeatures.
     */
    data: XOR<CalculationFeatureUpdateManyMutationInput, CalculationFeatureUncheckedUpdateManyInput>
    /**
     * Filter which CalculationFeatures to update
     */
    where?: CalculationFeatureWhereInput
    /**
     * Limit how many CalculationFeatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationFeatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalculationFeature upsert
   */
  export type CalculationFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationFeature
     */
    select?: CalculationFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationFeature
     */
    omit?: CalculationFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the CalculationFeature to update in case it exists.
     */
    where: CalculationFeatureWhereUniqueInput
    /**
     * In case the CalculationFeature found by the `where` argument doesn't exist, create a new CalculationFeature with this data.
     */
    create: XOR<CalculationFeatureCreateInput, CalculationFeatureUncheckedCreateInput>
    /**
     * In case the CalculationFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalculationFeatureUpdateInput, CalculationFeatureUncheckedUpdateInput>
  }

  /**
   * CalculationFeature delete
   */
  export type CalculationFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationFeature
     */
    select?: CalculationFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationFeature
     */
    omit?: CalculationFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationFeatureInclude<ExtArgs> | null
    /**
     * Filter which CalculationFeature to delete.
     */
    where: CalculationFeatureWhereUniqueInput
  }

  /**
   * CalculationFeature deleteMany
   */
  export type CalculationFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalculationFeatures to delete
     */
    where?: CalculationFeatureWhereInput
    /**
     * Limit how many CalculationFeatures to delete.
     */
    limit?: number
  }

  /**
   * CalculationFeature without action
   */
  export type CalculationFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationFeature
     */
    select?: CalculationFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationFeature
     */
    omit?: CalculationFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationFeatureInclude<ExtArgs> | null
  }


  /**
   * Model ContactInfo
   */

  export type AggregateContactInfo = {
    _count: ContactInfoCountAggregateOutputType | null
    _min: ContactInfoMinAggregateOutputType | null
    _max: ContactInfoMaxAggregateOutputType | null
  }

  export type ContactInfoMinAggregateOutputType = {
    id: string | null
    type: string | null
    label: string | null
    iconName: string | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ContactInfoMaxAggregateOutputType = {
    id: string | null
    type: string | null
    label: string | null
    iconName: string | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ContactInfoCountAggregateOutputType = {
    id: number
    type: number
    label: number
    value: number
    iconName: number
    color: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type ContactInfoMinAggregateInputType = {
    id?: true
    type?: true
    label?: true
    iconName?: true
    color?: true
    isActive?: true
    createdAt?: true
  }

  export type ContactInfoMaxAggregateInputType = {
    id?: true
    type?: true
    label?: true
    iconName?: true
    color?: true
    isActive?: true
    createdAt?: true
  }

  export type ContactInfoCountAggregateInputType = {
    id?: true
    type?: true
    label?: true
    value?: true
    iconName?: true
    color?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type ContactInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactInfo to aggregate.
     */
    where?: ContactInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInfos to fetch.
     */
    orderBy?: ContactInfoOrderByWithRelationInput | ContactInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactInfos
    **/
    _count?: true | ContactInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactInfoMaxAggregateInputType
  }

  export type GetContactInfoAggregateType<T extends ContactInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateContactInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactInfo[P]>
      : GetScalarType<T[P], AggregateContactInfo[P]>
  }




  export type ContactInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactInfoWhereInput
    orderBy?: ContactInfoOrderByWithAggregationInput | ContactInfoOrderByWithAggregationInput[]
    by: ContactInfoScalarFieldEnum[] | ContactInfoScalarFieldEnum
    having?: ContactInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactInfoCountAggregateInputType | true
    _min?: ContactInfoMinAggregateInputType
    _max?: ContactInfoMaxAggregateInputType
  }

  export type ContactInfoGroupByOutputType = {
    id: string
    type: string
    label: string
    value: JsonValue
    iconName: string
    color: string
    isActive: boolean
    createdAt: Date
    _count: ContactInfoCountAggregateOutputType | null
    _min: ContactInfoMinAggregateOutputType | null
    _max: ContactInfoMaxAggregateOutputType | null
  }

  type GetContactInfoGroupByPayload<T extends ContactInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactInfoGroupByOutputType[P]>
            : GetScalarType<T[P], ContactInfoGroupByOutputType[P]>
        }
      >
    >


  export type ContactInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    label?: boolean
    value?: boolean
    iconName?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contactInfo"]>

  export type ContactInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    label?: boolean
    value?: boolean
    iconName?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contactInfo"]>

  export type ContactInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    label?: boolean
    value?: boolean
    iconName?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contactInfo"]>

  export type ContactInfoSelectScalar = {
    id?: boolean
    type?: boolean
    label?: boolean
    value?: boolean
    iconName?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type ContactInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "label" | "value" | "iconName" | "color" | "isActive" | "createdAt", ExtArgs["result"]["contactInfo"]>

  export type $ContactInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactInfo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      label: string
      value: Prisma.JsonValue
      iconName: string
      color: string
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["contactInfo"]>
    composites: {}
  }

  type ContactInfoGetPayload<S extends boolean | null | undefined | ContactInfoDefaultArgs> = $Result.GetResult<Prisma.$ContactInfoPayload, S>

  type ContactInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactInfoCountAggregateInputType | true
    }

  export interface ContactInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactInfo'], meta: { name: 'ContactInfo' } }
    /**
     * Find zero or one ContactInfo that matches the filter.
     * @param {ContactInfoFindUniqueArgs} args - Arguments to find a ContactInfo
     * @example
     * // Get one ContactInfo
     * const contactInfo = await prisma.contactInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactInfoFindUniqueArgs>(args: SelectSubset<T, ContactInfoFindUniqueArgs<ExtArgs>>): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactInfoFindUniqueOrThrowArgs} args - Arguments to find a ContactInfo
     * @example
     * // Get one ContactInfo
     * const contactInfo = await prisma.contactInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoFindFirstArgs} args - Arguments to find a ContactInfo
     * @example
     * // Get one ContactInfo
     * const contactInfo = await prisma.contactInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactInfoFindFirstArgs>(args?: SelectSubset<T, ContactInfoFindFirstArgs<ExtArgs>>): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoFindFirstOrThrowArgs} args - Arguments to find a ContactInfo
     * @example
     * // Get one ContactInfo
     * const contactInfo = await prisma.contactInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactInfos
     * const contactInfos = await prisma.contactInfo.findMany()
     * 
     * // Get first 10 ContactInfos
     * const contactInfos = await prisma.contactInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactInfoWithIdOnly = await prisma.contactInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactInfoFindManyArgs>(args?: SelectSubset<T, ContactInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactInfo.
     * @param {ContactInfoCreateArgs} args - Arguments to create a ContactInfo.
     * @example
     * // Create one ContactInfo
     * const ContactInfo = await prisma.contactInfo.create({
     *   data: {
     *     // ... data to create a ContactInfo
     *   }
     * })
     * 
     */
    create<T extends ContactInfoCreateArgs>(args: SelectSubset<T, ContactInfoCreateArgs<ExtArgs>>): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactInfos.
     * @param {ContactInfoCreateManyArgs} args - Arguments to create many ContactInfos.
     * @example
     * // Create many ContactInfos
     * const contactInfo = await prisma.contactInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactInfoCreateManyArgs>(args?: SelectSubset<T, ContactInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactInfos and returns the data saved in the database.
     * @param {ContactInfoCreateManyAndReturnArgs} args - Arguments to create many ContactInfos.
     * @example
     * // Create many ContactInfos
     * const contactInfo = await prisma.contactInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactInfos and only return the `id`
     * const contactInfoWithIdOnly = await prisma.contactInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactInfo.
     * @param {ContactInfoDeleteArgs} args - Arguments to delete one ContactInfo.
     * @example
     * // Delete one ContactInfo
     * const ContactInfo = await prisma.contactInfo.delete({
     *   where: {
     *     // ... filter to delete one ContactInfo
     *   }
     * })
     * 
     */
    delete<T extends ContactInfoDeleteArgs>(args: SelectSubset<T, ContactInfoDeleteArgs<ExtArgs>>): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactInfo.
     * @param {ContactInfoUpdateArgs} args - Arguments to update one ContactInfo.
     * @example
     * // Update one ContactInfo
     * const contactInfo = await prisma.contactInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactInfoUpdateArgs>(args: SelectSubset<T, ContactInfoUpdateArgs<ExtArgs>>): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactInfos.
     * @param {ContactInfoDeleteManyArgs} args - Arguments to filter ContactInfos to delete.
     * @example
     * // Delete a few ContactInfos
     * const { count } = await prisma.contactInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactInfoDeleteManyArgs>(args?: SelectSubset<T, ContactInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactInfos
     * const contactInfo = await prisma.contactInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactInfoUpdateManyArgs>(args: SelectSubset<T, ContactInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactInfos and returns the data updated in the database.
     * @param {ContactInfoUpdateManyAndReturnArgs} args - Arguments to update many ContactInfos.
     * @example
     * // Update many ContactInfos
     * const contactInfo = await prisma.contactInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactInfos and only return the `id`
     * const contactInfoWithIdOnly = await prisma.contactInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactInfo.
     * @param {ContactInfoUpsertArgs} args - Arguments to update or create a ContactInfo.
     * @example
     * // Update or create a ContactInfo
     * const contactInfo = await prisma.contactInfo.upsert({
     *   create: {
     *     // ... data to create a ContactInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactInfo we want to update
     *   }
     * })
     */
    upsert<T extends ContactInfoUpsertArgs>(args: SelectSubset<T, ContactInfoUpsertArgs<ExtArgs>>): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoCountArgs} args - Arguments to filter ContactInfos to count.
     * @example
     * // Count the number of ContactInfos
     * const count = await prisma.contactInfo.count({
     *   where: {
     *     // ... the filter for the ContactInfos we want to count
     *   }
     * })
    **/
    count<T extends ContactInfoCountArgs>(
      args?: Subset<T, ContactInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactInfoAggregateArgs>(args: Subset<T, ContactInfoAggregateArgs>): Prisma.PrismaPromise<GetContactInfoAggregateType<T>>

    /**
     * Group by ContactInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactInfoGroupByArgs['orderBy'] }
        : { orderBy?: ContactInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactInfo model
   */
  readonly fields: ContactInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactInfo model
   */
  interface ContactInfoFieldRefs {
    readonly id: FieldRef<"ContactInfo", 'String'>
    readonly type: FieldRef<"ContactInfo", 'String'>
    readonly label: FieldRef<"ContactInfo", 'String'>
    readonly value: FieldRef<"ContactInfo", 'Json'>
    readonly iconName: FieldRef<"ContactInfo", 'String'>
    readonly color: FieldRef<"ContactInfo", 'String'>
    readonly isActive: FieldRef<"ContactInfo", 'Boolean'>
    readonly createdAt: FieldRef<"ContactInfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactInfo findUnique
   */
  export type ContactInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * Filter, which ContactInfo to fetch.
     */
    where: ContactInfoWhereUniqueInput
  }

  /**
   * ContactInfo findUniqueOrThrow
   */
  export type ContactInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * Filter, which ContactInfo to fetch.
     */
    where: ContactInfoWhereUniqueInput
  }

  /**
   * ContactInfo findFirst
   */
  export type ContactInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * Filter, which ContactInfo to fetch.
     */
    where?: ContactInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInfos to fetch.
     */
    orderBy?: ContactInfoOrderByWithRelationInput | ContactInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactInfos.
     */
    cursor?: ContactInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactInfos.
     */
    distinct?: ContactInfoScalarFieldEnum | ContactInfoScalarFieldEnum[]
  }

  /**
   * ContactInfo findFirstOrThrow
   */
  export type ContactInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * Filter, which ContactInfo to fetch.
     */
    where?: ContactInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInfos to fetch.
     */
    orderBy?: ContactInfoOrderByWithRelationInput | ContactInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactInfos.
     */
    cursor?: ContactInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactInfos.
     */
    distinct?: ContactInfoScalarFieldEnum | ContactInfoScalarFieldEnum[]
  }

  /**
   * ContactInfo findMany
   */
  export type ContactInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * Filter, which ContactInfos to fetch.
     */
    where?: ContactInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInfos to fetch.
     */
    orderBy?: ContactInfoOrderByWithRelationInput | ContactInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactInfos.
     */
    cursor?: ContactInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInfos.
     */
    skip?: number
    distinct?: ContactInfoScalarFieldEnum | ContactInfoScalarFieldEnum[]
  }

  /**
   * ContactInfo create
   */
  export type ContactInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactInfo.
     */
    data: XOR<ContactInfoCreateInput, ContactInfoUncheckedCreateInput>
  }

  /**
   * ContactInfo createMany
   */
  export type ContactInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactInfos.
     */
    data: ContactInfoCreateManyInput | ContactInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactInfo createManyAndReturn
   */
  export type ContactInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * The data used to create many ContactInfos.
     */
    data: ContactInfoCreateManyInput | ContactInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactInfo update
   */
  export type ContactInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactInfo.
     */
    data: XOR<ContactInfoUpdateInput, ContactInfoUncheckedUpdateInput>
    /**
     * Choose, which ContactInfo to update.
     */
    where: ContactInfoWhereUniqueInput
  }

  /**
   * ContactInfo updateMany
   */
  export type ContactInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactInfos.
     */
    data: XOR<ContactInfoUpdateManyMutationInput, ContactInfoUncheckedUpdateManyInput>
    /**
     * Filter which ContactInfos to update
     */
    where?: ContactInfoWhereInput
    /**
     * Limit how many ContactInfos to update.
     */
    limit?: number
  }

  /**
   * ContactInfo updateManyAndReturn
   */
  export type ContactInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * The data used to update ContactInfos.
     */
    data: XOR<ContactInfoUpdateManyMutationInput, ContactInfoUncheckedUpdateManyInput>
    /**
     * Filter which ContactInfos to update
     */
    where?: ContactInfoWhereInput
    /**
     * Limit how many ContactInfos to update.
     */
    limit?: number
  }

  /**
   * ContactInfo upsert
   */
  export type ContactInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactInfo to update in case it exists.
     */
    where: ContactInfoWhereUniqueInput
    /**
     * In case the ContactInfo found by the `where` argument doesn't exist, create a new ContactInfo with this data.
     */
    create: XOR<ContactInfoCreateInput, ContactInfoUncheckedCreateInput>
    /**
     * In case the ContactInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactInfoUpdateInput, ContactInfoUncheckedUpdateInput>
  }

  /**
   * ContactInfo delete
   */
  export type ContactInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
    /**
     * Filter which ContactInfo to delete.
     */
    where: ContactInfoWhereUniqueInput
  }

  /**
   * ContactInfo deleteMany
   */
  export type ContactInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactInfos to delete
     */
    where?: ContactInfoWhereInput
    /**
     * Limit how many ContactInfos to delete.
     */
    limit?: number
  }

  /**
   * ContactInfo without action
   */
  export type ContactInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInfo
     */
    omit?: ContactInfoOmit<ExtArgs> | null
  }


  /**
   * Model ProjectType
   */

  export type AggregateProjectType = {
    _count: ProjectTypeCountAggregateOutputType | null
    _min: ProjectTypeMinAggregateOutputType | null
    _max: ProjectTypeMaxAggregateOutputType | null
  }

  export type ProjectTypeMinAggregateOutputType = {
    id: string | null
    value: string | null
    label: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ProjectTypeMaxAggregateOutputType = {
    id: string | null
    value: string | null
    label: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ProjectTypeCountAggregateOutputType = {
    id: number
    value: number
    label: number
    description: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type ProjectTypeMinAggregateInputType = {
    id?: true
    value?: true
    label?: true
    description?: true
    isActive?: true
    createdAt?: true
  }

  export type ProjectTypeMaxAggregateInputType = {
    id?: true
    value?: true
    label?: true
    description?: true
    isActive?: true
    createdAt?: true
  }

  export type ProjectTypeCountAggregateInputType = {
    id?: true
    value?: true
    label?: true
    description?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type ProjectTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectType to aggregate.
     */
    where?: ProjectTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTypes to fetch.
     */
    orderBy?: ProjectTypeOrderByWithRelationInput | ProjectTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectTypes
    **/
    _count?: true | ProjectTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectTypeMaxAggregateInputType
  }

  export type GetProjectTypeAggregateType<T extends ProjectTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectType[P]>
      : GetScalarType<T[P], AggregateProjectType[P]>
  }




  export type ProjectTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTypeWhereInput
    orderBy?: ProjectTypeOrderByWithAggregationInput | ProjectTypeOrderByWithAggregationInput[]
    by: ProjectTypeScalarFieldEnum[] | ProjectTypeScalarFieldEnum
    having?: ProjectTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectTypeCountAggregateInputType | true
    _min?: ProjectTypeMinAggregateInputType
    _max?: ProjectTypeMaxAggregateInputType
  }

  export type ProjectTypeGroupByOutputType = {
    id: string
    value: string
    label: string
    description: string | null
    isActive: boolean
    createdAt: Date
    _count: ProjectTypeCountAggregateOutputType | null
    _min: ProjectTypeMinAggregateOutputType | null
    _max: ProjectTypeMaxAggregateOutputType | null
  }

  type GetProjectTypeGroupByPayload<T extends ProjectTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectTypeGroupByOutputType[P]>
        }
      >
    >


  export type ProjectTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    label?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["projectType"]>

  export type ProjectTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    label?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["projectType"]>

  export type ProjectTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    label?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["projectType"]>

  export type ProjectTypeSelectScalar = {
    id?: boolean
    value?: boolean
    label?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type ProjectTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "label" | "description" | "isActive" | "createdAt", ExtArgs["result"]["projectType"]>

  export type $ProjectTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: string
      label: string
      description: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["projectType"]>
    composites: {}
  }

  type ProjectTypeGetPayload<S extends boolean | null | undefined | ProjectTypeDefaultArgs> = $Result.GetResult<Prisma.$ProjectTypePayload, S>

  type ProjectTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectTypeCountAggregateInputType | true
    }

  export interface ProjectTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectType'], meta: { name: 'ProjectType' } }
    /**
     * Find zero or one ProjectType that matches the filter.
     * @param {ProjectTypeFindUniqueArgs} args - Arguments to find a ProjectType
     * @example
     * // Get one ProjectType
     * const projectType = await prisma.projectType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectTypeFindUniqueArgs>(args: SelectSubset<T, ProjectTypeFindUniqueArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectTypeFindUniqueOrThrowArgs} args - Arguments to find a ProjectType
     * @example
     * // Get one ProjectType
     * const projectType = await prisma.projectType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeFindFirstArgs} args - Arguments to find a ProjectType
     * @example
     * // Get one ProjectType
     * const projectType = await prisma.projectType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectTypeFindFirstArgs>(args?: SelectSubset<T, ProjectTypeFindFirstArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeFindFirstOrThrowArgs} args - Arguments to find a ProjectType
     * @example
     * // Get one ProjectType
     * const projectType = await prisma.projectType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectTypes
     * const projectTypes = await prisma.projectType.findMany()
     * 
     * // Get first 10 ProjectTypes
     * const projectTypes = await prisma.projectType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectTypeWithIdOnly = await prisma.projectType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectTypeFindManyArgs>(args?: SelectSubset<T, ProjectTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectType.
     * @param {ProjectTypeCreateArgs} args - Arguments to create a ProjectType.
     * @example
     * // Create one ProjectType
     * const ProjectType = await prisma.projectType.create({
     *   data: {
     *     // ... data to create a ProjectType
     *   }
     * })
     * 
     */
    create<T extends ProjectTypeCreateArgs>(args: SelectSubset<T, ProjectTypeCreateArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectTypes.
     * @param {ProjectTypeCreateManyArgs} args - Arguments to create many ProjectTypes.
     * @example
     * // Create many ProjectTypes
     * const projectType = await prisma.projectType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectTypeCreateManyArgs>(args?: SelectSubset<T, ProjectTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectTypes and returns the data saved in the database.
     * @param {ProjectTypeCreateManyAndReturnArgs} args - Arguments to create many ProjectTypes.
     * @example
     * // Create many ProjectTypes
     * const projectType = await prisma.projectType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectTypes and only return the `id`
     * const projectTypeWithIdOnly = await prisma.projectType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectType.
     * @param {ProjectTypeDeleteArgs} args - Arguments to delete one ProjectType.
     * @example
     * // Delete one ProjectType
     * const ProjectType = await prisma.projectType.delete({
     *   where: {
     *     // ... filter to delete one ProjectType
     *   }
     * })
     * 
     */
    delete<T extends ProjectTypeDeleteArgs>(args: SelectSubset<T, ProjectTypeDeleteArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectType.
     * @param {ProjectTypeUpdateArgs} args - Arguments to update one ProjectType.
     * @example
     * // Update one ProjectType
     * const projectType = await prisma.projectType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectTypeUpdateArgs>(args: SelectSubset<T, ProjectTypeUpdateArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectTypes.
     * @param {ProjectTypeDeleteManyArgs} args - Arguments to filter ProjectTypes to delete.
     * @example
     * // Delete a few ProjectTypes
     * const { count } = await prisma.projectType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectTypeDeleteManyArgs>(args?: SelectSubset<T, ProjectTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectTypes
     * const projectType = await prisma.projectType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectTypeUpdateManyArgs>(args: SelectSubset<T, ProjectTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTypes and returns the data updated in the database.
     * @param {ProjectTypeUpdateManyAndReturnArgs} args - Arguments to update many ProjectTypes.
     * @example
     * // Update many ProjectTypes
     * const projectType = await prisma.projectType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectTypes and only return the `id`
     * const projectTypeWithIdOnly = await prisma.projectType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectType.
     * @param {ProjectTypeUpsertArgs} args - Arguments to update or create a ProjectType.
     * @example
     * // Update or create a ProjectType
     * const projectType = await prisma.projectType.upsert({
     *   create: {
     *     // ... data to create a ProjectType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectType we want to update
     *   }
     * })
     */
    upsert<T extends ProjectTypeUpsertArgs>(args: SelectSubset<T, ProjectTypeUpsertArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeCountArgs} args - Arguments to filter ProjectTypes to count.
     * @example
     * // Count the number of ProjectTypes
     * const count = await prisma.projectType.count({
     *   where: {
     *     // ... the filter for the ProjectTypes we want to count
     *   }
     * })
    **/
    count<T extends ProjectTypeCountArgs>(
      args?: Subset<T, ProjectTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectTypeAggregateArgs>(args: Subset<T, ProjectTypeAggregateArgs>): Prisma.PrismaPromise<GetProjectTypeAggregateType<T>>

    /**
     * Group by ProjectType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectTypeGroupByArgs['orderBy'] }
        : { orderBy?: ProjectTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectType model
   */
  readonly fields: ProjectTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectType model
   */
  interface ProjectTypeFieldRefs {
    readonly id: FieldRef<"ProjectType", 'String'>
    readonly value: FieldRef<"ProjectType", 'String'>
    readonly label: FieldRef<"ProjectType", 'String'>
    readonly description: FieldRef<"ProjectType", 'String'>
    readonly isActive: FieldRef<"ProjectType", 'Boolean'>
    readonly createdAt: FieldRef<"ProjectType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectType findUnique
   */
  export type ProjectTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * Filter, which ProjectType to fetch.
     */
    where: ProjectTypeWhereUniqueInput
  }

  /**
   * ProjectType findUniqueOrThrow
   */
  export type ProjectTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * Filter, which ProjectType to fetch.
     */
    where: ProjectTypeWhereUniqueInput
  }

  /**
   * ProjectType findFirst
   */
  export type ProjectTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * Filter, which ProjectType to fetch.
     */
    where?: ProjectTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTypes to fetch.
     */
    orderBy?: ProjectTypeOrderByWithRelationInput | ProjectTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTypes.
     */
    cursor?: ProjectTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTypes.
     */
    distinct?: ProjectTypeScalarFieldEnum | ProjectTypeScalarFieldEnum[]
  }

  /**
   * ProjectType findFirstOrThrow
   */
  export type ProjectTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * Filter, which ProjectType to fetch.
     */
    where?: ProjectTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTypes to fetch.
     */
    orderBy?: ProjectTypeOrderByWithRelationInput | ProjectTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTypes.
     */
    cursor?: ProjectTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTypes.
     */
    distinct?: ProjectTypeScalarFieldEnum | ProjectTypeScalarFieldEnum[]
  }

  /**
   * ProjectType findMany
   */
  export type ProjectTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * Filter, which ProjectTypes to fetch.
     */
    where?: ProjectTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTypes to fetch.
     */
    orderBy?: ProjectTypeOrderByWithRelationInput | ProjectTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectTypes.
     */
    cursor?: ProjectTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTypes.
     */
    skip?: number
    distinct?: ProjectTypeScalarFieldEnum | ProjectTypeScalarFieldEnum[]
  }

  /**
   * ProjectType create
   */
  export type ProjectTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * The data needed to create a ProjectType.
     */
    data: XOR<ProjectTypeCreateInput, ProjectTypeUncheckedCreateInput>
  }

  /**
   * ProjectType createMany
   */
  export type ProjectTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectTypes.
     */
    data: ProjectTypeCreateManyInput | ProjectTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectType createManyAndReturn
   */
  export type ProjectTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectTypes.
     */
    data: ProjectTypeCreateManyInput | ProjectTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectType update
   */
  export type ProjectTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * The data needed to update a ProjectType.
     */
    data: XOR<ProjectTypeUpdateInput, ProjectTypeUncheckedUpdateInput>
    /**
     * Choose, which ProjectType to update.
     */
    where: ProjectTypeWhereUniqueInput
  }

  /**
   * ProjectType updateMany
   */
  export type ProjectTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectTypes.
     */
    data: XOR<ProjectTypeUpdateManyMutationInput, ProjectTypeUncheckedUpdateManyInput>
    /**
     * Filter which ProjectTypes to update
     */
    where?: ProjectTypeWhereInput
    /**
     * Limit how many ProjectTypes to update.
     */
    limit?: number
  }

  /**
   * ProjectType updateManyAndReturn
   */
  export type ProjectTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * The data used to update ProjectTypes.
     */
    data: XOR<ProjectTypeUpdateManyMutationInput, ProjectTypeUncheckedUpdateManyInput>
    /**
     * Filter which ProjectTypes to update
     */
    where?: ProjectTypeWhereInput
    /**
     * Limit how many ProjectTypes to update.
     */
    limit?: number
  }

  /**
   * ProjectType upsert
   */
  export type ProjectTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * The filter to search for the ProjectType to update in case it exists.
     */
    where: ProjectTypeWhereUniqueInput
    /**
     * In case the ProjectType found by the `where` argument doesn't exist, create a new ProjectType with this data.
     */
    create: XOR<ProjectTypeCreateInput, ProjectTypeUncheckedCreateInput>
    /**
     * In case the ProjectType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectTypeUpdateInput, ProjectTypeUncheckedUpdateInput>
  }

  /**
   * ProjectType delete
   */
  export type ProjectTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
    /**
     * Filter which ProjectType to delete.
     */
    where: ProjectTypeWhereUniqueInput
  }

  /**
   * ProjectType deleteMany
   */
  export type ProjectTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTypes to delete
     */
    where?: ProjectTypeWhereInput
    /**
     * Limit how many ProjectTypes to delete.
     */
    limit?: number
  }

  /**
   * ProjectType without action
   */
  export type ProjectTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectType
     */
    omit?: ProjectTypeOmit<ExtArgs> | null
  }


  /**
   * Model BudgetRange
   */

  export type AggregateBudgetRange = {
    _count: BudgetRangeCountAggregateOutputType | null
    _avg: BudgetRangeAvgAggregateOutputType | null
    _sum: BudgetRangeSumAggregateOutputType | null
    _min: BudgetRangeMinAggregateOutputType | null
    _max: BudgetRangeMaxAggregateOutputType | null
  }

  export type BudgetRangeAvgAggregateOutputType = {
    minAmount: Decimal | null
    maxAmount: Decimal | null
    displayOrder: number | null
  }

  export type BudgetRangeSumAggregateOutputType = {
    minAmount: Decimal | null
    maxAmount: Decimal | null
    displayOrder: number | null
  }

  export type BudgetRangeMinAggregateOutputType = {
    id: string | null
    value: string | null
    label: string | null
    minAmount: Decimal | null
    maxAmount: Decimal | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type BudgetRangeMaxAggregateOutputType = {
    id: string | null
    value: string | null
    label: string | null
    minAmount: Decimal | null
    maxAmount: Decimal | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type BudgetRangeCountAggregateOutputType = {
    id: number
    value: number
    label: number
    minAmount: number
    maxAmount: number
    displayOrder: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type BudgetRangeAvgAggregateInputType = {
    minAmount?: true
    maxAmount?: true
    displayOrder?: true
  }

  export type BudgetRangeSumAggregateInputType = {
    minAmount?: true
    maxAmount?: true
    displayOrder?: true
  }

  export type BudgetRangeMinAggregateInputType = {
    id?: true
    value?: true
    label?: true
    minAmount?: true
    maxAmount?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type BudgetRangeMaxAggregateInputType = {
    id?: true
    value?: true
    label?: true
    minAmount?: true
    maxAmount?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type BudgetRangeCountAggregateInputType = {
    id?: true
    value?: true
    label?: true
    minAmount?: true
    maxAmount?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type BudgetRangeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetRange to aggregate.
     */
    where?: BudgetRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetRanges to fetch.
     */
    orderBy?: BudgetRangeOrderByWithRelationInput | BudgetRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetRanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BudgetRanges
    **/
    _count?: true | BudgetRangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetRangeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetRangeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetRangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetRangeMaxAggregateInputType
  }

  export type GetBudgetRangeAggregateType<T extends BudgetRangeAggregateArgs> = {
        [P in keyof T & keyof AggregateBudgetRange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudgetRange[P]>
      : GetScalarType<T[P], AggregateBudgetRange[P]>
  }




  export type BudgetRangeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetRangeWhereInput
    orderBy?: BudgetRangeOrderByWithAggregationInput | BudgetRangeOrderByWithAggregationInput[]
    by: BudgetRangeScalarFieldEnum[] | BudgetRangeScalarFieldEnum
    having?: BudgetRangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetRangeCountAggregateInputType | true
    _avg?: BudgetRangeAvgAggregateInputType
    _sum?: BudgetRangeSumAggregateInputType
    _min?: BudgetRangeMinAggregateInputType
    _max?: BudgetRangeMaxAggregateInputType
  }

  export type BudgetRangeGroupByOutputType = {
    id: string
    value: string
    label: string
    minAmount: Decimal | null
    maxAmount: Decimal | null
    displayOrder: number | null
    isActive: boolean
    createdAt: Date
    _count: BudgetRangeCountAggregateOutputType | null
    _avg: BudgetRangeAvgAggregateOutputType | null
    _sum: BudgetRangeSumAggregateOutputType | null
    _min: BudgetRangeMinAggregateOutputType | null
    _max: BudgetRangeMaxAggregateOutputType | null
  }

  type GetBudgetRangeGroupByPayload<T extends BudgetRangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetRangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetRangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetRangeGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetRangeGroupByOutputType[P]>
        }
      >
    >


  export type BudgetRangeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    label?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["budgetRange"]>

  export type BudgetRangeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    label?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["budgetRange"]>

  export type BudgetRangeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    label?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["budgetRange"]>

  export type BudgetRangeSelectScalar = {
    id?: boolean
    value?: boolean
    label?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type BudgetRangeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "label" | "minAmount" | "maxAmount" | "displayOrder" | "isActive" | "createdAt", ExtArgs["result"]["budgetRange"]>

  export type $BudgetRangePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BudgetRange"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: string
      label: string
      minAmount: Prisma.Decimal | null
      maxAmount: Prisma.Decimal | null
      displayOrder: number | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["budgetRange"]>
    composites: {}
  }

  type BudgetRangeGetPayload<S extends boolean | null | undefined | BudgetRangeDefaultArgs> = $Result.GetResult<Prisma.$BudgetRangePayload, S>

  type BudgetRangeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BudgetRangeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BudgetRangeCountAggregateInputType | true
    }

  export interface BudgetRangeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BudgetRange'], meta: { name: 'BudgetRange' } }
    /**
     * Find zero or one BudgetRange that matches the filter.
     * @param {BudgetRangeFindUniqueArgs} args - Arguments to find a BudgetRange
     * @example
     * // Get one BudgetRange
     * const budgetRange = await prisma.budgetRange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetRangeFindUniqueArgs>(args: SelectSubset<T, BudgetRangeFindUniqueArgs<ExtArgs>>): Prisma__BudgetRangeClient<$Result.GetResult<Prisma.$BudgetRangePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BudgetRange that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BudgetRangeFindUniqueOrThrowArgs} args - Arguments to find a BudgetRange
     * @example
     * // Get one BudgetRange
     * const budgetRange = await prisma.budgetRange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetRangeFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetRangeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetRangeClient<$Result.GetResult<Prisma.$BudgetRangePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BudgetRange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetRangeFindFirstArgs} args - Arguments to find a BudgetRange
     * @example
     * // Get one BudgetRange
     * const budgetRange = await prisma.budgetRange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetRangeFindFirstArgs>(args?: SelectSubset<T, BudgetRangeFindFirstArgs<ExtArgs>>): Prisma__BudgetRangeClient<$Result.GetResult<Prisma.$BudgetRangePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BudgetRange that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetRangeFindFirstOrThrowArgs} args - Arguments to find a BudgetRange
     * @example
     * // Get one BudgetRange
     * const budgetRange = await prisma.budgetRange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetRangeFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetRangeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetRangeClient<$Result.GetResult<Prisma.$BudgetRangePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BudgetRanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetRangeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BudgetRanges
     * const budgetRanges = await prisma.budgetRange.findMany()
     * 
     * // Get first 10 BudgetRanges
     * const budgetRanges = await prisma.budgetRange.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetRangeWithIdOnly = await prisma.budgetRange.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetRangeFindManyArgs>(args?: SelectSubset<T, BudgetRangeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetRangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BudgetRange.
     * @param {BudgetRangeCreateArgs} args - Arguments to create a BudgetRange.
     * @example
     * // Create one BudgetRange
     * const BudgetRange = await prisma.budgetRange.create({
     *   data: {
     *     // ... data to create a BudgetRange
     *   }
     * })
     * 
     */
    create<T extends BudgetRangeCreateArgs>(args: SelectSubset<T, BudgetRangeCreateArgs<ExtArgs>>): Prisma__BudgetRangeClient<$Result.GetResult<Prisma.$BudgetRangePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BudgetRanges.
     * @param {BudgetRangeCreateManyArgs} args - Arguments to create many BudgetRanges.
     * @example
     * // Create many BudgetRanges
     * const budgetRange = await prisma.budgetRange.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetRangeCreateManyArgs>(args?: SelectSubset<T, BudgetRangeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BudgetRanges and returns the data saved in the database.
     * @param {BudgetRangeCreateManyAndReturnArgs} args - Arguments to create many BudgetRanges.
     * @example
     * // Create many BudgetRanges
     * const budgetRange = await prisma.budgetRange.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BudgetRanges and only return the `id`
     * const budgetRangeWithIdOnly = await prisma.budgetRange.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetRangeCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetRangeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetRangePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BudgetRange.
     * @param {BudgetRangeDeleteArgs} args - Arguments to delete one BudgetRange.
     * @example
     * // Delete one BudgetRange
     * const BudgetRange = await prisma.budgetRange.delete({
     *   where: {
     *     // ... filter to delete one BudgetRange
     *   }
     * })
     * 
     */
    delete<T extends BudgetRangeDeleteArgs>(args: SelectSubset<T, BudgetRangeDeleteArgs<ExtArgs>>): Prisma__BudgetRangeClient<$Result.GetResult<Prisma.$BudgetRangePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BudgetRange.
     * @param {BudgetRangeUpdateArgs} args - Arguments to update one BudgetRange.
     * @example
     * // Update one BudgetRange
     * const budgetRange = await prisma.budgetRange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetRangeUpdateArgs>(args: SelectSubset<T, BudgetRangeUpdateArgs<ExtArgs>>): Prisma__BudgetRangeClient<$Result.GetResult<Prisma.$BudgetRangePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BudgetRanges.
     * @param {BudgetRangeDeleteManyArgs} args - Arguments to filter BudgetRanges to delete.
     * @example
     * // Delete a few BudgetRanges
     * const { count } = await prisma.budgetRange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetRangeDeleteManyArgs>(args?: SelectSubset<T, BudgetRangeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetRanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetRangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BudgetRanges
     * const budgetRange = await prisma.budgetRange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetRangeUpdateManyArgs>(args: SelectSubset<T, BudgetRangeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetRanges and returns the data updated in the database.
     * @param {BudgetRangeUpdateManyAndReturnArgs} args - Arguments to update many BudgetRanges.
     * @example
     * // Update many BudgetRanges
     * const budgetRange = await prisma.budgetRange.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BudgetRanges and only return the `id`
     * const budgetRangeWithIdOnly = await prisma.budgetRange.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BudgetRangeUpdateManyAndReturnArgs>(args: SelectSubset<T, BudgetRangeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetRangePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BudgetRange.
     * @param {BudgetRangeUpsertArgs} args - Arguments to update or create a BudgetRange.
     * @example
     * // Update or create a BudgetRange
     * const budgetRange = await prisma.budgetRange.upsert({
     *   create: {
     *     // ... data to create a BudgetRange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BudgetRange we want to update
     *   }
     * })
     */
    upsert<T extends BudgetRangeUpsertArgs>(args: SelectSubset<T, BudgetRangeUpsertArgs<ExtArgs>>): Prisma__BudgetRangeClient<$Result.GetResult<Prisma.$BudgetRangePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BudgetRanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetRangeCountArgs} args - Arguments to filter BudgetRanges to count.
     * @example
     * // Count the number of BudgetRanges
     * const count = await prisma.budgetRange.count({
     *   where: {
     *     // ... the filter for the BudgetRanges we want to count
     *   }
     * })
    **/
    count<T extends BudgetRangeCountArgs>(
      args?: Subset<T, BudgetRangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetRangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BudgetRange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetRangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetRangeAggregateArgs>(args: Subset<T, BudgetRangeAggregateArgs>): Prisma.PrismaPromise<GetBudgetRangeAggregateType<T>>

    /**
     * Group by BudgetRange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetRangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetRangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetRangeGroupByArgs['orderBy'] }
        : { orderBy?: BudgetRangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetRangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetRangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BudgetRange model
   */
  readonly fields: BudgetRangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BudgetRange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetRangeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BudgetRange model
   */
  interface BudgetRangeFieldRefs {
    readonly id: FieldRef<"BudgetRange", 'String'>
    readonly value: FieldRef<"BudgetRange", 'String'>
    readonly label: FieldRef<"BudgetRange", 'String'>
    readonly minAmount: FieldRef<"BudgetRange", 'Decimal'>
    readonly maxAmount: FieldRef<"BudgetRange", 'Decimal'>
    readonly displayOrder: FieldRef<"BudgetRange", 'Int'>
    readonly isActive: FieldRef<"BudgetRange", 'Boolean'>
    readonly createdAt: FieldRef<"BudgetRange", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BudgetRange findUnique
   */
  export type BudgetRangeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRange
     */
    select?: BudgetRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRange
     */
    omit?: BudgetRangeOmit<ExtArgs> | null
    /**
     * Filter, which BudgetRange to fetch.
     */
    where: BudgetRangeWhereUniqueInput
  }

  /**
   * BudgetRange findUniqueOrThrow
   */
  export type BudgetRangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRange
     */
    select?: BudgetRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRange
     */
    omit?: BudgetRangeOmit<ExtArgs> | null
    /**
     * Filter, which BudgetRange to fetch.
     */
    where: BudgetRangeWhereUniqueInput
  }

  /**
   * BudgetRange findFirst
   */
  export type BudgetRangeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRange
     */
    select?: BudgetRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRange
     */
    omit?: BudgetRangeOmit<ExtArgs> | null
    /**
     * Filter, which BudgetRange to fetch.
     */
    where?: BudgetRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetRanges to fetch.
     */
    orderBy?: BudgetRangeOrderByWithRelationInput | BudgetRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetRanges.
     */
    cursor?: BudgetRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetRanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetRanges.
     */
    distinct?: BudgetRangeScalarFieldEnum | BudgetRangeScalarFieldEnum[]
  }

  /**
   * BudgetRange findFirstOrThrow
   */
  export type BudgetRangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRange
     */
    select?: BudgetRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRange
     */
    omit?: BudgetRangeOmit<ExtArgs> | null
    /**
     * Filter, which BudgetRange to fetch.
     */
    where?: BudgetRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetRanges to fetch.
     */
    orderBy?: BudgetRangeOrderByWithRelationInput | BudgetRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetRanges.
     */
    cursor?: BudgetRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetRanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetRanges.
     */
    distinct?: BudgetRangeScalarFieldEnum | BudgetRangeScalarFieldEnum[]
  }

  /**
   * BudgetRange findMany
   */
  export type BudgetRangeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRange
     */
    select?: BudgetRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRange
     */
    omit?: BudgetRangeOmit<ExtArgs> | null
    /**
     * Filter, which BudgetRanges to fetch.
     */
    where?: BudgetRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetRanges to fetch.
     */
    orderBy?: BudgetRangeOrderByWithRelationInput | BudgetRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BudgetRanges.
     */
    cursor?: BudgetRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetRanges.
     */
    skip?: number
    distinct?: BudgetRangeScalarFieldEnum | BudgetRangeScalarFieldEnum[]
  }

  /**
   * BudgetRange create
   */
  export type BudgetRangeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRange
     */
    select?: BudgetRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRange
     */
    omit?: BudgetRangeOmit<ExtArgs> | null
    /**
     * The data needed to create a BudgetRange.
     */
    data: XOR<BudgetRangeCreateInput, BudgetRangeUncheckedCreateInput>
  }

  /**
   * BudgetRange createMany
   */
  export type BudgetRangeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BudgetRanges.
     */
    data: BudgetRangeCreateManyInput | BudgetRangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BudgetRange createManyAndReturn
   */
  export type BudgetRangeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRange
     */
    select?: BudgetRangeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRange
     */
    omit?: BudgetRangeOmit<ExtArgs> | null
    /**
     * The data used to create many BudgetRanges.
     */
    data: BudgetRangeCreateManyInput | BudgetRangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BudgetRange update
   */
  export type BudgetRangeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRange
     */
    select?: BudgetRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRange
     */
    omit?: BudgetRangeOmit<ExtArgs> | null
    /**
     * The data needed to update a BudgetRange.
     */
    data: XOR<BudgetRangeUpdateInput, BudgetRangeUncheckedUpdateInput>
    /**
     * Choose, which BudgetRange to update.
     */
    where: BudgetRangeWhereUniqueInput
  }

  /**
   * BudgetRange updateMany
   */
  export type BudgetRangeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BudgetRanges.
     */
    data: XOR<BudgetRangeUpdateManyMutationInput, BudgetRangeUncheckedUpdateManyInput>
    /**
     * Filter which BudgetRanges to update
     */
    where?: BudgetRangeWhereInput
    /**
     * Limit how many BudgetRanges to update.
     */
    limit?: number
  }

  /**
   * BudgetRange updateManyAndReturn
   */
  export type BudgetRangeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRange
     */
    select?: BudgetRangeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRange
     */
    omit?: BudgetRangeOmit<ExtArgs> | null
    /**
     * The data used to update BudgetRanges.
     */
    data: XOR<BudgetRangeUpdateManyMutationInput, BudgetRangeUncheckedUpdateManyInput>
    /**
     * Filter which BudgetRanges to update
     */
    where?: BudgetRangeWhereInput
    /**
     * Limit how many BudgetRanges to update.
     */
    limit?: number
  }

  /**
   * BudgetRange upsert
   */
  export type BudgetRangeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRange
     */
    select?: BudgetRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRange
     */
    omit?: BudgetRangeOmit<ExtArgs> | null
    /**
     * The filter to search for the BudgetRange to update in case it exists.
     */
    where: BudgetRangeWhereUniqueInput
    /**
     * In case the BudgetRange found by the `where` argument doesn't exist, create a new BudgetRange with this data.
     */
    create: XOR<BudgetRangeCreateInput, BudgetRangeUncheckedCreateInput>
    /**
     * In case the BudgetRange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetRangeUpdateInput, BudgetRangeUncheckedUpdateInput>
  }

  /**
   * BudgetRange delete
   */
  export type BudgetRangeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRange
     */
    select?: BudgetRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRange
     */
    omit?: BudgetRangeOmit<ExtArgs> | null
    /**
     * Filter which BudgetRange to delete.
     */
    where: BudgetRangeWhereUniqueInput
  }

  /**
   * BudgetRange deleteMany
   */
  export type BudgetRangeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetRanges to delete
     */
    where?: BudgetRangeWhereInput
    /**
     * Limit how many BudgetRanges to delete.
     */
    limit?: number
  }

  /**
   * BudgetRange without action
   */
  export type BudgetRangeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetRange
     */
    select?: BudgetRangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetRange
     */
    omit?: BudgetRangeOmit<ExtArgs> | null
  }


  /**
   * Model TimelineOption
   */

  export type AggregateTimelineOption = {
    _count: TimelineOptionCountAggregateOutputType | null
    _avg: TimelineOptionAvgAggregateOutputType | null
    _sum: TimelineOptionSumAggregateOutputType | null
    _min: TimelineOptionMinAggregateOutputType | null
    _max: TimelineOptionMaxAggregateOutputType | null
  }

  export type TimelineOptionAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type TimelineOptionSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type TimelineOptionMinAggregateOutputType = {
    id: string | null
    value: string | null
    label: string | null
    description: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type TimelineOptionMaxAggregateOutputType = {
    id: string | null
    value: string | null
    label: string | null
    description: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type TimelineOptionCountAggregateOutputType = {
    id: number
    value: number
    label: number
    description: number
    displayOrder: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type TimelineOptionAvgAggregateInputType = {
    displayOrder?: true
  }

  export type TimelineOptionSumAggregateInputType = {
    displayOrder?: true
  }

  export type TimelineOptionMinAggregateInputType = {
    id?: true
    value?: true
    label?: true
    description?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type TimelineOptionMaxAggregateInputType = {
    id?: true
    value?: true
    label?: true
    description?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type TimelineOptionCountAggregateInputType = {
    id?: true
    value?: true
    label?: true
    description?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type TimelineOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimelineOption to aggregate.
     */
    where?: TimelineOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineOptions to fetch.
     */
    orderBy?: TimelineOptionOrderByWithRelationInput | TimelineOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimelineOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimelineOptions
    **/
    _count?: true | TimelineOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimelineOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimelineOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimelineOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimelineOptionMaxAggregateInputType
  }

  export type GetTimelineOptionAggregateType<T extends TimelineOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateTimelineOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimelineOption[P]>
      : GetScalarType<T[P], AggregateTimelineOption[P]>
  }




  export type TimelineOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimelineOptionWhereInput
    orderBy?: TimelineOptionOrderByWithAggregationInput | TimelineOptionOrderByWithAggregationInput[]
    by: TimelineOptionScalarFieldEnum[] | TimelineOptionScalarFieldEnum
    having?: TimelineOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimelineOptionCountAggregateInputType | true
    _avg?: TimelineOptionAvgAggregateInputType
    _sum?: TimelineOptionSumAggregateInputType
    _min?: TimelineOptionMinAggregateInputType
    _max?: TimelineOptionMaxAggregateInputType
  }

  export type TimelineOptionGroupByOutputType = {
    id: string
    value: string
    label: string
    description: string | null
    displayOrder: number | null
    isActive: boolean
    createdAt: Date
    _count: TimelineOptionCountAggregateOutputType | null
    _avg: TimelineOptionAvgAggregateOutputType | null
    _sum: TimelineOptionSumAggregateOutputType | null
    _min: TimelineOptionMinAggregateOutputType | null
    _max: TimelineOptionMaxAggregateOutputType | null
  }

  type GetTimelineOptionGroupByPayload<T extends TimelineOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimelineOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimelineOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimelineOptionGroupByOutputType[P]>
            : GetScalarType<T[P], TimelineOptionGroupByOutputType[P]>
        }
      >
    >


  export type TimelineOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    label?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["timelineOption"]>

  export type TimelineOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    label?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["timelineOption"]>

  export type TimelineOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    label?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["timelineOption"]>

  export type TimelineOptionSelectScalar = {
    id?: boolean
    value?: boolean
    label?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type TimelineOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "label" | "description" | "displayOrder" | "isActive" | "createdAt", ExtArgs["result"]["timelineOption"]>

  export type $TimelineOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimelineOption"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: string
      label: string
      description: string | null
      displayOrder: number | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["timelineOption"]>
    composites: {}
  }

  type TimelineOptionGetPayload<S extends boolean | null | undefined | TimelineOptionDefaultArgs> = $Result.GetResult<Prisma.$TimelineOptionPayload, S>

  type TimelineOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimelineOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimelineOptionCountAggregateInputType | true
    }

  export interface TimelineOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimelineOption'], meta: { name: 'TimelineOption' } }
    /**
     * Find zero or one TimelineOption that matches the filter.
     * @param {TimelineOptionFindUniqueArgs} args - Arguments to find a TimelineOption
     * @example
     * // Get one TimelineOption
     * const timelineOption = await prisma.timelineOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimelineOptionFindUniqueArgs>(args: SelectSubset<T, TimelineOptionFindUniqueArgs<ExtArgs>>): Prisma__TimelineOptionClient<$Result.GetResult<Prisma.$TimelineOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimelineOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimelineOptionFindUniqueOrThrowArgs} args - Arguments to find a TimelineOption
     * @example
     * // Get one TimelineOption
     * const timelineOption = await prisma.timelineOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimelineOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, TimelineOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimelineOptionClient<$Result.GetResult<Prisma.$TimelineOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimelineOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineOptionFindFirstArgs} args - Arguments to find a TimelineOption
     * @example
     * // Get one TimelineOption
     * const timelineOption = await prisma.timelineOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimelineOptionFindFirstArgs>(args?: SelectSubset<T, TimelineOptionFindFirstArgs<ExtArgs>>): Prisma__TimelineOptionClient<$Result.GetResult<Prisma.$TimelineOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimelineOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineOptionFindFirstOrThrowArgs} args - Arguments to find a TimelineOption
     * @example
     * // Get one TimelineOption
     * const timelineOption = await prisma.timelineOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimelineOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, TimelineOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimelineOptionClient<$Result.GetResult<Prisma.$TimelineOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimelineOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimelineOptions
     * const timelineOptions = await prisma.timelineOption.findMany()
     * 
     * // Get first 10 TimelineOptions
     * const timelineOptions = await prisma.timelineOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timelineOptionWithIdOnly = await prisma.timelineOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimelineOptionFindManyArgs>(args?: SelectSubset<T, TimelineOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelineOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimelineOption.
     * @param {TimelineOptionCreateArgs} args - Arguments to create a TimelineOption.
     * @example
     * // Create one TimelineOption
     * const TimelineOption = await prisma.timelineOption.create({
     *   data: {
     *     // ... data to create a TimelineOption
     *   }
     * })
     * 
     */
    create<T extends TimelineOptionCreateArgs>(args: SelectSubset<T, TimelineOptionCreateArgs<ExtArgs>>): Prisma__TimelineOptionClient<$Result.GetResult<Prisma.$TimelineOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimelineOptions.
     * @param {TimelineOptionCreateManyArgs} args - Arguments to create many TimelineOptions.
     * @example
     * // Create many TimelineOptions
     * const timelineOption = await prisma.timelineOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimelineOptionCreateManyArgs>(args?: SelectSubset<T, TimelineOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimelineOptions and returns the data saved in the database.
     * @param {TimelineOptionCreateManyAndReturnArgs} args - Arguments to create many TimelineOptions.
     * @example
     * // Create many TimelineOptions
     * const timelineOption = await prisma.timelineOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimelineOptions and only return the `id`
     * const timelineOptionWithIdOnly = await prisma.timelineOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimelineOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, TimelineOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelineOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TimelineOption.
     * @param {TimelineOptionDeleteArgs} args - Arguments to delete one TimelineOption.
     * @example
     * // Delete one TimelineOption
     * const TimelineOption = await prisma.timelineOption.delete({
     *   where: {
     *     // ... filter to delete one TimelineOption
     *   }
     * })
     * 
     */
    delete<T extends TimelineOptionDeleteArgs>(args: SelectSubset<T, TimelineOptionDeleteArgs<ExtArgs>>): Prisma__TimelineOptionClient<$Result.GetResult<Prisma.$TimelineOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimelineOption.
     * @param {TimelineOptionUpdateArgs} args - Arguments to update one TimelineOption.
     * @example
     * // Update one TimelineOption
     * const timelineOption = await prisma.timelineOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimelineOptionUpdateArgs>(args: SelectSubset<T, TimelineOptionUpdateArgs<ExtArgs>>): Prisma__TimelineOptionClient<$Result.GetResult<Prisma.$TimelineOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimelineOptions.
     * @param {TimelineOptionDeleteManyArgs} args - Arguments to filter TimelineOptions to delete.
     * @example
     * // Delete a few TimelineOptions
     * const { count } = await prisma.timelineOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimelineOptionDeleteManyArgs>(args?: SelectSubset<T, TimelineOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimelineOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimelineOptions
     * const timelineOption = await prisma.timelineOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimelineOptionUpdateManyArgs>(args: SelectSubset<T, TimelineOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimelineOptions and returns the data updated in the database.
     * @param {TimelineOptionUpdateManyAndReturnArgs} args - Arguments to update many TimelineOptions.
     * @example
     * // Update many TimelineOptions
     * const timelineOption = await prisma.timelineOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TimelineOptions and only return the `id`
     * const timelineOptionWithIdOnly = await prisma.timelineOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimelineOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, TimelineOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelineOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TimelineOption.
     * @param {TimelineOptionUpsertArgs} args - Arguments to update or create a TimelineOption.
     * @example
     * // Update or create a TimelineOption
     * const timelineOption = await prisma.timelineOption.upsert({
     *   create: {
     *     // ... data to create a TimelineOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimelineOption we want to update
     *   }
     * })
     */
    upsert<T extends TimelineOptionUpsertArgs>(args: SelectSubset<T, TimelineOptionUpsertArgs<ExtArgs>>): Prisma__TimelineOptionClient<$Result.GetResult<Prisma.$TimelineOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimelineOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineOptionCountArgs} args - Arguments to filter TimelineOptions to count.
     * @example
     * // Count the number of TimelineOptions
     * const count = await prisma.timelineOption.count({
     *   where: {
     *     // ... the filter for the TimelineOptions we want to count
     *   }
     * })
    **/
    count<T extends TimelineOptionCountArgs>(
      args?: Subset<T, TimelineOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimelineOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimelineOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimelineOptionAggregateArgs>(args: Subset<T, TimelineOptionAggregateArgs>): Prisma.PrismaPromise<GetTimelineOptionAggregateType<T>>

    /**
     * Group by TimelineOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimelineOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimelineOptionGroupByArgs['orderBy'] }
        : { orderBy?: TimelineOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimelineOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimelineOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimelineOption model
   */
  readonly fields: TimelineOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimelineOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimelineOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimelineOption model
   */
  interface TimelineOptionFieldRefs {
    readonly id: FieldRef<"TimelineOption", 'String'>
    readonly value: FieldRef<"TimelineOption", 'String'>
    readonly label: FieldRef<"TimelineOption", 'String'>
    readonly description: FieldRef<"TimelineOption", 'String'>
    readonly displayOrder: FieldRef<"TimelineOption", 'Int'>
    readonly isActive: FieldRef<"TimelineOption", 'Boolean'>
    readonly createdAt: FieldRef<"TimelineOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TimelineOption findUnique
   */
  export type TimelineOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineOption
     */
    select?: TimelineOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineOption
     */
    omit?: TimelineOptionOmit<ExtArgs> | null
    /**
     * Filter, which TimelineOption to fetch.
     */
    where: TimelineOptionWhereUniqueInput
  }

  /**
   * TimelineOption findUniqueOrThrow
   */
  export type TimelineOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineOption
     */
    select?: TimelineOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineOption
     */
    omit?: TimelineOptionOmit<ExtArgs> | null
    /**
     * Filter, which TimelineOption to fetch.
     */
    where: TimelineOptionWhereUniqueInput
  }

  /**
   * TimelineOption findFirst
   */
  export type TimelineOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineOption
     */
    select?: TimelineOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineOption
     */
    omit?: TimelineOptionOmit<ExtArgs> | null
    /**
     * Filter, which TimelineOption to fetch.
     */
    where?: TimelineOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineOptions to fetch.
     */
    orderBy?: TimelineOptionOrderByWithRelationInput | TimelineOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimelineOptions.
     */
    cursor?: TimelineOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimelineOptions.
     */
    distinct?: TimelineOptionScalarFieldEnum | TimelineOptionScalarFieldEnum[]
  }

  /**
   * TimelineOption findFirstOrThrow
   */
  export type TimelineOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineOption
     */
    select?: TimelineOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineOption
     */
    omit?: TimelineOptionOmit<ExtArgs> | null
    /**
     * Filter, which TimelineOption to fetch.
     */
    where?: TimelineOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineOptions to fetch.
     */
    orderBy?: TimelineOptionOrderByWithRelationInput | TimelineOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimelineOptions.
     */
    cursor?: TimelineOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimelineOptions.
     */
    distinct?: TimelineOptionScalarFieldEnum | TimelineOptionScalarFieldEnum[]
  }

  /**
   * TimelineOption findMany
   */
  export type TimelineOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineOption
     */
    select?: TimelineOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineOption
     */
    omit?: TimelineOptionOmit<ExtArgs> | null
    /**
     * Filter, which TimelineOptions to fetch.
     */
    where?: TimelineOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineOptions to fetch.
     */
    orderBy?: TimelineOptionOrderByWithRelationInput | TimelineOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimelineOptions.
     */
    cursor?: TimelineOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineOptions.
     */
    skip?: number
    distinct?: TimelineOptionScalarFieldEnum | TimelineOptionScalarFieldEnum[]
  }

  /**
   * TimelineOption create
   */
  export type TimelineOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineOption
     */
    select?: TimelineOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineOption
     */
    omit?: TimelineOptionOmit<ExtArgs> | null
    /**
     * The data needed to create a TimelineOption.
     */
    data: XOR<TimelineOptionCreateInput, TimelineOptionUncheckedCreateInput>
  }

  /**
   * TimelineOption createMany
   */
  export type TimelineOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimelineOptions.
     */
    data: TimelineOptionCreateManyInput | TimelineOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimelineOption createManyAndReturn
   */
  export type TimelineOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineOption
     */
    select?: TimelineOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineOption
     */
    omit?: TimelineOptionOmit<ExtArgs> | null
    /**
     * The data used to create many TimelineOptions.
     */
    data: TimelineOptionCreateManyInput | TimelineOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimelineOption update
   */
  export type TimelineOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineOption
     */
    select?: TimelineOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineOption
     */
    omit?: TimelineOptionOmit<ExtArgs> | null
    /**
     * The data needed to update a TimelineOption.
     */
    data: XOR<TimelineOptionUpdateInput, TimelineOptionUncheckedUpdateInput>
    /**
     * Choose, which TimelineOption to update.
     */
    where: TimelineOptionWhereUniqueInput
  }

  /**
   * TimelineOption updateMany
   */
  export type TimelineOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimelineOptions.
     */
    data: XOR<TimelineOptionUpdateManyMutationInput, TimelineOptionUncheckedUpdateManyInput>
    /**
     * Filter which TimelineOptions to update
     */
    where?: TimelineOptionWhereInput
    /**
     * Limit how many TimelineOptions to update.
     */
    limit?: number
  }

  /**
   * TimelineOption updateManyAndReturn
   */
  export type TimelineOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineOption
     */
    select?: TimelineOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineOption
     */
    omit?: TimelineOptionOmit<ExtArgs> | null
    /**
     * The data used to update TimelineOptions.
     */
    data: XOR<TimelineOptionUpdateManyMutationInput, TimelineOptionUncheckedUpdateManyInput>
    /**
     * Filter which TimelineOptions to update
     */
    where?: TimelineOptionWhereInput
    /**
     * Limit how many TimelineOptions to update.
     */
    limit?: number
  }

  /**
   * TimelineOption upsert
   */
  export type TimelineOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineOption
     */
    select?: TimelineOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineOption
     */
    omit?: TimelineOptionOmit<ExtArgs> | null
    /**
     * The filter to search for the TimelineOption to update in case it exists.
     */
    where: TimelineOptionWhereUniqueInput
    /**
     * In case the TimelineOption found by the `where` argument doesn't exist, create a new TimelineOption with this data.
     */
    create: XOR<TimelineOptionCreateInput, TimelineOptionUncheckedCreateInput>
    /**
     * In case the TimelineOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimelineOptionUpdateInput, TimelineOptionUncheckedUpdateInput>
  }

  /**
   * TimelineOption delete
   */
  export type TimelineOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineOption
     */
    select?: TimelineOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineOption
     */
    omit?: TimelineOptionOmit<ExtArgs> | null
    /**
     * Filter which TimelineOption to delete.
     */
    where: TimelineOptionWhereUniqueInput
  }

  /**
   * TimelineOption deleteMany
   */
  export type TimelineOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimelineOptions to delete
     */
    where?: TimelineOptionWhereInput
    /**
     * Limit how many TimelineOptions to delete.
     */
    limit?: number
  }

  /**
   * TimelineOption without action
   */
  export type TimelineOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineOption
     */
    select?: TimelineOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineOption
     */
    omit?: TimelineOptionOmit<ExtArgs> | null
  }


  /**
   * Model PackageOption
   */

  export type AggregatePackageOption = {
    _count: PackageOptionCountAggregateOutputType | null
    _avg: PackageOptionAvgAggregateOutputType | null
    _sum: PackageOptionSumAggregateOutputType | null
    _min: PackageOptionMinAggregateOutputType | null
    _max: PackageOptionMaxAggregateOutputType | null
  }

  export type PackageOptionAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type PackageOptionSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type PackageOptionMinAggregateOutputType = {
    id: string | null
    value: string | null
    label: string | null
    description: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type PackageOptionMaxAggregateOutputType = {
    id: string | null
    value: string | null
    label: string | null
    description: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type PackageOptionCountAggregateOutputType = {
    id: number
    value: number
    label: number
    description: number
    displayOrder: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type PackageOptionAvgAggregateInputType = {
    displayOrder?: true
  }

  export type PackageOptionSumAggregateInputType = {
    displayOrder?: true
  }

  export type PackageOptionMinAggregateInputType = {
    id?: true
    value?: true
    label?: true
    description?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type PackageOptionMaxAggregateInputType = {
    id?: true
    value?: true
    label?: true
    description?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type PackageOptionCountAggregateInputType = {
    id?: true
    value?: true
    label?: true
    description?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type PackageOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackageOption to aggregate.
     */
    where?: PackageOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageOptions to fetch.
     */
    orderBy?: PackageOptionOrderByWithRelationInput | PackageOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackageOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PackageOptions
    **/
    _count?: true | PackageOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackageOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackageOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackageOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackageOptionMaxAggregateInputType
  }

  export type GetPackageOptionAggregateType<T extends PackageOptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePackageOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackageOption[P]>
      : GetScalarType<T[P], AggregatePackageOption[P]>
  }




  export type PackageOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageOptionWhereInput
    orderBy?: PackageOptionOrderByWithAggregationInput | PackageOptionOrderByWithAggregationInput[]
    by: PackageOptionScalarFieldEnum[] | PackageOptionScalarFieldEnum
    having?: PackageOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackageOptionCountAggregateInputType | true
    _avg?: PackageOptionAvgAggregateInputType
    _sum?: PackageOptionSumAggregateInputType
    _min?: PackageOptionMinAggregateInputType
    _max?: PackageOptionMaxAggregateInputType
  }

  export type PackageOptionGroupByOutputType = {
    id: string
    value: string
    label: string
    description: string | null
    displayOrder: number | null
    isActive: boolean
    createdAt: Date
    _count: PackageOptionCountAggregateOutputType | null
    _avg: PackageOptionAvgAggregateOutputType | null
    _sum: PackageOptionSumAggregateOutputType | null
    _min: PackageOptionMinAggregateOutputType | null
    _max: PackageOptionMaxAggregateOutputType | null
  }

  type GetPackageOptionGroupByPayload<T extends PackageOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackageOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackageOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackageOptionGroupByOutputType[P]>
            : GetScalarType<T[P], PackageOptionGroupByOutputType[P]>
        }
      >
    >


  export type PackageOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    label?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["packageOption"]>

  export type PackageOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    label?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["packageOption"]>

  export type PackageOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    label?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["packageOption"]>

  export type PackageOptionSelectScalar = {
    id?: boolean
    value?: boolean
    label?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type PackageOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "label" | "description" | "displayOrder" | "isActive" | "createdAt", ExtArgs["result"]["packageOption"]>

  export type $PackageOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PackageOption"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: string
      label: string
      description: string | null
      displayOrder: number | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["packageOption"]>
    composites: {}
  }

  type PackageOptionGetPayload<S extends boolean | null | undefined | PackageOptionDefaultArgs> = $Result.GetResult<Prisma.$PackageOptionPayload, S>

  type PackageOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PackageOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PackageOptionCountAggregateInputType | true
    }

  export interface PackageOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PackageOption'], meta: { name: 'PackageOption' } }
    /**
     * Find zero or one PackageOption that matches the filter.
     * @param {PackageOptionFindUniqueArgs} args - Arguments to find a PackageOption
     * @example
     * // Get one PackageOption
     * const packageOption = await prisma.packageOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackageOptionFindUniqueArgs>(args: SelectSubset<T, PackageOptionFindUniqueArgs<ExtArgs>>): Prisma__PackageOptionClient<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PackageOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PackageOptionFindUniqueOrThrowArgs} args - Arguments to find a PackageOption
     * @example
     * // Get one PackageOption
     * const packageOption = await prisma.packageOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackageOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PackageOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackageOptionClient<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PackageOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageOptionFindFirstArgs} args - Arguments to find a PackageOption
     * @example
     * // Get one PackageOption
     * const packageOption = await prisma.packageOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackageOptionFindFirstArgs>(args?: SelectSubset<T, PackageOptionFindFirstArgs<ExtArgs>>): Prisma__PackageOptionClient<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PackageOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageOptionFindFirstOrThrowArgs} args - Arguments to find a PackageOption
     * @example
     * // Get one PackageOption
     * const packageOption = await prisma.packageOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackageOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PackageOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackageOptionClient<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PackageOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PackageOptions
     * const packageOptions = await prisma.packageOption.findMany()
     * 
     * // Get first 10 PackageOptions
     * const packageOptions = await prisma.packageOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packageOptionWithIdOnly = await prisma.packageOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackageOptionFindManyArgs>(args?: SelectSubset<T, PackageOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PackageOption.
     * @param {PackageOptionCreateArgs} args - Arguments to create a PackageOption.
     * @example
     * // Create one PackageOption
     * const PackageOption = await prisma.packageOption.create({
     *   data: {
     *     // ... data to create a PackageOption
     *   }
     * })
     * 
     */
    create<T extends PackageOptionCreateArgs>(args: SelectSubset<T, PackageOptionCreateArgs<ExtArgs>>): Prisma__PackageOptionClient<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PackageOptions.
     * @param {PackageOptionCreateManyArgs} args - Arguments to create many PackageOptions.
     * @example
     * // Create many PackageOptions
     * const packageOption = await prisma.packageOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackageOptionCreateManyArgs>(args?: SelectSubset<T, PackageOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PackageOptions and returns the data saved in the database.
     * @param {PackageOptionCreateManyAndReturnArgs} args - Arguments to create many PackageOptions.
     * @example
     * // Create many PackageOptions
     * const packageOption = await prisma.packageOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PackageOptions and only return the `id`
     * const packageOptionWithIdOnly = await prisma.packageOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PackageOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PackageOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PackageOption.
     * @param {PackageOptionDeleteArgs} args - Arguments to delete one PackageOption.
     * @example
     * // Delete one PackageOption
     * const PackageOption = await prisma.packageOption.delete({
     *   where: {
     *     // ... filter to delete one PackageOption
     *   }
     * })
     * 
     */
    delete<T extends PackageOptionDeleteArgs>(args: SelectSubset<T, PackageOptionDeleteArgs<ExtArgs>>): Prisma__PackageOptionClient<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PackageOption.
     * @param {PackageOptionUpdateArgs} args - Arguments to update one PackageOption.
     * @example
     * // Update one PackageOption
     * const packageOption = await prisma.packageOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackageOptionUpdateArgs>(args: SelectSubset<T, PackageOptionUpdateArgs<ExtArgs>>): Prisma__PackageOptionClient<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PackageOptions.
     * @param {PackageOptionDeleteManyArgs} args - Arguments to filter PackageOptions to delete.
     * @example
     * // Delete a few PackageOptions
     * const { count } = await prisma.packageOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackageOptionDeleteManyArgs>(args?: SelectSubset<T, PackageOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackageOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PackageOptions
     * const packageOption = await prisma.packageOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackageOptionUpdateManyArgs>(args: SelectSubset<T, PackageOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackageOptions and returns the data updated in the database.
     * @param {PackageOptionUpdateManyAndReturnArgs} args - Arguments to update many PackageOptions.
     * @example
     * // Update many PackageOptions
     * const packageOption = await prisma.packageOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PackageOptions and only return the `id`
     * const packageOptionWithIdOnly = await prisma.packageOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PackageOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PackageOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PackageOption.
     * @param {PackageOptionUpsertArgs} args - Arguments to update or create a PackageOption.
     * @example
     * // Update or create a PackageOption
     * const packageOption = await prisma.packageOption.upsert({
     *   create: {
     *     // ... data to create a PackageOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PackageOption we want to update
     *   }
     * })
     */
    upsert<T extends PackageOptionUpsertArgs>(args: SelectSubset<T, PackageOptionUpsertArgs<ExtArgs>>): Prisma__PackageOptionClient<$Result.GetResult<Prisma.$PackageOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PackageOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageOptionCountArgs} args - Arguments to filter PackageOptions to count.
     * @example
     * // Count the number of PackageOptions
     * const count = await prisma.packageOption.count({
     *   where: {
     *     // ... the filter for the PackageOptions we want to count
     *   }
     * })
    **/
    count<T extends PackageOptionCountArgs>(
      args?: Subset<T, PackageOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackageOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PackageOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackageOptionAggregateArgs>(args: Subset<T, PackageOptionAggregateArgs>): Prisma.PrismaPromise<GetPackageOptionAggregateType<T>>

    /**
     * Group by PackageOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackageOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackageOptionGroupByArgs['orderBy'] }
        : { orderBy?: PackageOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackageOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackageOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PackageOption model
   */
  readonly fields: PackageOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PackageOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackageOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PackageOption model
   */
  interface PackageOptionFieldRefs {
    readonly id: FieldRef<"PackageOption", 'String'>
    readonly value: FieldRef<"PackageOption", 'String'>
    readonly label: FieldRef<"PackageOption", 'String'>
    readonly description: FieldRef<"PackageOption", 'String'>
    readonly displayOrder: FieldRef<"PackageOption", 'Int'>
    readonly isActive: FieldRef<"PackageOption", 'Boolean'>
    readonly createdAt: FieldRef<"PackageOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PackageOption findUnique
   */
  export type PackageOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * Filter, which PackageOption to fetch.
     */
    where: PackageOptionWhereUniqueInput
  }

  /**
   * PackageOption findUniqueOrThrow
   */
  export type PackageOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * Filter, which PackageOption to fetch.
     */
    where: PackageOptionWhereUniqueInput
  }

  /**
   * PackageOption findFirst
   */
  export type PackageOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * Filter, which PackageOption to fetch.
     */
    where?: PackageOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageOptions to fetch.
     */
    orderBy?: PackageOptionOrderByWithRelationInput | PackageOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackageOptions.
     */
    cursor?: PackageOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackageOptions.
     */
    distinct?: PackageOptionScalarFieldEnum | PackageOptionScalarFieldEnum[]
  }

  /**
   * PackageOption findFirstOrThrow
   */
  export type PackageOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * Filter, which PackageOption to fetch.
     */
    where?: PackageOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageOptions to fetch.
     */
    orderBy?: PackageOptionOrderByWithRelationInput | PackageOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackageOptions.
     */
    cursor?: PackageOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackageOptions.
     */
    distinct?: PackageOptionScalarFieldEnum | PackageOptionScalarFieldEnum[]
  }

  /**
   * PackageOption findMany
   */
  export type PackageOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * Filter, which PackageOptions to fetch.
     */
    where?: PackageOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageOptions to fetch.
     */
    orderBy?: PackageOptionOrderByWithRelationInput | PackageOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PackageOptions.
     */
    cursor?: PackageOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageOptions.
     */
    skip?: number
    distinct?: PackageOptionScalarFieldEnum | PackageOptionScalarFieldEnum[]
  }

  /**
   * PackageOption create
   */
  export type PackageOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * The data needed to create a PackageOption.
     */
    data: XOR<PackageOptionCreateInput, PackageOptionUncheckedCreateInput>
  }

  /**
   * PackageOption createMany
   */
  export type PackageOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PackageOptions.
     */
    data: PackageOptionCreateManyInput | PackageOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PackageOption createManyAndReturn
   */
  export type PackageOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * The data used to create many PackageOptions.
     */
    data: PackageOptionCreateManyInput | PackageOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PackageOption update
   */
  export type PackageOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * The data needed to update a PackageOption.
     */
    data: XOR<PackageOptionUpdateInput, PackageOptionUncheckedUpdateInput>
    /**
     * Choose, which PackageOption to update.
     */
    where: PackageOptionWhereUniqueInput
  }

  /**
   * PackageOption updateMany
   */
  export type PackageOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PackageOptions.
     */
    data: XOR<PackageOptionUpdateManyMutationInput, PackageOptionUncheckedUpdateManyInput>
    /**
     * Filter which PackageOptions to update
     */
    where?: PackageOptionWhereInput
    /**
     * Limit how many PackageOptions to update.
     */
    limit?: number
  }

  /**
   * PackageOption updateManyAndReturn
   */
  export type PackageOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * The data used to update PackageOptions.
     */
    data: XOR<PackageOptionUpdateManyMutationInput, PackageOptionUncheckedUpdateManyInput>
    /**
     * Filter which PackageOptions to update
     */
    where?: PackageOptionWhereInput
    /**
     * Limit how many PackageOptions to update.
     */
    limit?: number
  }

  /**
   * PackageOption upsert
   */
  export type PackageOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * The filter to search for the PackageOption to update in case it exists.
     */
    where: PackageOptionWhereUniqueInput
    /**
     * In case the PackageOption found by the `where` argument doesn't exist, create a new PackageOption with this data.
     */
    create: XOR<PackageOptionCreateInput, PackageOptionUncheckedCreateInput>
    /**
     * In case the PackageOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackageOptionUpdateInput, PackageOptionUncheckedUpdateInput>
  }

  /**
   * PackageOption delete
   */
  export type PackageOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
    /**
     * Filter which PackageOption to delete.
     */
    where: PackageOptionWhereUniqueInput
  }

  /**
   * PackageOption deleteMany
   */
  export type PackageOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackageOptions to delete
     */
    where?: PackageOptionWhereInput
    /**
     * Limit how many PackageOptions to delete.
     */
    limit?: number
  }

  /**
   * PackageOption without action
   */
  export type PackageOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageOption
     */
    select?: PackageOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageOption
     */
    omit?: PackageOptionOmit<ExtArgs> | null
  }


  /**
   * Model MigrationLog
   */

  export type AggregateMigrationLog = {
    _count: MigrationLogCountAggregateOutputType | null
    _min: MigrationLogMinAggregateOutputType | null
    _max: MigrationLogMaxAggregateOutputType | null
  }

  export type MigrationLogMinAggregateOutputType = {
    id: string | null
    migrationPhase: string | null
    entityType: string | null
    entityId: string | null
    operation: string | null
    status: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type MigrationLogMaxAggregateOutputType = {
    id: string | null
    migrationPhase: string | null
    entityType: string | null
    entityId: string | null
    operation: string | null
    status: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type MigrationLogCountAggregateOutputType = {
    id: number
    migrationPhase: number
    entityType: number
    entityId: number
    operation: number
    oldValues: number
    newValues: number
    validationResult: number
    status: number
    errorMessage: number
    createdAt: number
    _all: number
  }


  export type MigrationLogMinAggregateInputType = {
    id?: true
    migrationPhase?: true
    entityType?: true
    entityId?: true
    operation?: true
    status?: true
    errorMessage?: true
    createdAt?: true
  }

  export type MigrationLogMaxAggregateInputType = {
    id?: true
    migrationPhase?: true
    entityType?: true
    entityId?: true
    operation?: true
    status?: true
    errorMessage?: true
    createdAt?: true
  }

  export type MigrationLogCountAggregateInputType = {
    id?: true
    migrationPhase?: true
    entityType?: true
    entityId?: true
    operation?: true
    oldValues?: true
    newValues?: true
    validationResult?: true
    status?: true
    errorMessage?: true
    createdAt?: true
    _all?: true
  }

  export type MigrationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MigrationLog to aggregate.
     */
    where?: MigrationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MigrationLogs to fetch.
     */
    orderBy?: MigrationLogOrderByWithRelationInput | MigrationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MigrationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MigrationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MigrationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MigrationLogs
    **/
    _count?: true | MigrationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MigrationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MigrationLogMaxAggregateInputType
  }

  export type GetMigrationLogAggregateType<T extends MigrationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateMigrationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMigrationLog[P]>
      : GetScalarType<T[P], AggregateMigrationLog[P]>
  }




  export type MigrationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MigrationLogWhereInput
    orderBy?: MigrationLogOrderByWithAggregationInput | MigrationLogOrderByWithAggregationInput[]
    by: MigrationLogScalarFieldEnum[] | MigrationLogScalarFieldEnum
    having?: MigrationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MigrationLogCountAggregateInputType | true
    _min?: MigrationLogMinAggregateInputType
    _max?: MigrationLogMaxAggregateInputType
  }

  export type MigrationLogGroupByOutputType = {
    id: string
    migrationPhase: string
    entityType: string
    entityId: string | null
    operation: string
    oldValues: JsonValue | null
    newValues: JsonValue | null
    validationResult: JsonValue | null
    status: string
    errorMessage: string | null
    createdAt: Date
    _count: MigrationLogCountAggregateOutputType | null
    _min: MigrationLogMinAggregateOutputType | null
    _max: MigrationLogMaxAggregateOutputType | null
  }

  type GetMigrationLogGroupByPayload<T extends MigrationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MigrationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MigrationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MigrationLogGroupByOutputType[P]>
            : GetScalarType<T[P], MigrationLogGroupByOutputType[P]>
        }
      >
    >


  export type MigrationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    migrationPhase?: boolean
    entityType?: boolean
    entityId?: boolean
    operation?: boolean
    oldValues?: boolean
    newValues?: boolean
    validationResult?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["migrationLog"]>

  export type MigrationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    migrationPhase?: boolean
    entityType?: boolean
    entityId?: boolean
    operation?: boolean
    oldValues?: boolean
    newValues?: boolean
    validationResult?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["migrationLog"]>

  export type MigrationLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    migrationPhase?: boolean
    entityType?: boolean
    entityId?: boolean
    operation?: boolean
    oldValues?: boolean
    newValues?: boolean
    validationResult?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["migrationLog"]>

  export type MigrationLogSelectScalar = {
    id?: boolean
    migrationPhase?: boolean
    entityType?: boolean
    entityId?: boolean
    operation?: boolean
    oldValues?: boolean
    newValues?: boolean
    validationResult?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }

  export type MigrationLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "migrationPhase" | "entityType" | "entityId" | "operation" | "oldValues" | "newValues" | "validationResult" | "status" | "errorMessage" | "createdAt", ExtArgs["result"]["migrationLog"]>

  export type $MigrationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MigrationLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      migrationPhase: string
      entityType: string
      entityId: string | null
      operation: string
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      validationResult: Prisma.JsonValue | null
      status: string
      errorMessage: string | null
      createdAt: Date
    }, ExtArgs["result"]["migrationLog"]>
    composites: {}
  }

  type MigrationLogGetPayload<S extends boolean | null | undefined | MigrationLogDefaultArgs> = $Result.GetResult<Prisma.$MigrationLogPayload, S>

  type MigrationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MigrationLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MigrationLogCountAggregateInputType | true
    }

  export interface MigrationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MigrationLog'], meta: { name: 'MigrationLog' } }
    /**
     * Find zero or one MigrationLog that matches the filter.
     * @param {MigrationLogFindUniqueArgs} args - Arguments to find a MigrationLog
     * @example
     * // Get one MigrationLog
     * const migrationLog = await prisma.migrationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MigrationLogFindUniqueArgs>(args: SelectSubset<T, MigrationLogFindUniqueArgs<ExtArgs>>): Prisma__MigrationLogClient<$Result.GetResult<Prisma.$MigrationLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MigrationLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MigrationLogFindUniqueOrThrowArgs} args - Arguments to find a MigrationLog
     * @example
     * // Get one MigrationLog
     * const migrationLog = await prisma.migrationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MigrationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, MigrationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MigrationLogClient<$Result.GetResult<Prisma.$MigrationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MigrationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationLogFindFirstArgs} args - Arguments to find a MigrationLog
     * @example
     * // Get one MigrationLog
     * const migrationLog = await prisma.migrationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MigrationLogFindFirstArgs>(args?: SelectSubset<T, MigrationLogFindFirstArgs<ExtArgs>>): Prisma__MigrationLogClient<$Result.GetResult<Prisma.$MigrationLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MigrationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationLogFindFirstOrThrowArgs} args - Arguments to find a MigrationLog
     * @example
     * // Get one MigrationLog
     * const migrationLog = await prisma.migrationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MigrationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, MigrationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__MigrationLogClient<$Result.GetResult<Prisma.$MigrationLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MigrationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MigrationLogs
     * const migrationLogs = await prisma.migrationLog.findMany()
     * 
     * // Get first 10 MigrationLogs
     * const migrationLogs = await prisma.migrationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const migrationLogWithIdOnly = await prisma.migrationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MigrationLogFindManyArgs>(args?: SelectSubset<T, MigrationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MigrationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MigrationLog.
     * @param {MigrationLogCreateArgs} args - Arguments to create a MigrationLog.
     * @example
     * // Create one MigrationLog
     * const MigrationLog = await prisma.migrationLog.create({
     *   data: {
     *     // ... data to create a MigrationLog
     *   }
     * })
     * 
     */
    create<T extends MigrationLogCreateArgs>(args: SelectSubset<T, MigrationLogCreateArgs<ExtArgs>>): Prisma__MigrationLogClient<$Result.GetResult<Prisma.$MigrationLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MigrationLogs.
     * @param {MigrationLogCreateManyArgs} args - Arguments to create many MigrationLogs.
     * @example
     * // Create many MigrationLogs
     * const migrationLog = await prisma.migrationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MigrationLogCreateManyArgs>(args?: SelectSubset<T, MigrationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MigrationLogs and returns the data saved in the database.
     * @param {MigrationLogCreateManyAndReturnArgs} args - Arguments to create many MigrationLogs.
     * @example
     * // Create many MigrationLogs
     * const migrationLog = await prisma.migrationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MigrationLogs and only return the `id`
     * const migrationLogWithIdOnly = await prisma.migrationLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MigrationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, MigrationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MigrationLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MigrationLog.
     * @param {MigrationLogDeleteArgs} args - Arguments to delete one MigrationLog.
     * @example
     * // Delete one MigrationLog
     * const MigrationLog = await prisma.migrationLog.delete({
     *   where: {
     *     // ... filter to delete one MigrationLog
     *   }
     * })
     * 
     */
    delete<T extends MigrationLogDeleteArgs>(args: SelectSubset<T, MigrationLogDeleteArgs<ExtArgs>>): Prisma__MigrationLogClient<$Result.GetResult<Prisma.$MigrationLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MigrationLog.
     * @param {MigrationLogUpdateArgs} args - Arguments to update one MigrationLog.
     * @example
     * // Update one MigrationLog
     * const migrationLog = await prisma.migrationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MigrationLogUpdateArgs>(args: SelectSubset<T, MigrationLogUpdateArgs<ExtArgs>>): Prisma__MigrationLogClient<$Result.GetResult<Prisma.$MigrationLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MigrationLogs.
     * @param {MigrationLogDeleteManyArgs} args - Arguments to filter MigrationLogs to delete.
     * @example
     * // Delete a few MigrationLogs
     * const { count } = await prisma.migrationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MigrationLogDeleteManyArgs>(args?: SelectSubset<T, MigrationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MigrationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MigrationLogs
     * const migrationLog = await prisma.migrationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MigrationLogUpdateManyArgs>(args: SelectSubset<T, MigrationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MigrationLogs and returns the data updated in the database.
     * @param {MigrationLogUpdateManyAndReturnArgs} args - Arguments to update many MigrationLogs.
     * @example
     * // Update many MigrationLogs
     * const migrationLog = await prisma.migrationLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MigrationLogs and only return the `id`
     * const migrationLogWithIdOnly = await prisma.migrationLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MigrationLogUpdateManyAndReturnArgs>(args: SelectSubset<T, MigrationLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MigrationLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MigrationLog.
     * @param {MigrationLogUpsertArgs} args - Arguments to update or create a MigrationLog.
     * @example
     * // Update or create a MigrationLog
     * const migrationLog = await prisma.migrationLog.upsert({
     *   create: {
     *     // ... data to create a MigrationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MigrationLog we want to update
     *   }
     * })
     */
    upsert<T extends MigrationLogUpsertArgs>(args: SelectSubset<T, MigrationLogUpsertArgs<ExtArgs>>): Prisma__MigrationLogClient<$Result.GetResult<Prisma.$MigrationLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MigrationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationLogCountArgs} args - Arguments to filter MigrationLogs to count.
     * @example
     * // Count the number of MigrationLogs
     * const count = await prisma.migrationLog.count({
     *   where: {
     *     // ... the filter for the MigrationLogs we want to count
     *   }
     * })
    **/
    count<T extends MigrationLogCountArgs>(
      args?: Subset<T, MigrationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MigrationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MigrationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MigrationLogAggregateArgs>(args: Subset<T, MigrationLogAggregateArgs>): Prisma.PrismaPromise<GetMigrationLogAggregateType<T>>

    /**
     * Group by MigrationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MigrationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MigrationLogGroupByArgs['orderBy'] }
        : { orderBy?: MigrationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MigrationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMigrationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MigrationLog model
   */
  readonly fields: MigrationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MigrationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MigrationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MigrationLog model
   */
  interface MigrationLogFieldRefs {
    readonly id: FieldRef<"MigrationLog", 'String'>
    readonly migrationPhase: FieldRef<"MigrationLog", 'String'>
    readonly entityType: FieldRef<"MigrationLog", 'String'>
    readonly entityId: FieldRef<"MigrationLog", 'String'>
    readonly operation: FieldRef<"MigrationLog", 'String'>
    readonly oldValues: FieldRef<"MigrationLog", 'Json'>
    readonly newValues: FieldRef<"MigrationLog", 'Json'>
    readonly validationResult: FieldRef<"MigrationLog", 'Json'>
    readonly status: FieldRef<"MigrationLog", 'String'>
    readonly errorMessage: FieldRef<"MigrationLog", 'String'>
    readonly createdAt: FieldRef<"MigrationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MigrationLog findUnique
   */
  export type MigrationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MigrationLog
     */
    select?: MigrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MigrationLog
     */
    omit?: MigrationLogOmit<ExtArgs> | null
    /**
     * Filter, which MigrationLog to fetch.
     */
    where: MigrationLogWhereUniqueInput
  }

  /**
   * MigrationLog findUniqueOrThrow
   */
  export type MigrationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MigrationLog
     */
    select?: MigrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MigrationLog
     */
    omit?: MigrationLogOmit<ExtArgs> | null
    /**
     * Filter, which MigrationLog to fetch.
     */
    where: MigrationLogWhereUniqueInput
  }

  /**
   * MigrationLog findFirst
   */
  export type MigrationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MigrationLog
     */
    select?: MigrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MigrationLog
     */
    omit?: MigrationLogOmit<ExtArgs> | null
    /**
     * Filter, which MigrationLog to fetch.
     */
    where?: MigrationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MigrationLogs to fetch.
     */
    orderBy?: MigrationLogOrderByWithRelationInput | MigrationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MigrationLogs.
     */
    cursor?: MigrationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MigrationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MigrationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MigrationLogs.
     */
    distinct?: MigrationLogScalarFieldEnum | MigrationLogScalarFieldEnum[]
  }

  /**
   * MigrationLog findFirstOrThrow
   */
  export type MigrationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MigrationLog
     */
    select?: MigrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MigrationLog
     */
    omit?: MigrationLogOmit<ExtArgs> | null
    /**
     * Filter, which MigrationLog to fetch.
     */
    where?: MigrationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MigrationLogs to fetch.
     */
    orderBy?: MigrationLogOrderByWithRelationInput | MigrationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MigrationLogs.
     */
    cursor?: MigrationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MigrationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MigrationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MigrationLogs.
     */
    distinct?: MigrationLogScalarFieldEnum | MigrationLogScalarFieldEnum[]
  }

  /**
   * MigrationLog findMany
   */
  export type MigrationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MigrationLog
     */
    select?: MigrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MigrationLog
     */
    omit?: MigrationLogOmit<ExtArgs> | null
    /**
     * Filter, which MigrationLogs to fetch.
     */
    where?: MigrationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MigrationLogs to fetch.
     */
    orderBy?: MigrationLogOrderByWithRelationInput | MigrationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MigrationLogs.
     */
    cursor?: MigrationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MigrationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MigrationLogs.
     */
    skip?: number
    distinct?: MigrationLogScalarFieldEnum | MigrationLogScalarFieldEnum[]
  }

  /**
   * MigrationLog create
   */
  export type MigrationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MigrationLog
     */
    select?: MigrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MigrationLog
     */
    omit?: MigrationLogOmit<ExtArgs> | null
    /**
     * The data needed to create a MigrationLog.
     */
    data: XOR<MigrationLogCreateInput, MigrationLogUncheckedCreateInput>
  }

  /**
   * MigrationLog createMany
   */
  export type MigrationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MigrationLogs.
     */
    data: MigrationLogCreateManyInput | MigrationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MigrationLog createManyAndReturn
   */
  export type MigrationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MigrationLog
     */
    select?: MigrationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MigrationLog
     */
    omit?: MigrationLogOmit<ExtArgs> | null
    /**
     * The data used to create many MigrationLogs.
     */
    data: MigrationLogCreateManyInput | MigrationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MigrationLog update
   */
  export type MigrationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MigrationLog
     */
    select?: MigrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MigrationLog
     */
    omit?: MigrationLogOmit<ExtArgs> | null
    /**
     * The data needed to update a MigrationLog.
     */
    data: XOR<MigrationLogUpdateInput, MigrationLogUncheckedUpdateInput>
    /**
     * Choose, which MigrationLog to update.
     */
    where: MigrationLogWhereUniqueInput
  }

  /**
   * MigrationLog updateMany
   */
  export type MigrationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MigrationLogs.
     */
    data: XOR<MigrationLogUpdateManyMutationInput, MigrationLogUncheckedUpdateManyInput>
    /**
     * Filter which MigrationLogs to update
     */
    where?: MigrationLogWhereInput
    /**
     * Limit how many MigrationLogs to update.
     */
    limit?: number
  }

  /**
   * MigrationLog updateManyAndReturn
   */
  export type MigrationLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MigrationLog
     */
    select?: MigrationLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MigrationLog
     */
    omit?: MigrationLogOmit<ExtArgs> | null
    /**
     * The data used to update MigrationLogs.
     */
    data: XOR<MigrationLogUpdateManyMutationInput, MigrationLogUncheckedUpdateManyInput>
    /**
     * Filter which MigrationLogs to update
     */
    where?: MigrationLogWhereInput
    /**
     * Limit how many MigrationLogs to update.
     */
    limit?: number
  }

  /**
   * MigrationLog upsert
   */
  export type MigrationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MigrationLog
     */
    select?: MigrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MigrationLog
     */
    omit?: MigrationLogOmit<ExtArgs> | null
    /**
     * The filter to search for the MigrationLog to update in case it exists.
     */
    where: MigrationLogWhereUniqueInput
    /**
     * In case the MigrationLog found by the `where` argument doesn't exist, create a new MigrationLog with this data.
     */
    create: XOR<MigrationLogCreateInput, MigrationLogUncheckedCreateInput>
    /**
     * In case the MigrationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MigrationLogUpdateInput, MigrationLogUncheckedUpdateInput>
  }

  /**
   * MigrationLog delete
   */
  export type MigrationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MigrationLog
     */
    select?: MigrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MigrationLog
     */
    omit?: MigrationLogOmit<ExtArgs> | null
    /**
     * Filter which MigrationLog to delete.
     */
    where: MigrationLogWhereUniqueInput
  }

  /**
   * MigrationLog deleteMany
   */
  export type MigrationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MigrationLogs to delete
     */
    where?: MigrationLogWhereInput
    /**
     * Limit how many MigrationLogs to delete.
     */
    limit?: number
  }

  /**
   * MigrationLog without action
   */
  export type MigrationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MigrationLog
     */
    select?: MigrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MigrationLog
     */
    omit?: MigrationLogOmit<ExtArgs> | null
  }


  /**
   * Model SystemAudit
   */

  export type AggregateSystemAudit = {
    _count: SystemAuditCountAggregateOutputType | null
    _min: SystemAuditMinAggregateOutputType | null
    _max: SystemAuditMaxAggregateOutputType | null
  }

  export type SystemAuditMinAggregateOutputType = {
    id: string | null
    tableName: string | null
    recordId: string | null
    operation: string | null
    userId: string | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type SystemAuditMaxAggregateOutputType = {
    id: string | null
    tableName: string | null
    recordId: string | null
    operation: string | null
    userId: string | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type SystemAuditCountAggregateOutputType = {
    id: number
    tableName: number
    recordId: number
    operation: number
    oldValues: number
    newValues: number
    userId: number
    userAgent: number
    ipAddress: number
    createdAt: number
    _all: number
  }


  export type SystemAuditMinAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    operation?: true
    userId?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
  }

  export type SystemAuditMaxAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    operation?: true
    userId?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
  }

  export type SystemAuditCountAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    operation?: true
    oldValues?: true
    newValues?: true
    userId?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
    _all?: true
  }

  export type SystemAuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemAudit to aggregate.
     */
    where?: SystemAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAudits to fetch.
     */
    orderBy?: SystemAuditOrderByWithRelationInput | SystemAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemAudits
    **/
    _count?: true | SystemAuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemAuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemAuditMaxAggregateInputType
  }

  export type GetSystemAuditAggregateType<T extends SystemAuditAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemAudit[P]>
      : GetScalarType<T[P], AggregateSystemAudit[P]>
  }




  export type SystemAuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemAuditWhereInput
    orderBy?: SystemAuditOrderByWithAggregationInput | SystemAuditOrderByWithAggregationInput[]
    by: SystemAuditScalarFieldEnum[] | SystemAuditScalarFieldEnum
    having?: SystemAuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemAuditCountAggregateInputType | true
    _min?: SystemAuditMinAggregateInputType
    _max?: SystemAuditMaxAggregateInputType
  }

  export type SystemAuditGroupByOutputType = {
    id: string
    tableName: string
    recordId: string
    operation: string
    oldValues: JsonValue | null
    newValues: JsonValue | null
    userId: string | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date
    _count: SystemAuditCountAggregateOutputType | null
    _min: SystemAuditMinAggregateOutputType | null
    _max: SystemAuditMaxAggregateOutputType | null
  }

  type GetSystemAuditGroupByPayload<T extends SystemAuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemAuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemAuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemAuditGroupByOutputType[P]>
            : GetScalarType<T[P], SystemAuditGroupByOutputType[P]>
        }
      >
    >


  export type SystemAuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    operation?: boolean
    oldValues?: boolean
    newValues?: boolean
    userId?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemAudit"]>

  export type SystemAuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    operation?: boolean
    oldValues?: boolean
    newValues?: boolean
    userId?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemAudit"]>

  export type SystemAuditSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    operation?: boolean
    oldValues?: boolean
    newValues?: boolean
    userId?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemAudit"]>

  export type SystemAuditSelectScalar = {
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    operation?: boolean
    oldValues?: boolean
    newValues?: boolean
    userId?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }

  export type SystemAuditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableName" | "recordId" | "operation" | "oldValues" | "newValues" | "userId" | "userAgent" | "ipAddress" | "createdAt", ExtArgs["result"]["systemAudit"]>

  export type $SystemAuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemAudit"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tableName: string
      recordId: string
      operation: string
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      userId: string | null
      userAgent: string | null
      ipAddress: string | null
      createdAt: Date
    }, ExtArgs["result"]["systemAudit"]>
    composites: {}
  }

  type SystemAuditGetPayload<S extends boolean | null | undefined | SystemAuditDefaultArgs> = $Result.GetResult<Prisma.$SystemAuditPayload, S>

  type SystemAuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemAuditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemAuditCountAggregateInputType | true
    }

  export interface SystemAuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemAudit'], meta: { name: 'SystemAudit' } }
    /**
     * Find zero or one SystemAudit that matches the filter.
     * @param {SystemAuditFindUniqueArgs} args - Arguments to find a SystemAudit
     * @example
     * // Get one SystemAudit
     * const systemAudit = await prisma.systemAudit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemAuditFindUniqueArgs>(args: SelectSubset<T, SystemAuditFindUniqueArgs<ExtArgs>>): Prisma__SystemAuditClient<$Result.GetResult<Prisma.$SystemAuditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemAudit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemAuditFindUniqueOrThrowArgs} args - Arguments to find a SystemAudit
     * @example
     * // Get one SystemAudit
     * const systemAudit = await prisma.systemAudit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemAuditFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemAuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemAuditClient<$Result.GetResult<Prisma.$SystemAuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemAudit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAuditFindFirstArgs} args - Arguments to find a SystemAudit
     * @example
     * // Get one SystemAudit
     * const systemAudit = await prisma.systemAudit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemAuditFindFirstArgs>(args?: SelectSubset<T, SystemAuditFindFirstArgs<ExtArgs>>): Prisma__SystemAuditClient<$Result.GetResult<Prisma.$SystemAuditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemAudit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAuditFindFirstOrThrowArgs} args - Arguments to find a SystemAudit
     * @example
     * // Get one SystemAudit
     * const systemAudit = await prisma.systemAudit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemAuditFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemAuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemAuditClient<$Result.GetResult<Prisma.$SystemAuditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemAudits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemAudits
     * const systemAudits = await prisma.systemAudit.findMany()
     * 
     * // Get first 10 SystemAudits
     * const systemAudits = await prisma.systemAudit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemAuditWithIdOnly = await prisma.systemAudit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemAuditFindManyArgs>(args?: SelectSubset<T, SystemAuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemAudit.
     * @param {SystemAuditCreateArgs} args - Arguments to create a SystemAudit.
     * @example
     * // Create one SystemAudit
     * const SystemAudit = await prisma.systemAudit.create({
     *   data: {
     *     // ... data to create a SystemAudit
     *   }
     * })
     * 
     */
    create<T extends SystemAuditCreateArgs>(args: SelectSubset<T, SystemAuditCreateArgs<ExtArgs>>): Prisma__SystemAuditClient<$Result.GetResult<Prisma.$SystemAuditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemAudits.
     * @param {SystemAuditCreateManyArgs} args - Arguments to create many SystemAudits.
     * @example
     * // Create many SystemAudits
     * const systemAudit = await prisma.systemAudit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemAuditCreateManyArgs>(args?: SelectSubset<T, SystemAuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemAudits and returns the data saved in the database.
     * @param {SystemAuditCreateManyAndReturnArgs} args - Arguments to create many SystemAudits.
     * @example
     * // Create many SystemAudits
     * const systemAudit = await prisma.systemAudit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemAudits and only return the `id`
     * const systemAuditWithIdOnly = await prisma.systemAudit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemAuditCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemAuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemAuditPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemAudit.
     * @param {SystemAuditDeleteArgs} args - Arguments to delete one SystemAudit.
     * @example
     * // Delete one SystemAudit
     * const SystemAudit = await prisma.systemAudit.delete({
     *   where: {
     *     // ... filter to delete one SystemAudit
     *   }
     * })
     * 
     */
    delete<T extends SystemAuditDeleteArgs>(args: SelectSubset<T, SystemAuditDeleteArgs<ExtArgs>>): Prisma__SystemAuditClient<$Result.GetResult<Prisma.$SystemAuditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemAudit.
     * @param {SystemAuditUpdateArgs} args - Arguments to update one SystemAudit.
     * @example
     * // Update one SystemAudit
     * const systemAudit = await prisma.systemAudit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemAuditUpdateArgs>(args: SelectSubset<T, SystemAuditUpdateArgs<ExtArgs>>): Prisma__SystemAuditClient<$Result.GetResult<Prisma.$SystemAuditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemAudits.
     * @param {SystemAuditDeleteManyArgs} args - Arguments to filter SystemAudits to delete.
     * @example
     * // Delete a few SystemAudits
     * const { count } = await prisma.systemAudit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemAuditDeleteManyArgs>(args?: SelectSubset<T, SystemAuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemAudits
     * const systemAudit = await prisma.systemAudit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemAuditUpdateManyArgs>(args: SelectSubset<T, SystemAuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemAudits and returns the data updated in the database.
     * @param {SystemAuditUpdateManyAndReturnArgs} args - Arguments to update many SystemAudits.
     * @example
     * // Update many SystemAudits
     * const systemAudit = await prisma.systemAudit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemAudits and only return the `id`
     * const systemAuditWithIdOnly = await prisma.systemAudit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemAuditUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemAuditUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemAuditPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemAudit.
     * @param {SystemAuditUpsertArgs} args - Arguments to update or create a SystemAudit.
     * @example
     * // Update or create a SystemAudit
     * const systemAudit = await prisma.systemAudit.upsert({
     *   create: {
     *     // ... data to create a SystemAudit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemAudit we want to update
     *   }
     * })
     */
    upsert<T extends SystemAuditUpsertArgs>(args: SelectSubset<T, SystemAuditUpsertArgs<ExtArgs>>): Prisma__SystemAuditClient<$Result.GetResult<Prisma.$SystemAuditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAuditCountArgs} args - Arguments to filter SystemAudits to count.
     * @example
     * // Count the number of SystemAudits
     * const count = await prisma.systemAudit.count({
     *   where: {
     *     // ... the filter for the SystemAudits we want to count
     *   }
     * })
    **/
    count<T extends SystemAuditCountArgs>(
      args?: Subset<T, SystemAuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemAuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemAuditAggregateArgs>(args: Subset<T, SystemAuditAggregateArgs>): Prisma.PrismaPromise<GetSystemAuditAggregateType<T>>

    /**
     * Group by SystemAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemAuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemAuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemAuditGroupByArgs['orderBy'] }
        : { orderBy?: SystemAuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemAuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemAudit model
   */
  readonly fields: SystemAuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemAudit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemAuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemAudit model
   */
  interface SystemAuditFieldRefs {
    readonly id: FieldRef<"SystemAudit", 'String'>
    readonly tableName: FieldRef<"SystemAudit", 'String'>
    readonly recordId: FieldRef<"SystemAudit", 'String'>
    readonly operation: FieldRef<"SystemAudit", 'String'>
    readonly oldValues: FieldRef<"SystemAudit", 'Json'>
    readonly newValues: FieldRef<"SystemAudit", 'Json'>
    readonly userId: FieldRef<"SystemAudit", 'String'>
    readonly userAgent: FieldRef<"SystemAudit", 'String'>
    readonly ipAddress: FieldRef<"SystemAudit", 'String'>
    readonly createdAt: FieldRef<"SystemAudit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemAudit findUnique
   */
  export type SystemAuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAudit
     */
    select?: SystemAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAudit
     */
    omit?: SystemAuditOmit<ExtArgs> | null
    /**
     * Filter, which SystemAudit to fetch.
     */
    where: SystemAuditWhereUniqueInput
  }

  /**
   * SystemAudit findUniqueOrThrow
   */
  export type SystemAuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAudit
     */
    select?: SystemAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAudit
     */
    omit?: SystemAuditOmit<ExtArgs> | null
    /**
     * Filter, which SystemAudit to fetch.
     */
    where: SystemAuditWhereUniqueInput
  }

  /**
   * SystemAudit findFirst
   */
  export type SystemAuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAudit
     */
    select?: SystemAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAudit
     */
    omit?: SystemAuditOmit<ExtArgs> | null
    /**
     * Filter, which SystemAudit to fetch.
     */
    where?: SystemAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAudits to fetch.
     */
    orderBy?: SystemAuditOrderByWithRelationInput | SystemAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemAudits.
     */
    cursor?: SystemAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemAudits.
     */
    distinct?: SystemAuditScalarFieldEnum | SystemAuditScalarFieldEnum[]
  }

  /**
   * SystemAudit findFirstOrThrow
   */
  export type SystemAuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAudit
     */
    select?: SystemAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAudit
     */
    omit?: SystemAuditOmit<ExtArgs> | null
    /**
     * Filter, which SystemAudit to fetch.
     */
    where?: SystemAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAudits to fetch.
     */
    orderBy?: SystemAuditOrderByWithRelationInput | SystemAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemAudits.
     */
    cursor?: SystemAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemAudits.
     */
    distinct?: SystemAuditScalarFieldEnum | SystemAuditScalarFieldEnum[]
  }

  /**
   * SystemAudit findMany
   */
  export type SystemAuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAudit
     */
    select?: SystemAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAudit
     */
    omit?: SystemAuditOmit<ExtArgs> | null
    /**
     * Filter, which SystemAudits to fetch.
     */
    where?: SystemAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemAudits to fetch.
     */
    orderBy?: SystemAuditOrderByWithRelationInput | SystemAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemAudits.
     */
    cursor?: SystemAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemAudits.
     */
    skip?: number
    distinct?: SystemAuditScalarFieldEnum | SystemAuditScalarFieldEnum[]
  }

  /**
   * SystemAudit create
   */
  export type SystemAuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAudit
     */
    select?: SystemAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAudit
     */
    omit?: SystemAuditOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemAudit.
     */
    data: XOR<SystemAuditCreateInput, SystemAuditUncheckedCreateInput>
  }

  /**
   * SystemAudit createMany
   */
  export type SystemAuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemAudits.
     */
    data: SystemAuditCreateManyInput | SystemAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemAudit createManyAndReturn
   */
  export type SystemAuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAudit
     */
    select?: SystemAuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAudit
     */
    omit?: SystemAuditOmit<ExtArgs> | null
    /**
     * The data used to create many SystemAudits.
     */
    data: SystemAuditCreateManyInput | SystemAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemAudit update
   */
  export type SystemAuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAudit
     */
    select?: SystemAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAudit
     */
    omit?: SystemAuditOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemAudit.
     */
    data: XOR<SystemAuditUpdateInput, SystemAuditUncheckedUpdateInput>
    /**
     * Choose, which SystemAudit to update.
     */
    where: SystemAuditWhereUniqueInput
  }

  /**
   * SystemAudit updateMany
   */
  export type SystemAuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemAudits.
     */
    data: XOR<SystemAuditUpdateManyMutationInput, SystemAuditUncheckedUpdateManyInput>
    /**
     * Filter which SystemAudits to update
     */
    where?: SystemAuditWhereInput
    /**
     * Limit how many SystemAudits to update.
     */
    limit?: number
  }

  /**
   * SystemAudit updateManyAndReturn
   */
  export type SystemAuditUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAudit
     */
    select?: SystemAuditSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAudit
     */
    omit?: SystemAuditOmit<ExtArgs> | null
    /**
     * The data used to update SystemAudits.
     */
    data: XOR<SystemAuditUpdateManyMutationInput, SystemAuditUncheckedUpdateManyInput>
    /**
     * Filter which SystemAudits to update
     */
    where?: SystemAuditWhereInput
    /**
     * Limit how many SystemAudits to update.
     */
    limit?: number
  }

  /**
   * SystemAudit upsert
   */
  export type SystemAuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAudit
     */
    select?: SystemAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAudit
     */
    omit?: SystemAuditOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemAudit to update in case it exists.
     */
    where: SystemAuditWhereUniqueInput
    /**
     * In case the SystemAudit found by the `where` argument doesn't exist, create a new SystemAudit with this data.
     */
    create: XOR<SystemAuditCreateInput, SystemAuditUncheckedCreateInput>
    /**
     * In case the SystemAudit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemAuditUpdateInput, SystemAuditUncheckedUpdateInput>
  }

  /**
   * SystemAudit delete
   */
  export type SystemAuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAudit
     */
    select?: SystemAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAudit
     */
    omit?: SystemAuditOmit<ExtArgs> | null
    /**
     * Filter which SystemAudit to delete.
     */
    where: SystemAuditWhereUniqueInput
  }

  /**
   * SystemAudit deleteMany
   */
  export type SystemAuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemAudits to delete
     */
    where?: SystemAuditWhereInput
    /**
     * Limit how many SystemAudits to delete.
     */
    limit?: number
  }

  /**
   * SystemAudit without action
   */
  export type SystemAuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemAudit
     */
    select?: SystemAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemAudit
     */
    omit?: SystemAuditOmit<ExtArgs> | null
  }


  /**
   * Model FeatureFlag
   */

  export type AggregateFeatureFlag = {
    _count: FeatureFlagCountAggregateOutputType | null
    _avg: FeatureFlagAvgAggregateOutputType | null
    _sum: FeatureFlagSumAggregateOutputType | null
    _min: FeatureFlagMinAggregateOutputType | null
    _max: FeatureFlagMaxAggregateOutputType | null
  }

  export type FeatureFlagAvgAggregateOutputType = {
    rolloutPercentage: Decimal | null
  }

  export type FeatureFlagSumAggregateOutputType = {
    rolloutPercentage: Decimal | null
  }

  export type FeatureFlagMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isEnabled: boolean | null
    rolloutPercentage: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureFlagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isEnabled: boolean | null
    rolloutPercentage: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureFlagCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isEnabled: number
    rolloutPercentage: number
    conditions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeatureFlagAvgAggregateInputType = {
    rolloutPercentage?: true
  }

  export type FeatureFlagSumAggregateInputType = {
    rolloutPercentage?: true
  }

  export type FeatureFlagMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isEnabled?: true
    rolloutPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureFlagMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isEnabled?: true
    rolloutPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureFlagCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isEnabled?: true
    rolloutPercentage?: true
    conditions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeatureFlagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureFlag to aggregate.
     */
    where?: FeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagOrderByWithRelationInput | FeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeatureFlags
    **/
    _count?: true | FeatureFlagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatureFlagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatureFlagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureFlagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureFlagMaxAggregateInputType
  }

  export type GetFeatureFlagAggregateType<T extends FeatureFlagAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatureFlag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatureFlag[P]>
      : GetScalarType<T[P], AggregateFeatureFlag[P]>
  }




  export type FeatureFlagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureFlagWhereInput
    orderBy?: FeatureFlagOrderByWithAggregationInput | FeatureFlagOrderByWithAggregationInput[]
    by: FeatureFlagScalarFieldEnum[] | FeatureFlagScalarFieldEnum
    having?: FeatureFlagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureFlagCountAggregateInputType | true
    _avg?: FeatureFlagAvgAggregateInputType
    _sum?: FeatureFlagSumAggregateInputType
    _min?: FeatureFlagMinAggregateInputType
    _max?: FeatureFlagMaxAggregateInputType
  }

  export type FeatureFlagGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isEnabled: boolean
    rolloutPercentage: Decimal
    conditions: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: FeatureFlagCountAggregateOutputType | null
    _avg: FeatureFlagAvgAggregateOutputType | null
    _sum: FeatureFlagSumAggregateOutputType | null
    _min: FeatureFlagMinAggregateOutputType | null
    _max: FeatureFlagMaxAggregateOutputType | null
  }

  type GetFeatureFlagGroupByPayload<T extends FeatureFlagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureFlagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureFlagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureFlagGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureFlagGroupByOutputType[P]>
        }
      >
    >


  export type FeatureFlagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isEnabled?: boolean
    rolloutPercentage?: boolean
    conditions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["featureFlag"]>

  export type FeatureFlagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isEnabled?: boolean
    rolloutPercentage?: boolean
    conditions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["featureFlag"]>

  export type FeatureFlagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isEnabled?: boolean
    rolloutPercentage?: boolean
    conditions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["featureFlag"]>

  export type FeatureFlagSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isEnabled?: boolean
    rolloutPercentage?: boolean
    conditions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeatureFlagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isEnabled" | "rolloutPercentage" | "conditions" | "createdAt" | "updatedAt", ExtArgs["result"]["featureFlag"]>

  export type $FeatureFlagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeatureFlag"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isEnabled: boolean
      rolloutPercentage: Prisma.Decimal
      conditions: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["featureFlag"]>
    composites: {}
  }

  type FeatureFlagGetPayload<S extends boolean | null | undefined | FeatureFlagDefaultArgs> = $Result.GetResult<Prisma.$FeatureFlagPayload, S>

  type FeatureFlagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatureFlagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatureFlagCountAggregateInputType | true
    }

  export interface FeatureFlagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeatureFlag'], meta: { name: 'FeatureFlag' } }
    /**
     * Find zero or one FeatureFlag that matches the filter.
     * @param {FeatureFlagFindUniqueArgs} args - Arguments to find a FeatureFlag
     * @example
     * // Get one FeatureFlag
     * const featureFlag = await prisma.featureFlag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatureFlagFindUniqueArgs>(args: SelectSubset<T, FeatureFlagFindUniqueArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeatureFlag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatureFlagFindUniqueOrThrowArgs} args - Arguments to find a FeatureFlag
     * @example
     * // Get one FeatureFlag
     * const featureFlag = await prisma.featureFlag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatureFlagFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatureFlagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatureFlag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagFindFirstArgs} args - Arguments to find a FeatureFlag
     * @example
     * // Get one FeatureFlag
     * const featureFlag = await prisma.featureFlag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatureFlagFindFirstArgs>(args?: SelectSubset<T, FeatureFlagFindFirstArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatureFlag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagFindFirstOrThrowArgs} args - Arguments to find a FeatureFlag
     * @example
     * // Get one FeatureFlag
     * const featureFlag = await prisma.featureFlag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatureFlagFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatureFlagFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeatureFlags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeatureFlags
     * const featureFlags = await prisma.featureFlag.findMany()
     * 
     * // Get first 10 FeatureFlags
     * const featureFlags = await prisma.featureFlag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featureFlagWithIdOnly = await prisma.featureFlag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeatureFlagFindManyArgs>(args?: SelectSubset<T, FeatureFlagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeatureFlag.
     * @param {FeatureFlagCreateArgs} args - Arguments to create a FeatureFlag.
     * @example
     * // Create one FeatureFlag
     * const FeatureFlag = await prisma.featureFlag.create({
     *   data: {
     *     // ... data to create a FeatureFlag
     *   }
     * })
     * 
     */
    create<T extends FeatureFlagCreateArgs>(args: SelectSubset<T, FeatureFlagCreateArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeatureFlags.
     * @param {FeatureFlagCreateManyArgs} args - Arguments to create many FeatureFlags.
     * @example
     * // Create many FeatureFlags
     * const featureFlag = await prisma.featureFlag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatureFlagCreateManyArgs>(args?: SelectSubset<T, FeatureFlagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeatureFlags and returns the data saved in the database.
     * @param {FeatureFlagCreateManyAndReturnArgs} args - Arguments to create many FeatureFlags.
     * @example
     * // Create many FeatureFlags
     * const featureFlag = await prisma.featureFlag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeatureFlags and only return the `id`
     * const featureFlagWithIdOnly = await prisma.featureFlag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatureFlagCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatureFlagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeatureFlag.
     * @param {FeatureFlagDeleteArgs} args - Arguments to delete one FeatureFlag.
     * @example
     * // Delete one FeatureFlag
     * const FeatureFlag = await prisma.featureFlag.delete({
     *   where: {
     *     // ... filter to delete one FeatureFlag
     *   }
     * })
     * 
     */
    delete<T extends FeatureFlagDeleteArgs>(args: SelectSubset<T, FeatureFlagDeleteArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeatureFlag.
     * @param {FeatureFlagUpdateArgs} args - Arguments to update one FeatureFlag.
     * @example
     * // Update one FeatureFlag
     * const featureFlag = await prisma.featureFlag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatureFlagUpdateArgs>(args: SelectSubset<T, FeatureFlagUpdateArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeatureFlags.
     * @param {FeatureFlagDeleteManyArgs} args - Arguments to filter FeatureFlags to delete.
     * @example
     * // Delete a few FeatureFlags
     * const { count } = await prisma.featureFlag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatureFlagDeleteManyArgs>(args?: SelectSubset<T, FeatureFlagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeatureFlags
     * const featureFlag = await prisma.featureFlag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatureFlagUpdateManyArgs>(args: SelectSubset<T, FeatureFlagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureFlags and returns the data updated in the database.
     * @param {FeatureFlagUpdateManyAndReturnArgs} args - Arguments to update many FeatureFlags.
     * @example
     * // Update many FeatureFlags
     * const featureFlag = await prisma.featureFlag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeatureFlags and only return the `id`
     * const featureFlagWithIdOnly = await prisma.featureFlag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeatureFlagUpdateManyAndReturnArgs>(args: SelectSubset<T, FeatureFlagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeatureFlag.
     * @param {FeatureFlagUpsertArgs} args - Arguments to update or create a FeatureFlag.
     * @example
     * // Update or create a FeatureFlag
     * const featureFlag = await prisma.featureFlag.upsert({
     *   create: {
     *     // ... data to create a FeatureFlag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeatureFlag we want to update
     *   }
     * })
     */
    upsert<T extends FeatureFlagUpsertArgs>(args: SelectSubset<T, FeatureFlagUpsertArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeatureFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagCountArgs} args - Arguments to filter FeatureFlags to count.
     * @example
     * // Count the number of FeatureFlags
     * const count = await prisma.featureFlag.count({
     *   where: {
     *     // ... the filter for the FeatureFlags we want to count
     *   }
     * })
    **/
    count<T extends FeatureFlagCountArgs>(
      args?: Subset<T, FeatureFlagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureFlagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeatureFlag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureFlagAggregateArgs>(args: Subset<T, FeatureFlagAggregateArgs>): Prisma.PrismaPromise<GetFeatureFlagAggregateType<T>>

    /**
     * Group by FeatureFlag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureFlagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureFlagGroupByArgs['orderBy'] }
        : { orderBy?: FeatureFlagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureFlagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureFlagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeatureFlag model
   */
  readonly fields: FeatureFlagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeatureFlag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureFlagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeatureFlag model
   */
  interface FeatureFlagFieldRefs {
    readonly id: FieldRef<"FeatureFlag", 'String'>
    readonly name: FieldRef<"FeatureFlag", 'String'>
    readonly description: FieldRef<"FeatureFlag", 'String'>
    readonly isEnabled: FieldRef<"FeatureFlag", 'Boolean'>
    readonly rolloutPercentage: FieldRef<"FeatureFlag", 'Decimal'>
    readonly conditions: FieldRef<"FeatureFlag", 'Json'>
    readonly createdAt: FieldRef<"FeatureFlag", 'DateTime'>
    readonly updatedAt: FieldRef<"FeatureFlag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeatureFlag findUnique
   */
  export type FeatureFlagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * Filter, which FeatureFlag to fetch.
     */
    where: FeatureFlagWhereUniqueInput
  }

  /**
   * FeatureFlag findUniqueOrThrow
   */
  export type FeatureFlagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * Filter, which FeatureFlag to fetch.
     */
    where: FeatureFlagWhereUniqueInput
  }

  /**
   * FeatureFlag findFirst
   */
  export type FeatureFlagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * Filter, which FeatureFlag to fetch.
     */
    where?: FeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagOrderByWithRelationInput | FeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureFlags.
     */
    cursor?: FeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureFlags.
     */
    distinct?: FeatureFlagScalarFieldEnum | FeatureFlagScalarFieldEnum[]
  }

  /**
   * FeatureFlag findFirstOrThrow
   */
  export type FeatureFlagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * Filter, which FeatureFlag to fetch.
     */
    where?: FeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagOrderByWithRelationInput | FeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureFlags.
     */
    cursor?: FeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureFlags.
     */
    distinct?: FeatureFlagScalarFieldEnum | FeatureFlagScalarFieldEnum[]
  }

  /**
   * FeatureFlag findMany
   */
  export type FeatureFlagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * Filter, which FeatureFlags to fetch.
     */
    where?: FeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagOrderByWithRelationInput | FeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeatureFlags.
     */
    cursor?: FeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    distinct?: FeatureFlagScalarFieldEnum | FeatureFlagScalarFieldEnum[]
  }

  /**
   * FeatureFlag create
   */
  export type FeatureFlagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * The data needed to create a FeatureFlag.
     */
    data: XOR<FeatureFlagCreateInput, FeatureFlagUncheckedCreateInput>
  }

  /**
   * FeatureFlag createMany
   */
  export type FeatureFlagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeatureFlags.
     */
    data: FeatureFlagCreateManyInput | FeatureFlagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatureFlag createManyAndReturn
   */
  export type FeatureFlagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * The data used to create many FeatureFlags.
     */
    data: FeatureFlagCreateManyInput | FeatureFlagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatureFlag update
   */
  export type FeatureFlagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * The data needed to update a FeatureFlag.
     */
    data: XOR<FeatureFlagUpdateInput, FeatureFlagUncheckedUpdateInput>
    /**
     * Choose, which FeatureFlag to update.
     */
    where: FeatureFlagWhereUniqueInput
  }

  /**
   * FeatureFlag updateMany
   */
  export type FeatureFlagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeatureFlags.
     */
    data: XOR<FeatureFlagUpdateManyMutationInput, FeatureFlagUncheckedUpdateManyInput>
    /**
     * Filter which FeatureFlags to update
     */
    where?: FeatureFlagWhereInput
    /**
     * Limit how many FeatureFlags to update.
     */
    limit?: number
  }

  /**
   * FeatureFlag updateManyAndReturn
   */
  export type FeatureFlagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * The data used to update FeatureFlags.
     */
    data: XOR<FeatureFlagUpdateManyMutationInput, FeatureFlagUncheckedUpdateManyInput>
    /**
     * Filter which FeatureFlags to update
     */
    where?: FeatureFlagWhereInput
    /**
     * Limit how many FeatureFlags to update.
     */
    limit?: number
  }

  /**
   * FeatureFlag upsert
   */
  export type FeatureFlagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * The filter to search for the FeatureFlag to update in case it exists.
     */
    where: FeatureFlagWhereUniqueInput
    /**
     * In case the FeatureFlag found by the `where` argument doesn't exist, create a new FeatureFlag with this data.
     */
    create: XOR<FeatureFlagCreateInput, FeatureFlagUncheckedCreateInput>
    /**
     * In case the FeatureFlag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureFlagUpdateInput, FeatureFlagUncheckedUpdateInput>
  }

  /**
   * FeatureFlag delete
   */
  export type FeatureFlagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * Filter which FeatureFlag to delete.
     */
    where: FeatureFlagWhereUniqueInput
  }

  /**
   * FeatureFlag deleteMany
   */
  export type FeatureFlagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureFlags to delete
     */
    where?: FeatureFlagWhereInput
    /**
     * Limit how many FeatureFlags to delete.
     */
    limit?: number
  }

  /**
   * FeatureFlag without action
   */
  export type FeatureFlagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const FeatureGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    iconName: 'iconName',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeatureGroupScalarFieldEnum = (typeof FeatureGroupScalarFieldEnum)[keyof typeof FeatureGroupScalarFieldEnum]


  export const FeatureScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    name: 'name',
    description: 'description',
    explanation: 'explanation',
    isCountable: 'isCountable',
    minCount: 'minCount',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeatureScalarFieldEnum = (typeof FeatureScalarFieldEnum)[keyof typeof FeatureScalarFieldEnum]


  export const FeatureTierScalarFieldEnum: {
    id: 'id',
    featureId: 'featureId',
    tierName: 'tierName',
    description: 'description',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeatureTierScalarFieldEnum = (typeof FeatureTierScalarFieldEnum)[keyof typeof FeatureTierScalarFieldEnum]


  export const BusinessTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    basePrice: 'basePrice',
    timelineDays: 'timelineDays',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessTypeScalarFieldEnum = (typeof BusinessTypeScalarFieldEnum)[keyof typeof BusinessTypeScalarFieldEnum]


  export const BusinessTypeDefaultScalarFieldEnum: {
    id: 'id',
    businessTypeId: 'businessTypeId',
    featureId: 'featureId',
    defaultTier: 'defaultTier',
    defaultCount: 'defaultCount',
    createdAt: 'createdAt'
  };

  export type BusinessTypeDefaultScalarFieldEnum = (typeof BusinessTypeDefaultScalarFieldEnum)[keyof typeof BusinessTypeDefaultScalarFieldEnum]


  export const BusinessTypePageScalarFieldEnum: {
    id: 'id',
    businessTypeId: 'businessTypeId',
    pageType: 'pageType',
    pageName: 'pageName',
    isDefault: 'isDefault',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt'
  };

  export type BusinessTypePageScalarFieldEnum = (typeof BusinessTypePageScalarFieldEnum)[keyof typeof BusinessTypePageScalarFieldEnum]


  export const ServiceCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type ServiceCategoryScalarFieldEnum = (typeof ServiceCategoryScalarFieldEnum)[keyof typeof ServiceCategoryScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    categoryId: 'categoryId',
    priceMin: 'priceMin',
    priceMax: 'priceMax',
    demoUrl: 'demoUrl',
    iconName: 'iconName',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    company: 'company',
    projectType: 'projectType',
    budgetRange: 'budgetRange',
    timeline: 'timeline',
    description: 'description',
    preferredPackage: 'preferredPackage',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const TimeSlotScalarFieldEnum: {
    id: 'id',
    date: 'date',
    time: 'time',
    isAvailable: 'isAvailable',
    contactId: 'contactId',
    createdAt: 'createdAt'
  };

  export type TimeSlotScalarFieldEnum = (typeof TimeSlotScalarFieldEnum)[keyof typeof TimeSlotScalarFieldEnum]


  export const ContactFormStepScalarFieldEnum: {
    id: 'id',
    contactId: 'contactId',
    stepNumber: 'stepNumber',
    stepData: 'stepData',
    completedAt: 'completedAt'
  };

  export type ContactFormStepScalarFieldEnum = (typeof ContactFormStepScalarFieldEnum)[keyof typeof ContactFormStepScalarFieldEnum]


  export const PricingCalculationScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    businessTypeId: 'businessTypeId',
    totalPrice: 'totalPrice',
    calculationData: 'calculationData',
    contactId: 'contactId',
    createdAt: 'createdAt'
  };

  export type PricingCalculationScalarFieldEnum = (typeof PricingCalculationScalarFieldEnum)[keyof typeof PricingCalculationScalarFieldEnum]


  export const CalculationFeatureScalarFieldEnum: {
    id: 'id',
    calculationId: 'calculationId',
    featureId: 'featureId',
    tierName: 'tierName',
    count: 'count',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice'
  };

  export type CalculationFeatureScalarFieldEnum = (typeof CalculationFeatureScalarFieldEnum)[keyof typeof CalculationFeatureScalarFieldEnum]


  export const ContactInfoScalarFieldEnum: {
    id: 'id',
    type: 'type',
    label: 'label',
    value: 'value',
    iconName: 'iconName',
    color: 'color',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type ContactInfoScalarFieldEnum = (typeof ContactInfoScalarFieldEnum)[keyof typeof ContactInfoScalarFieldEnum]


  export const ProjectTypeScalarFieldEnum: {
    id: 'id',
    value: 'value',
    label: 'label',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type ProjectTypeScalarFieldEnum = (typeof ProjectTypeScalarFieldEnum)[keyof typeof ProjectTypeScalarFieldEnum]


  export const BudgetRangeScalarFieldEnum: {
    id: 'id',
    value: 'value',
    label: 'label',
    minAmount: 'minAmount',
    maxAmount: 'maxAmount',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type BudgetRangeScalarFieldEnum = (typeof BudgetRangeScalarFieldEnum)[keyof typeof BudgetRangeScalarFieldEnum]


  export const TimelineOptionScalarFieldEnum: {
    id: 'id',
    value: 'value',
    label: 'label',
    description: 'description',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type TimelineOptionScalarFieldEnum = (typeof TimelineOptionScalarFieldEnum)[keyof typeof TimelineOptionScalarFieldEnum]


  export const PackageOptionScalarFieldEnum: {
    id: 'id',
    value: 'value',
    label: 'label',
    description: 'description',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type PackageOptionScalarFieldEnum = (typeof PackageOptionScalarFieldEnum)[keyof typeof PackageOptionScalarFieldEnum]


  export const MigrationLogScalarFieldEnum: {
    id: 'id',
    migrationPhase: 'migrationPhase',
    entityType: 'entityType',
    entityId: 'entityId',
    operation: 'operation',
    oldValues: 'oldValues',
    newValues: 'newValues',
    validationResult: 'validationResult',
    status: 'status',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt'
  };

  export type MigrationLogScalarFieldEnum = (typeof MigrationLogScalarFieldEnum)[keyof typeof MigrationLogScalarFieldEnum]


  export const SystemAuditScalarFieldEnum: {
    id: 'id',
    tableName: 'tableName',
    recordId: 'recordId',
    operation: 'operation',
    oldValues: 'oldValues',
    newValues: 'newValues',
    userId: 'userId',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt'
  };

  export type SystemAuditScalarFieldEnum = (typeof SystemAuditScalarFieldEnum)[keyof typeof SystemAuditScalarFieldEnum]


  export const FeatureFlagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isEnabled: 'isEnabled',
    rolloutPercentage: 'rolloutPercentage',
    conditions: 'conditions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeatureFlagScalarFieldEnum = (typeof FeatureFlagScalarFieldEnum)[keyof typeof FeatureFlagScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type FeatureGroupWhereInput = {
    AND?: FeatureGroupWhereInput | FeatureGroupWhereInput[]
    OR?: FeatureGroupWhereInput[]
    NOT?: FeatureGroupWhereInput | FeatureGroupWhereInput[]
    id?: UuidFilter<"FeatureGroup"> | string
    name?: StringFilter<"FeatureGroup"> | string
    description?: StringNullableFilter<"FeatureGroup"> | string | null
    iconName?: StringNullableFilter<"FeatureGroup"> | string | null
    displayOrder?: IntNullableFilter<"FeatureGroup"> | number | null
    isActive?: BoolFilter<"FeatureGroup"> | boolean
    createdAt?: DateTimeFilter<"FeatureGroup"> | Date | string
    updatedAt?: DateTimeFilter<"FeatureGroup"> | Date | string
    features?: FeatureListRelationFilter
  }

  export type FeatureGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    iconName?: SortOrderInput | SortOrder
    displayOrder?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    features?: FeatureOrderByRelationAggregateInput
  }

  export type FeatureGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeatureGroupWhereInput | FeatureGroupWhereInput[]
    OR?: FeatureGroupWhereInput[]
    NOT?: FeatureGroupWhereInput | FeatureGroupWhereInput[]
    name?: StringFilter<"FeatureGroup"> | string
    description?: StringNullableFilter<"FeatureGroup"> | string | null
    iconName?: StringNullableFilter<"FeatureGroup"> | string | null
    displayOrder?: IntNullableFilter<"FeatureGroup"> | number | null
    isActive?: BoolFilter<"FeatureGroup"> | boolean
    createdAt?: DateTimeFilter<"FeatureGroup"> | Date | string
    updatedAt?: DateTimeFilter<"FeatureGroup"> | Date | string
    features?: FeatureListRelationFilter
  }, "id">

  export type FeatureGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    iconName?: SortOrderInput | SortOrder
    displayOrder?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeatureGroupCountOrderByAggregateInput
    _avg?: FeatureGroupAvgOrderByAggregateInput
    _max?: FeatureGroupMaxOrderByAggregateInput
    _min?: FeatureGroupMinOrderByAggregateInput
    _sum?: FeatureGroupSumOrderByAggregateInput
  }

  export type FeatureGroupScalarWhereWithAggregatesInput = {
    AND?: FeatureGroupScalarWhereWithAggregatesInput | FeatureGroupScalarWhereWithAggregatesInput[]
    OR?: FeatureGroupScalarWhereWithAggregatesInput[]
    NOT?: FeatureGroupScalarWhereWithAggregatesInput | FeatureGroupScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FeatureGroup"> | string
    name?: StringWithAggregatesFilter<"FeatureGroup"> | string
    description?: StringNullableWithAggregatesFilter<"FeatureGroup"> | string | null
    iconName?: StringNullableWithAggregatesFilter<"FeatureGroup"> | string | null
    displayOrder?: IntNullableWithAggregatesFilter<"FeatureGroup"> | number | null
    isActive?: BoolWithAggregatesFilter<"FeatureGroup"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FeatureGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeatureGroup"> | Date | string
  }

  export type FeatureWhereInput = {
    AND?: FeatureWhereInput | FeatureWhereInput[]
    OR?: FeatureWhereInput[]
    NOT?: FeatureWhereInput | FeatureWhereInput[]
    id?: UuidFilter<"Feature"> | string
    groupId?: UuidFilter<"Feature"> | string
    name?: StringFilter<"Feature"> | string
    description?: StringNullableFilter<"Feature"> | string | null
    explanation?: StringNullableFilter<"Feature"> | string | null
    isCountable?: BoolFilter<"Feature"> | boolean
    minCount?: IntFilter<"Feature"> | number
    displayOrder?: IntNullableFilter<"Feature"> | number | null
    isActive?: BoolFilter<"Feature"> | boolean
    createdAt?: DateTimeFilter<"Feature"> | Date | string
    updatedAt?: DateTimeFilter<"Feature"> | Date | string
    defaults?: BusinessTypeDefaultListRelationFilter
    calculations?: CalculationFeatureListRelationFilter
    tiers?: FeatureTierListRelationFilter
    group?: XOR<FeatureGroupScalarRelationFilter, FeatureGroupWhereInput>
  }

  export type FeatureOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    explanation?: SortOrderInput | SortOrder
    isCountable?: SortOrder
    minCount?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    defaults?: BusinessTypeDefaultOrderByRelationAggregateInput
    calculations?: CalculationFeatureOrderByRelationAggregateInput
    tiers?: FeatureTierOrderByRelationAggregateInput
    group?: FeatureGroupOrderByWithRelationInput
  }

  export type FeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeatureWhereInput | FeatureWhereInput[]
    OR?: FeatureWhereInput[]
    NOT?: FeatureWhereInput | FeatureWhereInput[]
    groupId?: UuidFilter<"Feature"> | string
    name?: StringFilter<"Feature"> | string
    description?: StringNullableFilter<"Feature"> | string | null
    explanation?: StringNullableFilter<"Feature"> | string | null
    isCountable?: BoolFilter<"Feature"> | boolean
    minCount?: IntFilter<"Feature"> | number
    displayOrder?: IntNullableFilter<"Feature"> | number | null
    isActive?: BoolFilter<"Feature"> | boolean
    createdAt?: DateTimeFilter<"Feature"> | Date | string
    updatedAt?: DateTimeFilter<"Feature"> | Date | string
    defaults?: BusinessTypeDefaultListRelationFilter
    calculations?: CalculationFeatureListRelationFilter
    tiers?: FeatureTierListRelationFilter
    group?: XOR<FeatureGroupScalarRelationFilter, FeatureGroupWhereInput>
  }, "id">

  export type FeatureOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    explanation?: SortOrderInput | SortOrder
    isCountable?: SortOrder
    minCount?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeatureCountOrderByAggregateInput
    _avg?: FeatureAvgOrderByAggregateInput
    _max?: FeatureMaxOrderByAggregateInput
    _min?: FeatureMinOrderByAggregateInput
    _sum?: FeatureSumOrderByAggregateInput
  }

  export type FeatureScalarWhereWithAggregatesInput = {
    AND?: FeatureScalarWhereWithAggregatesInput | FeatureScalarWhereWithAggregatesInput[]
    OR?: FeatureScalarWhereWithAggregatesInput[]
    NOT?: FeatureScalarWhereWithAggregatesInput | FeatureScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Feature"> | string
    groupId?: UuidWithAggregatesFilter<"Feature"> | string
    name?: StringWithAggregatesFilter<"Feature"> | string
    description?: StringNullableWithAggregatesFilter<"Feature"> | string | null
    explanation?: StringNullableWithAggregatesFilter<"Feature"> | string | null
    isCountable?: BoolWithAggregatesFilter<"Feature"> | boolean
    minCount?: IntWithAggregatesFilter<"Feature"> | number
    displayOrder?: IntNullableWithAggregatesFilter<"Feature"> | number | null
    isActive?: BoolWithAggregatesFilter<"Feature"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Feature"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Feature"> | Date | string
  }

  export type FeatureTierWhereInput = {
    AND?: FeatureTierWhereInput | FeatureTierWhereInput[]
    OR?: FeatureTierWhereInput[]
    NOT?: FeatureTierWhereInput | FeatureTierWhereInput[]
    id?: UuidFilter<"FeatureTier"> | string
    featureId?: UuidFilter<"FeatureTier"> | string
    tierName?: StringFilter<"FeatureTier"> | string
    description?: StringNullableFilter<"FeatureTier"> | string | null
    price?: DecimalFilter<"FeatureTier"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"FeatureTier"> | Date | string
    updatedAt?: DateTimeFilter<"FeatureTier"> | Date | string
    calculations?: CalculationFeatureListRelationFilter
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
  }

  export type FeatureTierOrderByWithRelationInput = {
    id?: SortOrder
    featureId?: SortOrder
    tierName?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    calculations?: CalculationFeatureOrderByRelationAggregateInput
    feature?: FeatureOrderByWithRelationInput
  }

  export type FeatureTierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    featureId_tierName?: FeatureTierFeatureIdTierNameCompoundUniqueInput
    AND?: FeatureTierWhereInput | FeatureTierWhereInput[]
    OR?: FeatureTierWhereInput[]
    NOT?: FeatureTierWhereInput | FeatureTierWhereInput[]
    featureId?: UuidFilter<"FeatureTier"> | string
    tierName?: StringFilter<"FeatureTier"> | string
    description?: StringNullableFilter<"FeatureTier"> | string | null
    price?: DecimalFilter<"FeatureTier"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"FeatureTier"> | Date | string
    updatedAt?: DateTimeFilter<"FeatureTier"> | Date | string
    calculations?: CalculationFeatureListRelationFilter
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
  }, "id" | "featureId_tierName">

  export type FeatureTierOrderByWithAggregationInput = {
    id?: SortOrder
    featureId?: SortOrder
    tierName?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeatureTierCountOrderByAggregateInput
    _avg?: FeatureTierAvgOrderByAggregateInput
    _max?: FeatureTierMaxOrderByAggregateInput
    _min?: FeatureTierMinOrderByAggregateInput
    _sum?: FeatureTierSumOrderByAggregateInput
  }

  export type FeatureTierScalarWhereWithAggregatesInput = {
    AND?: FeatureTierScalarWhereWithAggregatesInput | FeatureTierScalarWhereWithAggregatesInput[]
    OR?: FeatureTierScalarWhereWithAggregatesInput[]
    NOT?: FeatureTierScalarWhereWithAggregatesInput | FeatureTierScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FeatureTier"> | string
    featureId?: UuidWithAggregatesFilter<"FeatureTier"> | string
    tierName?: StringWithAggregatesFilter<"FeatureTier"> | string
    description?: StringNullableWithAggregatesFilter<"FeatureTier"> | string | null
    price?: DecimalWithAggregatesFilter<"FeatureTier"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"FeatureTier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeatureTier"> | Date | string
  }

  export type BusinessTypeWhereInput = {
    AND?: BusinessTypeWhereInput | BusinessTypeWhereInput[]
    OR?: BusinessTypeWhereInput[]
    NOT?: BusinessTypeWhereInput | BusinessTypeWhereInput[]
    id?: UuidFilter<"BusinessType"> | string
    name?: StringFilter<"BusinessType"> | string
    slug?: StringFilter<"BusinessType"> | string
    description?: StringNullableFilter<"BusinessType"> | string | null
    basePrice?: DecimalFilter<"BusinessType"> | Decimal | DecimalJsLike | number | string
    timelineDays?: IntNullableFilter<"BusinessType"> | number | null
    isActive?: BoolFilter<"BusinessType"> | boolean
    createdAt?: DateTimeFilter<"BusinessType"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessType"> | Date | string
    defaults?: BusinessTypeDefaultListRelationFilter
    pages?: BusinessTypePageListRelationFilter
    calculations?: PricingCalculationListRelationFilter
  }

  export type BusinessTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    timelineDays?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    defaults?: BusinessTypeDefaultOrderByRelationAggregateInput
    pages?: BusinessTypePageOrderByRelationAggregateInput
    calculations?: PricingCalculationOrderByRelationAggregateInput
  }

  export type BusinessTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BusinessTypeWhereInput | BusinessTypeWhereInput[]
    OR?: BusinessTypeWhereInput[]
    NOT?: BusinessTypeWhereInput | BusinessTypeWhereInput[]
    name?: StringFilter<"BusinessType"> | string
    description?: StringNullableFilter<"BusinessType"> | string | null
    basePrice?: DecimalFilter<"BusinessType"> | Decimal | DecimalJsLike | number | string
    timelineDays?: IntNullableFilter<"BusinessType"> | number | null
    isActive?: BoolFilter<"BusinessType"> | boolean
    createdAt?: DateTimeFilter<"BusinessType"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessType"> | Date | string
    defaults?: BusinessTypeDefaultListRelationFilter
    pages?: BusinessTypePageListRelationFilter
    calculations?: PricingCalculationListRelationFilter
  }, "id" | "slug">

  export type BusinessTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    timelineDays?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessTypeCountOrderByAggregateInput
    _avg?: BusinessTypeAvgOrderByAggregateInput
    _max?: BusinessTypeMaxOrderByAggregateInput
    _min?: BusinessTypeMinOrderByAggregateInput
    _sum?: BusinessTypeSumOrderByAggregateInput
  }

  export type BusinessTypeScalarWhereWithAggregatesInput = {
    AND?: BusinessTypeScalarWhereWithAggregatesInput | BusinessTypeScalarWhereWithAggregatesInput[]
    OR?: BusinessTypeScalarWhereWithAggregatesInput[]
    NOT?: BusinessTypeScalarWhereWithAggregatesInput | BusinessTypeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BusinessType"> | string
    name?: StringWithAggregatesFilter<"BusinessType"> | string
    slug?: StringWithAggregatesFilter<"BusinessType"> | string
    description?: StringNullableWithAggregatesFilter<"BusinessType"> | string | null
    basePrice?: DecimalWithAggregatesFilter<"BusinessType"> | Decimal | DecimalJsLike | number | string
    timelineDays?: IntNullableWithAggregatesFilter<"BusinessType"> | number | null
    isActive?: BoolWithAggregatesFilter<"BusinessType"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BusinessType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessType"> | Date | string
  }

  export type BusinessTypeDefaultWhereInput = {
    AND?: BusinessTypeDefaultWhereInput | BusinessTypeDefaultWhereInput[]
    OR?: BusinessTypeDefaultWhereInput[]
    NOT?: BusinessTypeDefaultWhereInput | BusinessTypeDefaultWhereInput[]
    id?: UuidFilter<"BusinessTypeDefault"> | string
    businessTypeId?: UuidFilter<"BusinessTypeDefault"> | string
    featureId?: UuidFilter<"BusinessTypeDefault"> | string
    defaultTier?: StringFilter<"BusinessTypeDefault"> | string
    defaultCount?: IntFilter<"BusinessTypeDefault"> | number
    createdAt?: DateTimeFilter<"BusinessTypeDefault"> | Date | string
    businessType?: XOR<BusinessTypeScalarRelationFilter, BusinessTypeWhereInput>
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
  }

  export type BusinessTypeDefaultOrderByWithRelationInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    featureId?: SortOrder
    defaultTier?: SortOrder
    defaultCount?: SortOrder
    createdAt?: SortOrder
    businessType?: BusinessTypeOrderByWithRelationInput
    feature?: FeatureOrderByWithRelationInput
  }

  export type BusinessTypeDefaultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    businessTypeId_featureId?: BusinessTypeDefaultBusinessTypeIdFeatureIdCompoundUniqueInput
    AND?: BusinessTypeDefaultWhereInput | BusinessTypeDefaultWhereInput[]
    OR?: BusinessTypeDefaultWhereInput[]
    NOT?: BusinessTypeDefaultWhereInput | BusinessTypeDefaultWhereInput[]
    businessTypeId?: UuidFilter<"BusinessTypeDefault"> | string
    featureId?: UuidFilter<"BusinessTypeDefault"> | string
    defaultTier?: StringFilter<"BusinessTypeDefault"> | string
    defaultCount?: IntFilter<"BusinessTypeDefault"> | number
    createdAt?: DateTimeFilter<"BusinessTypeDefault"> | Date | string
    businessType?: XOR<BusinessTypeScalarRelationFilter, BusinessTypeWhereInput>
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
  }, "id" | "businessTypeId_featureId">

  export type BusinessTypeDefaultOrderByWithAggregationInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    featureId?: SortOrder
    defaultTier?: SortOrder
    defaultCount?: SortOrder
    createdAt?: SortOrder
    _count?: BusinessTypeDefaultCountOrderByAggregateInput
    _avg?: BusinessTypeDefaultAvgOrderByAggregateInput
    _max?: BusinessTypeDefaultMaxOrderByAggregateInput
    _min?: BusinessTypeDefaultMinOrderByAggregateInput
    _sum?: BusinessTypeDefaultSumOrderByAggregateInput
  }

  export type BusinessTypeDefaultScalarWhereWithAggregatesInput = {
    AND?: BusinessTypeDefaultScalarWhereWithAggregatesInput | BusinessTypeDefaultScalarWhereWithAggregatesInput[]
    OR?: BusinessTypeDefaultScalarWhereWithAggregatesInput[]
    NOT?: BusinessTypeDefaultScalarWhereWithAggregatesInput | BusinessTypeDefaultScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BusinessTypeDefault"> | string
    businessTypeId?: UuidWithAggregatesFilter<"BusinessTypeDefault"> | string
    featureId?: UuidWithAggregatesFilter<"BusinessTypeDefault"> | string
    defaultTier?: StringWithAggregatesFilter<"BusinessTypeDefault"> | string
    defaultCount?: IntWithAggregatesFilter<"BusinessTypeDefault"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BusinessTypeDefault"> | Date | string
  }

  export type BusinessTypePageWhereInput = {
    AND?: BusinessTypePageWhereInput | BusinessTypePageWhereInput[]
    OR?: BusinessTypePageWhereInput[]
    NOT?: BusinessTypePageWhereInput | BusinessTypePageWhereInput[]
    id?: UuidFilter<"BusinessTypePage"> | string
    businessTypeId?: UuidFilter<"BusinessTypePage"> | string
    pageType?: StringFilter<"BusinessTypePage"> | string
    pageName?: StringFilter<"BusinessTypePage"> | string
    isDefault?: BoolFilter<"BusinessTypePage"> | boolean
    displayOrder?: IntNullableFilter<"BusinessTypePage"> | number | null
    createdAt?: DateTimeFilter<"BusinessTypePage"> | Date | string
    businessType?: XOR<BusinessTypeScalarRelationFilter, BusinessTypeWhereInput>
  }

  export type BusinessTypePageOrderByWithRelationInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    pageType?: SortOrder
    pageName?: SortOrder
    isDefault?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    businessType?: BusinessTypeOrderByWithRelationInput
  }

  export type BusinessTypePageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BusinessTypePageWhereInput | BusinessTypePageWhereInput[]
    OR?: BusinessTypePageWhereInput[]
    NOT?: BusinessTypePageWhereInput | BusinessTypePageWhereInput[]
    businessTypeId?: UuidFilter<"BusinessTypePage"> | string
    pageType?: StringFilter<"BusinessTypePage"> | string
    pageName?: StringFilter<"BusinessTypePage"> | string
    isDefault?: BoolFilter<"BusinessTypePage"> | boolean
    displayOrder?: IntNullableFilter<"BusinessTypePage"> | number | null
    createdAt?: DateTimeFilter<"BusinessTypePage"> | Date | string
    businessType?: XOR<BusinessTypeScalarRelationFilter, BusinessTypeWhereInput>
  }, "id">

  export type BusinessTypePageOrderByWithAggregationInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    pageType?: SortOrder
    pageName?: SortOrder
    isDefault?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BusinessTypePageCountOrderByAggregateInput
    _avg?: BusinessTypePageAvgOrderByAggregateInput
    _max?: BusinessTypePageMaxOrderByAggregateInput
    _min?: BusinessTypePageMinOrderByAggregateInput
    _sum?: BusinessTypePageSumOrderByAggregateInput
  }

  export type BusinessTypePageScalarWhereWithAggregatesInput = {
    AND?: BusinessTypePageScalarWhereWithAggregatesInput | BusinessTypePageScalarWhereWithAggregatesInput[]
    OR?: BusinessTypePageScalarWhereWithAggregatesInput[]
    NOT?: BusinessTypePageScalarWhereWithAggregatesInput | BusinessTypePageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BusinessTypePage"> | string
    businessTypeId?: UuidWithAggregatesFilter<"BusinessTypePage"> | string
    pageType?: StringWithAggregatesFilter<"BusinessTypePage"> | string
    pageName?: StringWithAggregatesFilter<"BusinessTypePage"> | string
    isDefault?: BoolWithAggregatesFilter<"BusinessTypePage"> | boolean
    displayOrder?: IntNullableWithAggregatesFilter<"BusinessTypePage"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"BusinessTypePage"> | Date | string
  }

  export type ServiceCategoryWhereInput = {
    AND?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    OR?: ServiceCategoryWhereInput[]
    NOT?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    id?: UuidFilter<"ServiceCategory"> | string
    name?: StringFilter<"ServiceCategory"> | string
    slug?: StringFilter<"ServiceCategory"> | string
    description?: StringNullableFilter<"ServiceCategory"> | string | null
    createdAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    services?: ServiceListRelationFilter
  }

  export type ServiceCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
  }

  export type ServiceCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    OR?: ServiceCategoryWhereInput[]
    NOT?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    name?: StringFilter<"ServiceCategory"> | string
    description?: StringNullableFilter<"ServiceCategory"> | string | null
    createdAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    services?: ServiceListRelationFilter
  }, "id" | "slug">

  export type ServiceCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ServiceCategoryCountOrderByAggregateInput
    _max?: ServiceCategoryMaxOrderByAggregateInput
    _min?: ServiceCategoryMinOrderByAggregateInput
  }

  export type ServiceCategoryScalarWhereWithAggregatesInput = {
    AND?: ServiceCategoryScalarWhereWithAggregatesInput | ServiceCategoryScalarWhereWithAggregatesInput[]
    OR?: ServiceCategoryScalarWhereWithAggregatesInput[]
    NOT?: ServiceCategoryScalarWhereWithAggregatesInput | ServiceCategoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ServiceCategory"> | string
    name?: StringWithAggregatesFilter<"ServiceCategory"> | string
    slug?: StringWithAggregatesFilter<"ServiceCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ServiceCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceCategory"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: UuidFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    slug?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    categoryId?: UuidFilter<"Service"> | string
    priceMin?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    priceMax?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    demoUrl?: StringNullableFilter<"Service"> | string | null
    iconName?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    category?: XOR<ServiceCategoryScalarRelationFilter, ServiceCategoryWhereInput>
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    priceMin?: SortOrderInput | SortOrder
    priceMax?: SortOrderInput | SortOrder
    demoUrl?: SortOrderInput | SortOrder
    iconName?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: ServiceCategoryOrderByWithRelationInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    categoryId?: UuidFilter<"Service"> | string
    priceMin?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    priceMax?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    demoUrl?: StringNullableFilter<"Service"> | string | null
    iconName?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    category?: XOR<ServiceCategoryScalarRelationFilter, ServiceCategoryWhereInput>
  }, "id" | "slug">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    priceMin?: SortOrderInput | SortOrder
    priceMax?: SortOrderInput | SortOrder
    demoUrl?: SortOrderInput | SortOrder
    iconName?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    slug?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    categoryId?: UuidWithAggregatesFilter<"Service"> | string
    priceMin?: DecimalNullableWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    priceMax?: DecimalNullableWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    demoUrl?: StringNullableWithAggregatesFilter<"Service"> | string | null
    iconName?: StringNullableWithAggregatesFilter<"Service"> | string | null
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: UuidFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    phone?: StringNullableFilter<"Contact"> | string | null
    company?: StringNullableFilter<"Contact"> | string | null
    projectType?: StringNullableFilter<"Contact"> | string | null
    budgetRange?: StringNullableFilter<"Contact"> | string | null
    timeline?: StringNullableFilter<"Contact"> | string | null
    description?: StringNullableFilter<"Contact"> | string | null
    preferredPackage?: StringNullableFilter<"Contact"> | string | null
    status?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    formSteps?: ContactFormStepListRelationFilter
    calculations?: PricingCalculationListRelationFilter
    timeSlots?: TimeSlotListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    projectType?: SortOrderInput | SortOrder
    budgetRange?: SortOrderInput | SortOrder
    timeline?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    preferredPackage?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    formSteps?: ContactFormStepOrderByRelationAggregateInput
    calculations?: PricingCalculationOrderByRelationAggregateInput
    timeSlots?: TimeSlotOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    name?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    phone?: StringNullableFilter<"Contact"> | string | null
    company?: StringNullableFilter<"Contact"> | string | null
    projectType?: StringNullableFilter<"Contact"> | string | null
    budgetRange?: StringNullableFilter<"Contact"> | string | null
    timeline?: StringNullableFilter<"Contact"> | string | null
    description?: StringNullableFilter<"Contact"> | string | null
    preferredPackage?: StringNullableFilter<"Contact"> | string | null
    status?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    formSteps?: ContactFormStepListRelationFilter
    calculations?: PricingCalculationListRelationFilter
    timeSlots?: TimeSlotListRelationFilter
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    projectType?: SortOrderInput | SortOrder
    budgetRange?: SortOrderInput | SortOrder
    timeline?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    preferredPackage?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Contact"> | string
    name?: StringWithAggregatesFilter<"Contact"> | string
    email?: StringWithAggregatesFilter<"Contact"> | string
    phone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    company?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    projectType?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    budgetRange?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    timeline?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    description?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    preferredPackage?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    status?: StringWithAggregatesFilter<"Contact"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type TimeSlotWhereInput = {
    AND?: TimeSlotWhereInput | TimeSlotWhereInput[]
    OR?: TimeSlotWhereInput[]
    NOT?: TimeSlotWhereInput | TimeSlotWhereInput[]
    id?: UuidFilter<"TimeSlot"> | string
    date?: DateTimeFilter<"TimeSlot"> | Date | string
    time?: DateTimeFilter<"TimeSlot"> | Date | string
    isAvailable?: BoolFilter<"TimeSlot"> | boolean
    contactId?: UuidNullableFilter<"TimeSlot"> | string | null
    createdAt?: DateTimeFilter<"TimeSlot"> | Date | string
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
  }

  export type TimeSlotOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    isAvailable?: SortOrder
    contactId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    contact?: ContactOrderByWithRelationInput
  }

  export type TimeSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    date_time?: TimeSlotDateTimeCompoundUniqueInput
    AND?: TimeSlotWhereInput | TimeSlotWhereInput[]
    OR?: TimeSlotWhereInput[]
    NOT?: TimeSlotWhereInput | TimeSlotWhereInput[]
    date?: DateTimeFilter<"TimeSlot"> | Date | string
    time?: DateTimeFilter<"TimeSlot"> | Date | string
    isAvailable?: BoolFilter<"TimeSlot"> | boolean
    contactId?: UuidNullableFilter<"TimeSlot"> | string | null
    createdAt?: DateTimeFilter<"TimeSlot"> | Date | string
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
  }, "id" | "date_time">

  export type TimeSlotOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    isAvailable?: SortOrder
    contactId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TimeSlotCountOrderByAggregateInput
    _max?: TimeSlotMaxOrderByAggregateInput
    _min?: TimeSlotMinOrderByAggregateInput
  }

  export type TimeSlotScalarWhereWithAggregatesInput = {
    AND?: TimeSlotScalarWhereWithAggregatesInput | TimeSlotScalarWhereWithAggregatesInput[]
    OR?: TimeSlotScalarWhereWithAggregatesInput[]
    NOT?: TimeSlotScalarWhereWithAggregatesInput | TimeSlotScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TimeSlot"> | string
    date?: DateTimeWithAggregatesFilter<"TimeSlot"> | Date | string
    time?: DateTimeWithAggregatesFilter<"TimeSlot"> | Date | string
    isAvailable?: BoolWithAggregatesFilter<"TimeSlot"> | boolean
    contactId?: UuidNullableWithAggregatesFilter<"TimeSlot"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TimeSlot"> | Date | string
  }

  export type ContactFormStepWhereInput = {
    AND?: ContactFormStepWhereInput | ContactFormStepWhereInput[]
    OR?: ContactFormStepWhereInput[]
    NOT?: ContactFormStepWhereInput | ContactFormStepWhereInput[]
    id?: UuidFilter<"ContactFormStep"> | string
    contactId?: UuidFilter<"ContactFormStep"> | string
    stepNumber?: IntFilter<"ContactFormStep"> | number
    stepData?: JsonFilter<"ContactFormStep">
    completedAt?: DateTimeFilter<"ContactFormStep"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }

  export type ContactFormStepOrderByWithRelationInput = {
    id?: SortOrder
    contactId?: SortOrder
    stepNumber?: SortOrder
    stepData?: SortOrder
    completedAt?: SortOrder
    contact?: ContactOrderByWithRelationInput
  }

  export type ContactFormStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactFormStepWhereInput | ContactFormStepWhereInput[]
    OR?: ContactFormStepWhereInput[]
    NOT?: ContactFormStepWhereInput | ContactFormStepWhereInput[]
    contactId?: UuidFilter<"ContactFormStep"> | string
    stepNumber?: IntFilter<"ContactFormStep"> | number
    stepData?: JsonFilter<"ContactFormStep">
    completedAt?: DateTimeFilter<"ContactFormStep"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }, "id">

  export type ContactFormStepOrderByWithAggregationInput = {
    id?: SortOrder
    contactId?: SortOrder
    stepNumber?: SortOrder
    stepData?: SortOrder
    completedAt?: SortOrder
    _count?: ContactFormStepCountOrderByAggregateInput
    _avg?: ContactFormStepAvgOrderByAggregateInput
    _max?: ContactFormStepMaxOrderByAggregateInput
    _min?: ContactFormStepMinOrderByAggregateInput
    _sum?: ContactFormStepSumOrderByAggregateInput
  }

  export type ContactFormStepScalarWhereWithAggregatesInput = {
    AND?: ContactFormStepScalarWhereWithAggregatesInput | ContactFormStepScalarWhereWithAggregatesInput[]
    OR?: ContactFormStepScalarWhereWithAggregatesInput[]
    NOT?: ContactFormStepScalarWhereWithAggregatesInput | ContactFormStepScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ContactFormStep"> | string
    contactId?: UuidWithAggregatesFilter<"ContactFormStep"> | string
    stepNumber?: IntWithAggregatesFilter<"ContactFormStep"> | number
    stepData?: JsonWithAggregatesFilter<"ContactFormStep">
    completedAt?: DateTimeWithAggregatesFilter<"ContactFormStep"> | Date | string
  }

  export type PricingCalculationWhereInput = {
    AND?: PricingCalculationWhereInput | PricingCalculationWhereInput[]
    OR?: PricingCalculationWhereInput[]
    NOT?: PricingCalculationWhereInput | PricingCalculationWhereInput[]
    id?: UuidFilter<"PricingCalculation"> | string
    sessionId?: StringNullableFilter<"PricingCalculation"> | string | null
    businessTypeId?: UuidFilter<"PricingCalculation"> | string
    totalPrice?: DecimalFilter<"PricingCalculation"> | Decimal | DecimalJsLike | number | string
    calculationData?: JsonFilter<"PricingCalculation">
    contactId?: UuidNullableFilter<"PricingCalculation"> | string | null
    createdAt?: DateTimeFilter<"PricingCalculation"> | Date | string
    features?: CalculationFeatureListRelationFilter
    businessType?: XOR<BusinessTypeScalarRelationFilter, BusinessTypeWhereInput>
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
  }

  export type PricingCalculationOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    businessTypeId?: SortOrder
    totalPrice?: SortOrder
    calculationData?: SortOrder
    contactId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    features?: CalculationFeatureOrderByRelationAggregateInput
    businessType?: BusinessTypeOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
  }

  export type PricingCalculationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PricingCalculationWhereInput | PricingCalculationWhereInput[]
    OR?: PricingCalculationWhereInput[]
    NOT?: PricingCalculationWhereInput | PricingCalculationWhereInput[]
    sessionId?: StringNullableFilter<"PricingCalculation"> | string | null
    businessTypeId?: UuidFilter<"PricingCalculation"> | string
    totalPrice?: DecimalFilter<"PricingCalculation"> | Decimal | DecimalJsLike | number | string
    calculationData?: JsonFilter<"PricingCalculation">
    contactId?: UuidNullableFilter<"PricingCalculation"> | string | null
    createdAt?: DateTimeFilter<"PricingCalculation"> | Date | string
    features?: CalculationFeatureListRelationFilter
    businessType?: XOR<BusinessTypeScalarRelationFilter, BusinessTypeWhereInput>
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
  }, "id">

  export type PricingCalculationOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    businessTypeId?: SortOrder
    totalPrice?: SortOrder
    calculationData?: SortOrder
    contactId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PricingCalculationCountOrderByAggregateInput
    _avg?: PricingCalculationAvgOrderByAggregateInput
    _max?: PricingCalculationMaxOrderByAggregateInput
    _min?: PricingCalculationMinOrderByAggregateInput
    _sum?: PricingCalculationSumOrderByAggregateInput
  }

  export type PricingCalculationScalarWhereWithAggregatesInput = {
    AND?: PricingCalculationScalarWhereWithAggregatesInput | PricingCalculationScalarWhereWithAggregatesInput[]
    OR?: PricingCalculationScalarWhereWithAggregatesInput[]
    NOT?: PricingCalculationScalarWhereWithAggregatesInput | PricingCalculationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PricingCalculation"> | string
    sessionId?: StringNullableWithAggregatesFilter<"PricingCalculation"> | string | null
    businessTypeId?: UuidWithAggregatesFilter<"PricingCalculation"> | string
    totalPrice?: DecimalWithAggregatesFilter<"PricingCalculation"> | Decimal | DecimalJsLike | number | string
    calculationData?: JsonWithAggregatesFilter<"PricingCalculation">
    contactId?: UuidNullableWithAggregatesFilter<"PricingCalculation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PricingCalculation"> | Date | string
  }

  export type CalculationFeatureWhereInput = {
    AND?: CalculationFeatureWhereInput | CalculationFeatureWhereInput[]
    OR?: CalculationFeatureWhereInput[]
    NOT?: CalculationFeatureWhereInput | CalculationFeatureWhereInput[]
    id?: UuidFilter<"CalculationFeature"> | string
    calculationId?: UuidFilter<"CalculationFeature"> | string
    featureId?: UuidFilter<"CalculationFeature"> | string
    tierName?: StringFilter<"CalculationFeature"> | string
    count?: IntFilter<"CalculationFeature"> | number
    unitPrice?: DecimalFilter<"CalculationFeature"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"CalculationFeature"> | Decimal | DecimalJsLike | number | string
    calculation?: XOR<PricingCalculationScalarRelationFilter, PricingCalculationWhereInput>
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    tier?: XOR<FeatureTierScalarRelationFilter, FeatureTierWhereInput>
  }

  export type CalculationFeatureOrderByWithRelationInput = {
    id?: SortOrder
    calculationId?: SortOrder
    featureId?: SortOrder
    tierName?: SortOrder
    count?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    calculation?: PricingCalculationOrderByWithRelationInput
    feature?: FeatureOrderByWithRelationInput
    tier?: FeatureTierOrderByWithRelationInput
  }

  export type CalculationFeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CalculationFeatureWhereInput | CalculationFeatureWhereInput[]
    OR?: CalculationFeatureWhereInput[]
    NOT?: CalculationFeatureWhereInput | CalculationFeatureWhereInput[]
    calculationId?: UuidFilter<"CalculationFeature"> | string
    featureId?: UuidFilter<"CalculationFeature"> | string
    tierName?: StringFilter<"CalculationFeature"> | string
    count?: IntFilter<"CalculationFeature"> | number
    unitPrice?: DecimalFilter<"CalculationFeature"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"CalculationFeature"> | Decimal | DecimalJsLike | number | string
    calculation?: XOR<PricingCalculationScalarRelationFilter, PricingCalculationWhereInput>
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    tier?: XOR<FeatureTierScalarRelationFilter, FeatureTierWhereInput>
  }, "id">

  export type CalculationFeatureOrderByWithAggregationInput = {
    id?: SortOrder
    calculationId?: SortOrder
    featureId?: SortOrder
    tierName?: SortOrder
    count?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    _count?: CalculationFeatureCountOrderByAggregateInput
    _avg?: CalculationFeatureAvgOrderByAggregateInput
    _max?: CalculationFeatureMaxOrderByAggregateInput
    _min?: CalculationFeatureMinOrderByAggregateInput
    _sum?: CalculationFeatureSumOrderByAggregateInput
  }

  export type CalculationFeatureScalarWhereWithAggregatesInput = {
    AND?: CalculationFeatureScalarWhereWithAggregatesInput | CalculationFeatureScalarWhereWithAggregatesInput[]
    OR?: CalculationFeatureScalarWhereWithAggregatesInput[]
    NOT?: CalculationFeatureScalarWhereWithAggregatesInput | CalculationFeatureScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CalculationFeature"> | string
    calculationId?: UuidWithAggregatesFilter<"CalculationFeature"> | string
    featureId?: UuidWithAggregatesFilter<"CalculationFeature"> | string
    tierName?: StringWithAggregatesFilter<"CalculationFeature"> | string
    count?: IntWithAggregatesFilter<"CalculationFeature"> | number
    unitPrice?: DecimalWithAggregatesFilter<"CalculationFeature"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalWithAggregatesFilter<"CalculationFeature"> | Decimal | DecimalJsLike | number | string
  }

  export type ContactInfoWhereInput = {
    AND?: ContactInfoWhereInput | ContactInfoWhereInput[]
    OR?: ContactInfoWhereInput[]
    NOT?: ContactInfoWhereInput | ContactInfoWhereInput[]
    id?: UuidFilter<"ContactInfo"> | string
    type?: StringFilter<"ContactInfo"> | string
    label?: StringFilter<"ContactInfo"> | string
    value?: JsonFilter<"ContactInfo">
    iconName?: StringFilter<"ContactInfo"> | string
    color?: StringFilter<"ContactInfo"> | string
    isActive?: BoolFilter<"ContactInfo"> | boolean
    createdAt?: DateTimeFilter<"ContactInfo"> | Date | string
  }

  export type ContactInfoOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    label?: SortOrder
    value?: SortOrder
    iconName?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactInfoWhereInput | ContactInfoWhereInput[]
    OR?: ContactInfoWhereInput[]
    NOT?: ContactInfoWhereInput | ContactInfoWhereInput[]
    type?: StringFilter<"ContactInfo"> | string
    label?: StringFilter<"ContactInfo"> | string
    value?: JsonFilter<"ContactInfo">
    iconName?: StringFilter<"ContactInfo"> | string
    color?: StringFilter<"ContactInfo"> | string
    isActive?: BoolFilter<"ContactInfo"> | boolean
    createdAt?: DateTimeFilter<"ContactInfo"> | Date | string
  }, "id">

  export type ContactInfoOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    label?: SortOrder
    value?: SortOrder
    iconName?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: ContactInfoCountOrderByAggregateInput
    _max?: ContactInfoMaxOrderByAggregateInput
    _min?: ContactInfoMinOrderByAggregateInput
  }

  export type ContactInfoScalarWhereWithAggregatesInput = {
    AND?: ContactInfoScalarWhereWithAggregatesInput | ContactInfoScalarWhereWithAggregatesInput[]
    OR?: ContactInfoScalarWhereWithAggregatesInput[]
    NOT?: ContactInfoScalarWhereWithAggregatesInput | ContactInfoScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ContactInfo"> | string
    type?: StringWithAggregatesFilter<"ContactInfo"> | string
    label?: StringWithAggregatesFilter<"ContactInfo"> | string
    value?: JsonWithAggregatesFilter<"ContactInfo">
    iconName?: StringWithAggregatesFilter<"ContactInfo"> | string
    color?: StringWithAggregatesFilter<"ContactInfo"> | string
    isActive?: BoolWithAggregatesFilter<"ContactInfo"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ContactInfo"> | Date | string
  }

  export type ProjectTypeWhereInput = {
    AND?: ProjectTypeWhereInput | ProjectTypeWhereInput[]
    OR?: ProjectTypeWhereInput[]
    NOT?: ProjectTypeWhereInput | ProjectTypeWhereInput[]
    id?: UuidFilter<"ProjectType"> | string
    value?: StringFilter<"ProjectType"> | string
    label?: StringFilter<"ProjectType"> | string
    description?: StringNullableFilter<"ProjectType"> | string | null
    isActive?: BoolFilter<"ProjectType"> | boolean
    createdAt?: DateTimeFilter<"ProjectType"> | Date | string
  }

  export type ProjectTypeOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    value?: string
    AND?: ProjectTypeWhereInput | ProjectTypeWhereInput[]
    OR?: ProjectTypeWhereInput[]
    NOT?: ProjectTypeWhereInput | ProjectTypeWhereInput[]
    label?: StringFilter<"ProjectType"> | string
    description?: StringNullableFilter<"ProjectType"> | string | null
    isActive?: BoolFilter<"ProjectType"> | boolean
    createdAt?: DateTimeFilter<"ProjectType"> | Date | string
  }, "id" | "value">

  export type ProjectTypeOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: ProjectTypeCountOrderByAggregateInput
    _max?: ProjectTypeMaxOrderByAggregateInput
    _min?: ProjectTypeMinOrderByAggregateInput
  }

  export type ProjectTypeScalarWhereWithAggregatesInput = {
    AND?: ProjectTypeScalarWhereWithAggregatesInput | ProjectTypeScalarWhereWithAggregatesInput[]
    OR?: ProjectTypeScalarWhereWithAggregatesInput[]
    NOT?: ProjectTypeScalarWhereWithAggregatesInput | ProjectTypeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProjectType"> | string
    value?: StringWithAggregatesFilter<"ProjectType"> | string
    label?: StringWithAggregatesFilter<"ProjectType"> | string
    description?: StringNullableWithAggregatesFilter<"ProjectType"> | string | null
    isActive?: BoolWithAggregatesFilter<"ProjectType"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProjectType"> | Date | string
  }

  export type BudgetRangeWhereInput = {
    AND?: BudgetRangeWhereInput | BudgetRangeWhereInput[]
    OR?: BudgetRangeWhereInput[]
    NOT?: BudgetRangeWhereInput | BudgetRangeWhereInput[]
    id?: UuidFilter<"BudgetRange"> | string
    value?: StringFilter<"BudgetRange"> | string
    label?: StringFilter<"BudgetRange"> | string
    minAmount?: DecimalNullableFilter<"BudgetRange"> | Decimal | DecimalJsLike | number | string | null
    maxAmount?: DecimalNullableFilter<"BudgetRange"> | Decimal | DecimalJsLike | number | string | null
    displayOrder?: IntNullableFilter<"BudgetRange"> | number | null
    isActive?: BoolFilter<"BudgetRange"> | boolean
    createdAt?: DateTimeFilter<"BudgetRange"> | Date | string
  }

  export type BudgetRangeOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    minAmount?: SortOrderInput | SortOrder
    maxAmount?: SortOrderInput | SortOrder
    displayOrder?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetRangeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    value?: string
    AND?: BudgetRangeWhereInput | BudgetRangeWhereInput[]
    OR?: BudgetRangeWhereInput[]
    NOT?: BudgetRangeWhereInput | BudgetRangeWhereInput[]
    label?: StringFilter<"BudgetRange"> | string
    minAmount?: DecimalNullableFilter<"BudgetRange"> | Decimal | DecimalJsLike | number | string | null
    maxAmount?: DecimalNullableFilter<"BudgetRange"> | Decimal | DecimalJsLike | number | string | null
    displayOrder?: IntNullableFilter<"BudgetRange"> | number | null
    isActive?: BoolFilter<"BudgetRange"> | boolean
    createdAt?: DateTimeFilter<"BudgetRange"> | Date | string
  }, "id" | "value">

  export type BudgetRangeOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    minAmount?: SortOrderInput | SortOrder
    maxAmount?: SortOrderInput | SortOrder
    displayOrder?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: BudgetRangeCountOrderByAggregateInput
    _avg?: BudgetRangeAvgOrderByAggregateInput
    _max?: BudgetRangeMaxOrderByAggregateInput
    _min?: BudgetRangeMinOrderByAggregateInput
    _sum?: BudgetRangeSumOrderByAggregateInput
  }

  export type BudgetRangeScalarWhereWithAggregatesInput = {
    AND?: BudgetRangeScalarWhereWithAggregatesInput | BudgetRangeScalarWhereWithAggregatesInput[]
    OR?: BudgetRangeScalarWhereWithAggregatesInput[]
    NOT?: BudgetRangeScalarWhereWithAggregatesInput | BudgetRangeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BudgetRange"> | string
    value?: StringWithAggregatesFilter<"BudgetRange"> | string
    label?: StringWithAggregatesFilter<"BudgetRange"> | string
    minAmount?: DecimalNullableWithAggregatesFilter<"BudgetRange"> | Decimal | DecimalJsLike | number | string | null
    maxAmount?: DecimalNullableWithAggregatesFilter<"BudgetRange"> | Decimal | DecimalJsLike | number | string | null
    displayOrder?: IntNullableWithAggregatesFilter<"BudgetRange"> | number | null
    isActive?: BoolWithAggregatesFilter<"BudgetRange"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BudgetRange"> | Date | string
  }

  export type TimelineOptionWhereInput = {
    AND?: TimelineOptionWhereInput | TimelineOptionWhereInput[]
    OR?: TimelineOptionWhereInput[]
    NOT?: TimelineOptionWhereInput | TimelineOptionWhereInput[]
    id?: UuidFilter<"TimelineOption"> | string
    value?: StringFilter<"TimelineOption"> | string
    label?: StringFilter<"TimelineOption"> | string
    description?: StringNullableFilter<"TimelineOption"> | string | null
    displayOrder?: IntNullableFilter<"TimelineOption"> | number | null
    isActive?: BoolFilter<"TimelineOption"> | boolean
    createdAt?: DateTimeFilter<"TimelineOption"> | Date | string
  }

  export type TimelineOptionOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    displayOrder?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type TimelineOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    value?: string
    AND?: TimelineOptionWhereInput | TimelineOptionWhereInput[]
    OR?: TimelineOptionWhereInput[]
    NOT?: TimelineOptionWhereInput | TimelineOptionWhereInput[]
    label?: StringFilter<"TimelineOption"> | string
    description?: StringNullableFilter<"TimelineOption"> | string | null
    displayOrder?: IntNullableFilter<"TimelineOption"> | number | null
    isActive?: BoolFilter<"TimelineOption"> | boolean
    createdAt?: DateTimeFilter<"TimelineOption"> | Date | string
  }, "id" | "value">

  export type TimelineOptionOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    displayOrder?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: TimelineOptionCountOrderByAggregateInput
    _avg?: TimelineOptionAvgOrderByAggregateInput
    _max?: TimelineOptionMaxOrderByAggregateInput
    _min?: TimelineOptionMinOrderByAggregateInput
    _sum?: TimelineOptionSumOrderByAggregateInput
  }

  export type TimelineOptionScalarWhereWithAggregatesInput = {
    AND?: TimelineOptionScalarWhereWithAggregatesInput | TimelineOptionScalarWhereWithAggregatesInput[]
    OR?: TimelineOptionScalarWhereWithAggregatesInput[]
    NOT?: TimelineOptionScalarWhereWithAggregatesInput | TimelineOptionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TimelineOption"> | string
    value?: StringWithAggregatesFilter<"TimelineOption"> | string
    label?: StringWithAggregatesFilter<"TimelineOption"> | string
    description?: StringNullableWithAggregatesFilter<"TimelineOption"> | string | null
    displayOrder?: IntNullableWithAggregatesFilter<"TimelineOption"> | number | null
    isActive?: BoolWithAggregatesFilter<"TimelineOption"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TimelineOption"> | Date | string
  }

  export type PackageOptionWhereInput = {
    AND?: PackageOptionWhereInput | PackageOptionWhereInput[]
    OR?: PackageOptionWhereInput[]
    NOT?: PackageOptionWhereInput | PackageOptionWhereInput[]
    id?: UuidFilter<"PackageOption"> | string
    value?: StringFilter<"PackageOption"> | string
    label?: StringFilter<"PackageOption"> | string
    description?: StringNullableFilter<"PackageOption"> | string | null
    displayOrder?: IntNullableFilter<"PackageOption"> | number | null
    isActive?: BoolFilter<"PackageOption"> | boolean
    createdAt?: DateTimeFilter<"PackageOption"> | Date | string
  }

  export type PackageOptionOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    displayOrder?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PackageOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    value?: string
    AND?: PackageOptionWhereInput | PackageOptionWhereInput[]
    OR?: PackageOptionWhereInput[]
    NOT?: PackageOptionWhereInput | PackageOptionWhereInput[]
    label?: StringFilter<"PackageOption"> | string
    description?: StringNullableFilter<"PackageOption"> | string | null
    displayOrder?: IntNullableFilter<"PackageOption"> | number | null
    isActive?: BoolFilter<"PackageOption"> | boolean
    createdAt?: DateTimeFilter<"PackageOption"> | Date | string
  }, "id" | "value">

  export type PackageOptionOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    description?: SortOrderInput | SortOrder
    displayOrder?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: PackageOptionCountOrderByAggregateInput
    _avg?: PackageOptionAvgOrderByAggregateInput
    _max?: PackageOptionMaxOrderByAggregateInput
    _min?: PackageOptionMinOrderByAggregateInput
    _sum?: PackageOptionSumOrderByAggregateInput
  }

  export type PackageOptionScalarWhereWithAggregatesInput = {
    AND?: PackageOptionScalarWhereWithAggregatesInput | PackageOptionScalarWhereWithAggregatesInput[]
    OR?: PackageOptionScalarWhereWithAggregatesInput[]
    NOT?: PackageOptionScalarWhereWithAggregatesInput | PackageOptionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PackageOption"> | string
    value?: StringWithAggregatesFilter<"PackageOption"> | string
    label?: StringWithAggregatesFilter<"PackageOption"> | string
    description?: StringNullableWithAggregatesFilter<"PackageOption"> | string | null
    displayOrder?: IntNullableWithAggregatesFilter<"PackageOption"> | number | null
    isActive?: BoolWithAggregatesFilter<"PackageOption"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PackageOption"> | Date | string
  }

  export type MigrationLogWhereInput = {
    AND?: MigrationLogWhereInput | MigrationLogWhereInput[]
    OR?: MigrationLogWhereInput[]
    NOT?: MigrationLogWhereInput | MigrationLogWhereInput[]
    id?: UuidFilter<"MigrationLog"> | string
    migrationPhase?: StringFilter<"MigrationLog"> | string
    entityType?: StringFilter<"MigrationLog"> | string
    entityId?: UuidNullableFilter<"MigrationLog"> | string | null
    operation?: StringFilter<"MigrationLog"> | string
    oldValues?: JsonNullableFilter<"MigrationLog">
    newValues?: JsonNullableFilter<"MigrationLog">
    validationResult?: JsonNullableFilter<"MigrationLog">
    status?: StringFilter<"MigrationLog"> | string
    errorMessage?: StringNullableFilter<"MigrationLog"> | string | null
    createdAt?: DateTimeFilter<"MigrationLog"> | Date | string
  }

  export type MigrationLogOrderByWithRelationInput = {
    id?: SortOrder
    migrationPhase?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    operation?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    validationResult?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type MigrationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MigrationLogWhereInput | MigrationLogWhereInput[]
    OR?: MigrationLogWhereInput[]
    NOT?: MigrationLogWhereInput | MigrationLogWhereInput[]
    migrationPhase?: StringFilter<"MigrationLog"> | string
    entityType?: StringFilter<"MigrationLog"> | string
    entityId?: UuidNullableFilter<"MigrationLog"> | string | null
    operation?: StringFilter<"MigrationLog"> | string
    oldValues?: JsonNullableFilter<"MigrationLog">
    newValues?: JsonNullableFilter<"MigrationLog">
    validationResult?: JsonNullableFilter<"MigrationLog">
    status?: StringFilter<"MigrationLog"> | string
    errorMessage?: StringNullableFilter<"MigrationLog"> | string | null
    createdAt?: DateTimeFilter<"MigrationLog"> | Date | string
  }, "id">

  export type MigrationLogOrderByWithAggregationInput = {
    id?: SortOrder
    migrationPhase?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    operation?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    validationResult?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MigrationLogCountOrderByAggregateInput
    _max?: MigrationLogMaxOrderByAggregateInput
    _min?: MigrationLogMinOrderByAggregateInput
  }

  export type MigrationLogScalarWhereWithAggregatesInput = {
    AND?: MigrationLogScalarWhereWithAggregatesInput | MigrationLogScalarWhereWithAggregatesInput[]
    OR?: MigrationLogScalarWhereWithAggregatesInput[]
    NOT?: MigrationLogScalarWhereWithAggregatesInput | MigrationLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MigrationLog"> | string
    migrationPhase?: StringWithAggregatesFilter<"MigrationLog"> | string
    entityType?: StringWithAggregatesFilter<"MigrationLog"> | string
    entityId?: UuidNullableWithAggregatesFilter<"MigrationLog"> | string | null
    operation?: StringWithAggregatesFilter<"MigrationLog"> | string
    oldValues?: JsonNullableWithAggregatesFilter<"MigrationLog">
    newValues?: JsonNullableWithAggregatesFilter<"MigrationLog">
    validationResult?: JsonNullableWithAggregatesFilter<"MigrationLog">
    status?: StringWithAggregatesFilter<"MigrationLog"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"MigrationLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MigrationLog"> | Date | string
  }

  export type SystemAuditWhereInput = {
    AND?: SystemAuditWhereInput | SystemAuditWhereInput[]
    OR?: SystemAuditWhereInput[]
    NOT?: SystemAuditWhereInput | SystemAuditWhereInput[]
    id?: UuidFilter<"SystemAudit"> | string
    tableName?: StringFilter<"SystemAudit"> | string
    recordId?: UuidFilter<"SystemAudit"> | string
    operation?: StringFilter<"SystemAudit"> | string
    oldValues?: JsonNullableFilter<"SystemAudit">
    newValues?: JsonNullableFilter<"SystemAudit">
    userId?: StringNullableFilter<"SystemAudit"> | string | null
    userAgent?: StringNullableFilter<"SystemAudit"> | string | null
    ipAddress?: StringNullableFilter<"SystemAudit"> | string | null
    createdAt?: DateTimeFilter<"SystemAudit"> | Date | string
  }

  export type SystemAuditOrderByWithRelationInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operation?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type SystemAuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemAuditWhereInput | SystemAuditWhereInput[]
    OR?: SystemAuditWhereInput[]
    NOT?: SystemAuditWhereInput | SystemAuditWhereInput[]
    tableName?: StringFilter<"SystemAudit"> | string
    recordId?: UuidFilter<"SystemAudit"> | string
    operation?: StringFilter<"SystemAudit"> | string
    oldValues?: JsonNullableFilter<"SystemAudit">
    newValues?: JsonNullableFilter<"SystemAudit">
    userId?: StringNullableFilter<"SystemAudit"> | string | null
    userAgent?: StringNullableFilter<"SystemAudit"> | string | null
    ipAddress?: StringNullableFilter<"SystemAudit"> | string | null
    createdAt?: DateTimeFilter<"SystemAudit"> | Date | string
  }, "id">

  export type SystemAuditOrderByWithAggregationInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operation?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SystemAuditCountOrderByAggregateInput
    _max?: SystemAuditMaxOrderByAggregateInput
    _min?: SystemAuditMinOrderByAggregateInput
  }

  export type SystemAuditScalarWhereWithAggregatesInput = {
    AND?: SystemAuditScalarWhereWithAggregatesInput | SystemAuditScalarWhereWithAggregatesInput[]
    OR?: SystemAuditScalarWhereWithAggregatesInput[]
    NOT?: SystemAuditScalarWhereWithAggregatesInput | SystemAuditScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SystemAudit"> | string
    tableName?: StringWithAggregatesFilter<"SystemAudit"> | string
    recordId?: UuidWithAggregatesFilter<"SystemAudit"> | string
    operation?: StringWithAggregatesFilter<"SystemAudit"> | string
    oldValues?: JsonNullableWithAggregatesFilter<"SystemAudit">
    newValues?: JsonNullableWithAggregatesFilter<"SystemAudit">
    userId?: StringNullableWithAggregatesFilter<"SystemAudit"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"SystemAudit"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"SystemAudit"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemAudit"> | Date | string
  }

  export type FeatureFlagWhereInput = {
    AND?: FeatureFlagWhereInput | FeatureFlagWhereInput[]
    OR?: FeatureFlagWhereInput[]
    NOT?: FeatureFlagWhereInput | FeatureFlagWhereInput[]
    id?: UuidFilter<"FeatureFlag"> | string
    name?: StringFilter<"FeatureFlag"> | string
    description?: StringNullableFilter<"FeatureFlag"> | string | null
    isEnabled?: BoolFilter<"FeatureFlag"> | boolean
    rolloutPercentage?: DecimalFilter<"FeatureFlag"> | Decimal | DecimalJsLike | number | string
    conditions?: JsonNullableFilter<"FeatureFlag">
    createdAt?: DateTimeFilter<"FeatureFlag"> | Date | string
    updatedAt?: DateTimeFilter<"FeatureFlag"> | Date | string
  }

  export type FeatureFlagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    rolloutPercentage?: SortOrder
    conditions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureFlagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: FeatureFlagWhereInput | FeatureFlagWhereInput[]
    OR?: FeatureFlagWhereInput[]
    NOT?: FeatureFlagWhereInput | FeatureFlagWhereInput[]
    description?: StringNullableFilter<"FeatureFlag"> | string | null
    isEnabled?: BoolFilter<"FeatureFlag"> | boolean
    rolloutPercentage?: DecimalFilter<"FeatureFlag"> | Decimal | DecimalJsLike | number | string
    conditions?: JsonNullableFilter<"FeatureFlag">
    createdAt?: DateTimeFilter<"FeatureFlag"> | Date | string
    updatedAt?: DateTimeFilter<"FeatureFlag"> | Date | string
  }, "id" | "name">

  export type FeatureFlagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    rolloutPercentage?: SortOrder
    conditions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeatureFlagCountOrderByAggregateInput
    _avg?: FeatureFlagAvgOrderByAggregateInput
    _max?: FeatureFlagMaxOrderByAggregateInput
    _min?: FeatureFlagMinOrderByAggregateInput
    _sum?: FeatureFlagSumOrderByAggregateInput
  }

  export type FeatureFlagScalarWhereWithAggregatesInput = {
    AND?: FeatureFlagScalarWhereWithAggregatesInput | FeatureFlagScalarWhereWithAggregatesInput[]
    OR?: FeatureFlagScalarWhereWithAggregatesInput[]
    NOT?: FeatureFlagScalarWhereWithAggregatesInput | FeatureFlagScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FeatureFlag"> | string
    name?: StringWithAggregatesFilter<"FeatureFlag"> | string
    description?: StringNullableWithAggregatesFilter<"FeatureFlag"> | string | null
    isEnabled?: BoolWithAggregatesFilter<"FeatureFlag"> | boolean
    rolloutPercentage?: DecimalWithAggregatesFilter<"FeatureFlag"> | Decimal | DecimalJsLike | number | string
    conditions?: JsonNullableWithAggregatesFilter<"FeatureFlag">
    createdAt?: DateTimeWithAggregatesFilter<"FeatureFlag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeatureFlag"> | Date | string
  }

  export type FeatureGroupCreateInput = {
    id?: string
    name: string
    description?: string | null
    iconName?: string | null
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: FeatureCreateNestedManyWithoutGroupInput
  }

  export type FeatureGroupUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    iconName?: string | null
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: FeatureUncheckedCreateNestedManyWithoutGroupInput
  }

  export type FeatureGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: FeatureUpdateManyWithoutGroupNestedInput
  }

  export type FeatureGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: FeatureUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type FeatureGroupCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    iconName?: string | null
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureCreateInput = {
    id?: string
    name: string
    description?: string | null
    explanation?: string | null
    isCountable?: boolean
    minCount?: number
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaults?: BusinessTypeDefaultCreateNestedManyWithoutFeatureInput
    calculations?: CalculationFeatureCreateNestedManyWithoutFeatureInput
    tiers?: FeatureTierCreateNestedManyWithoutFeatureInput
    group: FeatureGroupCreateNestedOneWithoutFeaturesInput
  }

  export type FeatureUncheckedCreateInput = {
    id?: string
    groupId: string
    name: string
    description?: string | null
    explanation?: string | null
    isCountable?: boolean
    minCount?: number
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaults?: BusinessTypeDefaultUncheckedCreateNestedManyWithoutFeatureInput
    calculations?: CalculationFeatureUncheckedCreateNestedManyWithoutFeatureInput
    tiers?: FeatureTierUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isCountable?: BoolFieldUpdateOperationsInput | boolean
    minCount?: IntFieldUpdateOperationsInput | number
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaults?: BusinessTypeDefaultUpdateManyWithoutFeatureNestedInput
    calculations?: CalculationFeatureUpdateManyWithoutFeatureNestedInput
    tiers?: FeatureTierUpdateManyWithoutFeatureNestedInput
    group?: FeatureGroupUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type FeatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isCountable?: BoolFieldUpdateOperationsInput | boolean
    minCount?: IntFieldUpdateOperationsInput | number
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaults?: BusinessTypeDefaultUncheckedUpdateManyWithoutFeatureNestedInput
    calculations?: CalculationFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    tiers?: FeatureTierUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureCreateManyInput = {
    id?: string
    groupId: string
    name: string
    description?: string | null
    explanation?: string | null
    isCountable?: boolean
    minCount?: number
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isCountable?: BoolFieldUpdateOperationsInput | boolean
    minCount?: IntFieldUpdateOperationsInput | number
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isCountable?: BoolFieldUpdateOperationsInput | boolean
    minCount?: IntFieldUpdateOperationsInput | number
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureTierCreateInput = {
    id?: string
    tierName: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    calculations?: CalculationFeatureCreateNestedManyWithoutTierInput
    feature: FeatureCreateNestedOneWithoutTiersInput
  }

  export type FeatureTierUncheckedCreateInput = {
    id?: string
    featureId: string
    tierName: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    calculations?: CalculationFeatureUncheckedCreateNestedManyWithoutTierInput
  }

  export type FeatureTierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculations?: CalculationFeatureUpdateManyWithoutTierNestedInput
    feature?: FeatureUpdateOneRequiredWithoutTiersNestedInput
  }

  export type FeatureTierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureId?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculations?: CalculationFeatureUncheckedUpdateManyWithoutTierNestedInput
  }

  export type FeatureTierCreateManyInput = {
    id?: string
    featureId: string
    tierName: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureTierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureTierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureId?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    timelineDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaults?: BusinessTypeDefaultCreateNestedManyWithoutBusinessTypeInput
    pages?: BusinessTypePageCreateNestedManyWithoutBusinessTypeInput
    calculations?: PricingCalculationCreateNestedManyWithoutBusinessTypeInput
  }

  export type BusinessTypeUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    timelineDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaults?: BusinessTypeDefaultUncheckedCreateNestedManyWithoutBusinessTypeInput
    pages?: BusinessTypePageUncheckedCreateNestedManyWithoutBusinessTypeInput
    calculations?: PricingCalculationUncheckedCreateNestedManyWithoutBusinessTypeInput
  }

  export type BusinessTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timelineDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaults?: BusinessTypeDefaultUpdateManyWithoutBusinessTypeNestedInput
    pages?: BusinessTypePageUpdateManyWithoutBusinessTypeNestedInput
    calculations?: PricingCalculationUpdateManyWithoutBusinessTypeNestedInput
  }

  export type BusinessTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timelineDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaults?: BusinessTypeDefaultUncheckedUpdateManyWithoutBusinessTypeNestedInput
    pages?: BusinessTypePageUncheckedUpdateManyWithoutBusinessTypeNestedInput
    calculations?: PricingCalculationUncheckedUpdateManyWithoutBusinessTypeNestedInput
  }

  export type BusinessTypeCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    timelineDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timelineDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timelineDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeDefaultCreateInput = {
    id?: string
    defaultTier: string
    defaultCount?: number
    createdAt?: Date | string
    businessType: BusinessTypeCreateNestedOneWithoutDefaultsInput
    feature: FeatureCreateNestedOneWithoutDefaultsInput
  }

  export type BusinessTypeDefaultUncheckedCreateInput = {
    id?: string
    businessTypeId: string
    featureId: string
    defaultTier: string
    defaultCount?: number
    createdAt?: Date | string
  }

  export type BusinessTypeDefaultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultTier?: StringFieldUpdateOperationsInput | string
    defaultCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessType?: BusinessTypeUpdateOneRequiredWithoutDefaultsNestedInput
    feature?: FeatureUpdateOneRequiredWithoutDefaultsNestedInput
  }

  export type BusinessTypeDefaultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    featureId?: StringFieldUpdateOperationsInput | string
    defaultTier?: StringFieldUpdateOperationsInput | string
    defaultCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeDefaultCreateManyInput = {
    id?: string
    businessTypeId: string
    featureId: string
    defaultTier: string
    defaultCount?: number
    createdAt?: Date | string
  }

  export type BusinessTypeDefaultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultTier?: StringFieldUpdateOperationsInput | string
    defaultCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeDefaultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    featureId?: StringFieldUpdateOperationsInput | string
    defaultTier?: StringFieldUpdateOperationsInput | string
    defaultCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypePageCreateInput = {
    id?: string
    pageType: string
    pageName: string
    isDefault?: boolean
    displayOrder?: number | null
    createdAt?: Date | string
    businessType: BusinessTypeCreateNestedOneWithoutPagesInput
  }

  export type BusinessTypePageUncheckedCreateInput = {
    id?: string
    businessTypeId: string
    pageType: string
    pageName: string
    isDefault?: boolean
    displayOrder?: number | null
    createdAt?: Date | string
  }

  export type BusinessTypePageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageType?: StringFieldUpdateOperationsInput | string
    pageName?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessType?: BusinessTypeUpdateOneRequiredWithoutPagesNestedInput
  }

  export type BusinessTypePageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    pageType?: StringFieldUpdateOperationsInput | string
    pageName?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypePageCreateManyInput = {
    id?: string
    businessTypeId: string
    pageType: string
    pageName: string
    isDefault?: boolean
    displayOrder?: number | null
    createdAt?: Date | string
  }

  export type BusinessTypePageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageType?: StringFieldUpdateOperationsInput | string
    pageName?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypePageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    pageType?: StringFieldUpdateOperationsInput | string
    pageName?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    services?: ServiceCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
  }

  export type ServiceCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceMin?: Decimal | DecimalJsLike | number | string | null
    priceMax?: Decimal | DecimalJsLike | number | string | null
    demoUrl?: string | null
    iconName?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ServiceCategoryCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    categoryId: string
    priceMin?: Decimal | DecimalJsLike | number | string | null
    priceMax?: Decimal | DecimalJsLike | number | string | null
    demoUrl?: string | null
    iconName?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    priceMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    categoryId: string
    priceMin?: Decimal | DecimalJsLike | number | string | null
    priceMax?: Decimal | DecimalJsLike | number | string | null
    demoUrl?: string | null
    iconName?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    priceMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    company?: string | null
    projectType?: string | null
    budgetRange?: string | null
    timeline?: string | null
    description?: string | null
    preferredPackage?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formSteps?: ContactFormStepCreateNestedManyWithoutContactInput
    calculations?: PricingCalculationCreateNestedManyWithoutContactInput
    timeSlots?: TimeSlotCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    company?: string | null
    projectType?: string | null
    budgetRange?: string | null
    timeline?: string | null
    description?: string | null
    preferredPackage?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formSteps?: ContactFormStepUncheckedCreateNestedManyWithoutContactInput
    calculations?: PricingCalculationUncheckedCreateNestedManyWithoutContactInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preferredPackage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formSteps?: ContactFormStepUpdateManyWithoutContactNestedInput
    calculations?: PricingCalculationUpdateManyWithoutContactNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preferredPackage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formSteps?: ContactFormStepUncheckedUpdateManyWithoutContactNestedInput
    calculations?: PricingCalculationUncheckedUpdateManyWithoutContactNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    company?: string | null
    projectType?: string | null
    budgetRange?: string | null
    timeline?: string | null
    description?: string | null
    preferredPackage?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preferredPackage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preferredPackage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeSlotCreateInput = {
    id?: string
    date: Date | string
    time: Date | string
    isAvailable?: boolean
    createdAt?: Date | string
    contact?: ContactCreateNestedOneWithoutTimeSlotsInput
  }

  export type TimeSlotUncheckedCreateInput = {
    id?: string
    date: Date | string
    time: Date | string
    isAvailable?: boolean
    contactId?: string | null
    createdAt?: Date | string
  }

  export type TimeSlotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneWithoutTimeSlotsNestedInput
  }

  export type TimeSlotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeSlotCreateManyInput = {
    id?: string
    date: Date | string
    time: Date | string
    isAvailable?: boolean
    contactId?: string | null
    createdAt?: Date | string
  }

  export type TimeSlotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeSlotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFormStepCreateInput = {
    id?: string
    stepNumber: number
    stepData: JsonNullValueInput | InputJsonValue
    completedAt: Date | string
    contact: ContactCreateNestedOneWithoutFormStepsInput
  }

  export type ContactFormStepUncheckedCreateInput = {
    id?: string
    contactId: string
    stepNumber: number
    stepData: JsonNullValueInput | InputJsonValue
    completedAt: Date | string
  }

  export type ContactFormStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    stepData?: JsonNullValueInput | InputJsonValue
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutFormStepsNestedInput
  }

  export type ContactFormStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    stepData?: JsonNullValueInput | InputJsonValue
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFormStepCreateManyInput = {
    id?: string
    contactId: string
    stepNumber: number
    stepData: JsonNullValueInput | InputJsonValue
    completedAt: Date | string
  }

  export type ContactFormStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    stepData?: JsonNullValueInput | InputJsonValue
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFormStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    stepData?: JsonNullValueInput | InputJsonValue
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingCalculationCreateInput = {
    id?: string
    sessionId?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    calculationData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    features?: CalculationFeatureCreateNestedManyWithoutCalculationInput
    businessType: BusinessTypeCreateNestedOneWithoutCalculationsInput
    contact?: ContactCreateNestedOneWithoutCalculationsInput
  }

  export type PricingCalculationUncheckedCreateInput = {
    id?: string
    sessionId?: string | null
    businessTypeId: string
    totalPrice: Decimal | DecimalJsLike | number | string
    calculationData: JsonNullValueInput | InputJsonValue
    contactId?: string | null
    createdAt?: Date | string
    features?: CalculationFeatureUncheckedCreateNestedManyWithoutCalculationInput
  }

  export type PricingCalculationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: CalculationFeatureUpdateManyWithoutCalculationNestedInput
    businessType?: BusinessTypeUpdateOneRequiredWithoutCalculationsNestedInput
    contact?: ContactUpdateOneWithoutCalculationsNestedInput
  }

  export type PricingCalculationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    businessTypeId?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationData?: JsonNullValueInput | InputJsonValue
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: CalculationFeatureUncheckedUpdateManyWithoutCalculationNestedInput
  }

  export type PricingCalculationCreateManyInput = {
    id?: string
    sessionId?: string | null
    businessTypeId: string
    totalPrice: Decimal | DecimalJsLike | number | string
    calculationData: JsonNullValueInput | InputJsonValue
    contactId?: string | null
    createdAt?: Date | string
  }

  export type PricingCalculationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingCalculationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    businessTypeId?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationData?: JsonNullValueInput | InputJsonValue
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalculationFeatureCreateInput = {
    id?: string
    count?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    calculation: PricingCalculationCreateNestedOneWithoutFeaturesInput
    feature: FeatureCreateNestedOneWithoutCalculationsInput
    tier: FeatureTierCreateNestedOneWithoutCalculationsInput
  }

  export type CalculationFeatureUncheckedCreateInput = {
    id?: string
    calculationId: string
    featureId: string
    tierName: string
    count?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type CalculationFeatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculation?: PricingCalculationUpdateOneRequiredWithoutFeaturesNestedInput
    feature?: FeatureUpdateOneRequiredWithoutCalculationsNestedInput
    tier?: FeatureTierUpdateOneRequiredWithoutCalculationsNestedInput
  }

  export type CalculationFeatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    calculationId?: StringFieldUpdateOperationsInput | string
    featureId?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CalculationFeatureCreateManyInput = {
    id?: string
    calculationId: string
    featureId: string
    tierName: string
    count?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type CalculationFeatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CalculationFeatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    calculationId?: StringFieldUpdateOperationsInput | string
    featureId?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ContactInfoCreateInput = {
    id?: string
    type: string
    label: string
    value: JsonNullValueInput | InputJsonValue
    iconName: string
    color: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ContactInfoUncheckedCreateInput = {
    id?: string
    type: string
    label: string
    value: JsonNullValueInput | InputJsonValue
    iconName: string
    color: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ContactInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    iconName?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    iconName?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInfoCreateManyInput = {
    id?: string
    type: string
    label: string
    value: JsonNullValueInput | InputJsonValue
    iconName: string
    color: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ContactInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    iconName?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    iconName?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTypeCreateInput = {
    id?: string
    value: string
    label: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ProjectTypeUncheckedCreateInput = {
    id?: string
    value: string
    label: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ProjectTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTypeCreateManyInput = {
    id?: string
    value: string
    label: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ProjectTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetRangeCreateInput = {
    id?: string
    value: string
    label: string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type BudgetRangeUncheckedCreateInput = {
    id?: string
    value: string
    label: string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type BudgetRangeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetRangeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetRangeCreateManyInput = {
    id?: string
    value: string
    label: string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type BudgetRangeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetRangeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimelineOptionCreateInput = {
    id?: string
    value: string
    label: string
    description?: string | null
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type TimelineOptionUncheckedCreateInput = {
    id?: string
    value: string
    label: string
    description?: string | null
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type TimelineOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimelineOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimelineOptionCreateManyInput = {
    id?: string
    value: string
    label: string
    description?: string | null
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type TimelineOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimelineOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageOptionCreateInput = {
    id?: string
    value: string
    label: string
    description?: string | null
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PackageOptionUncheckedCreateInput = {
    id?: string
    value: string
    label: string
    description?: string | null
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PackageOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageOptionCreateManyInput = {
    id?: string
    value: string
    label: string
    description?: string | null
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PackageOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MigrationLogCreateInput = {
    id?: string
    migrationPhase: string
    entityType: string
    entityId?: string | null
    operation: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    validationResult?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type MigrationLogUncheckedCreateInput = {
    id?: string
    migrationPhase: string
    entityType: string
    entityId?: string | null
    operation: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    validationResult?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type MigrationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    migrationPhase?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    validationResult?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MigrationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    migrationPhase?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    validationResult?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MigrationLogCreateManyInput = {
    id?: string
    migrationPhase: string
    entityType: string
    entityId?: string | null
    operation: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    validationResult?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type MigrationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    migrationPhase?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    validationResult?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MigrationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    migrationPhase?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    validationResult?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemAuditCreateInput = {
    id?: string
    tableName: string
    recordId: string
    operation: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type SystemAuditUncheckedCreateInput = {
    id?: string
    tableName: string
    recordId: string
    operation: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type SystemAuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operation?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemAuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operation?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemAuditCreateManyInput = {
    id?: string
    tableName: string
    recordId: string
    operation: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type SystemAuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operation?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemAuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operation?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagCreateInput = {
    id?: string
    name: string
    description?: string | null
    isEnabled?: boolean
    rolloutPercentage?: Decimal | DecimalJsLike | number | string
    conditions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureFlagUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isEnabled?: boolean
    rolloutPercentage?: Decimal | DecimalJsLike | number | string
    conditions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureFlagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    rolloutPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conditions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    rolloutPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conditions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isEnabled?: boolean
    rolloutPercentage?: Decimal | DecimalJsLike | number | string
    conditions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureFlagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    rolloutPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conditions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    rolloutPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conditions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FeatureListRelationFilter = {
    every?: FeatureWhereInput
    some?: FeatureWhereInput
    none?: FeatureWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type FeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeatureGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconName?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureGroupAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type FeatureGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconName?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconName?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureGroupSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BusinessTypeDefaultListRelationFilter = {
    every?: BusinessTypeDefaultWhereInput
    some?: BusinessTypeDefaultWhereInput
    none?: BusinessTypeDefaultWhereInput
  }

  export type CalculationFeatureListRelationFilter = {
    every?: CalculationFeatureWhereInput
    some?: CalculationFeatureWhereInput
    none?: CalculationFeatureWhereInput
  }

  export type FeatureTierListRelationFilter = {
    every?: FeatureTierWhereInput
    some?: FeatureTierWhereInput
    none?: FeatureTierWhereInput
  }

  export type FeatureGroupScalarRelationFilter = {
    is?: FeatureGroupWhereInput
    isNot?: FeatureGroupWhereInput
  }

  export type BusinessTypeDefaultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalculationFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeatureTierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeatureCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    explanation?: SortOrder
    isCountable?: SortOrder
    minCount?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureAvgOrderByAggregateInput = {
    minCount?: SortOrder
    displayOrder?: SortOrder
  }

  export type FeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    explanation?: SortOrder
    isCountable?: SortOrder
    minCount?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    explanation?: SortOrder
    isCountable?: SortOrder
    minCount?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureSumOrderByAggregateInput = {
    minCount?: SortOrder
    displayOrder?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type FeatureScalarRelationFilter = {
    is?: FeatureWhereInput
    isNot?: FeatureWhereInput
  }

  export type FeatureTierFeatureIdTierNameCompoundUniqueInput = {
    featureId: string
    tierName: string
  }

  export type FeatureTierCountOrderByAggregateInput = {
    id?: SortOrder
    featureId?: SortOrder
    tierName?: SortOrder
    description?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureTierAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type FeatureTierMaxOrderByAggregateInput = {
    id?: SortOrder
    featureId?: SortOrder
    tierName?: SortOrder
    description?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureTierMinOrderByAggregateInput = {
    id?: SortOrder
    featureId?: SortOrder
    tierName?: SortOrder
    description?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureTierSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BusinessTypePageListRelationFilter = {
    every?: BusinessTypePageWhereInput
    some?: BusinessTypePageWhereInput
    none?: BusinessTypePageWhereInput
  }

  export type PricingCalculationListRelationFilter = {
    every?: PricingCalculationWhereInput
    some?: PricingCalculationWhereInput
    none?: PricingCalculationWhereInput
  }

  export type BusinessTypePageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PricingCalculationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    timelineDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessTypeAvgOrderByAggregateInput = {
    basePrice?: SortOrder
    timelineDays?: SortOrder
  }

  export type BusinessTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    timelineDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    timelineDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessTypeSumOrderByAggregateInput = {
    basePrice?: SortOrder
    timelineDays?: SortOrder
  }

  export type BusinessTypeScalarRelationFilter = {
    is?: BusinessTypeWhereInput
    isNot?: BusinessTypeWhereInput
  }

  export type BusinessTypeDefaultBusinessTypeIdFeatureIdCompoundUniqueInput = {
    businessTypeId: string
    featureId: string
  }

  export type BusinessTypeDefaultCountOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    featureId?: SortOrder
    defaultTier?: SortOrder
    defaultCount?: SortOrder
    createdAt?: SortOrder
  }

  export type BusinessTypeDefaultAvgOrderByAggregateInput = {
    defaultCount?: SortOrder
  }

  export type BusinessTypeDefaultMaxOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    featureId?: SortOrder
    defaultTier?: SortOrder
    defaultCount?: SortOrder
    createdAt?: SortOrder
  }

  export type BusinessTypeDefaultMinOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    featureId?: SortOrder
    defaultTier?: SortOrder
    defaultCount?: SortOrder
    createdAt?: SortOrder
  }

  export type BusinessTypeDefaultSumOrderByAggregateInput = {
    defaultCount?: SortOrder
  }

  export type BusinessTypePageCountOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    pageType?: SortOrder
    pageName?: SortOrder
    isDefault?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type BusinessTypePageAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type BusinessTypePageMaxOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    pageType?: SortOrder
    pageName?: SortOrder
    isDefault?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type BusinessTypePageMinOrderByAggregateInput = {
    id?: SortOrder
    businessTypeId?: SortOrder
    pageType?: SortOrder
    pageName?: SortOrder
    isDefault?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type BusinessTypePageSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ServiceCategoryScalarRelationFilter = {
    is?: ServiceCategoryWhereInput
    isNot?: ServiceCategoryWhereInput
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
    demoUrl?: SortOrder
    iconName?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    priceMin?: SortOrder
    priceMax?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
    demoUrl?: SortOrder
    iconName?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
    demoUrl?: SortOrder
    iconName?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    priceMin?: SortOrder
    priceMax?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ContactFormStepListRelationFilter = {
    every?: ContactFormStepWhereInput
    some?: ContactFormStepWhereInput
    none?: ContactFormStepWhereInput
  }

  export type TimeSlotListRelationFilter = {
    every?: TimeSlotWhereInput
    some?: TimeSlotWhereInput
    none?: TimeSlotWhereInput
  }

  export type ContactFormStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimeSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    projectType?: SortOrder
    budgetRange?: SortOrder
    timeline?: SortOrder
    description?: SortOrder
    preferredPackage?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    projectType?: SortOrder
    budgetRange?: SortOrder
    timeline?: SortOrder
    description?: SortOrder
    preferredPackage?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    projectType?: SortOrder
    budgetRange?: SortOrder
    timeline?: SortOrder
    description?: SortOrder
    preferredPackage?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type ContactNullableScalarRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type TimeSlotDateTimeCompoundUniqueInput = {
    date: Date | string
    time: Date | string
  }

  export type TimeSlotCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    isAvailable?: SortOrder
    contactId?: SortOrder
    createdAt?: SortOrder
  }

  export type TimeSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    isAvailable?: SortOrder
    contactId?: SortOrder
    createdAt?: SortOrder
  }

  export type TimeSlotMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    isAvailable?: SortOrder
    contactId?: SortOrder
    createdAt?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ContactScalarRelationFilter = {
    is?: ContactWhereInput
    isNot?: ContactWhereInput
  }

  export type ContactFormStepCountOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    stepNumber?: SortOrder
    stepData?: SortOrder
    completedAt?: SortOrder
  }

  export type ContactFormStepAvgOrderByAggregateInput = {
    stepNumber?: SortOrder
  }

  export type ContactFormStepMaxOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    stepNumber?: SortOrder
    completedAt?: SortOrder
  }

  export type ContactFormStepMinOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    stepNumber?: SortOrder
    completedAt?: SortOrder
  }

  export type ContactFormStepSumOrderByAggregateInput = {
    stepNumber?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type PricingCalculationCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    businessTypeId?: SortOrder
    totalPrice?: SortOrder
    calculationData?: SortOrder
    contactId?: SortOrder
    createdAt?: SortOrder
  }

  export type PricingCalculationAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
  }

  export type PricingCalculationMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    businessTypeId?: SortOrder
    totalPrice?: SortOrder
    contactId?: SortOrder
    createdAt?: SortOrder
  }

  export type PricingCalculationMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    businessTypeId?: SortOrder
    totalPrice?: SortOrder
    contactId?: SortOrder
    createdAt?: SortOrder
  }

  export type PricingCalculationSumOrderByAggregateInput = {
    totalPrice?: SortOrder
  }

  export type PricingCalculationScalarRelationFilter = {
    is?: PricingCalculationWhereInput
    isNot?: PricingCalculationWhereInput
  }

  export type FeatureTierScalarRelationFilter = {
    is?: FeatureTierWhereInput
    isNot?: FeatureTierWhereInput
  }

  export type CalculationFeatureCountOrderByAggregateInput = {
    id?: SortOrder
    calculationId?: SortOrder
    featureId?: SortOrder
    tierName?: SortOrder
    count?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type CalculationFeatureAvgOrderByAggregateInput = {
    count?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type CalculationFeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    calculationId?: SortOrder
    featureId?: SortOrder
    tierName?: SortOrder
    count?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type CalculationFeatureMinOrderByAggregateInput = {
    id?: SortOrder
    calculationId?: SortOrder
    featureId?: SortOrder
    tierName?: SortOrder
    count?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type CalculationFeatureSumOrderByAggregateInput = {
    count?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type ContactInfoCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    label?: SortOrder
    value?: SortOrder
    iconName?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    label?: SortOrder
    iconName?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactInfoMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    label?: SortOrder
    iconName?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectTypeCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectTypeMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetRangeCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetRangeAvgOrderByAggregateInput = {
    minAmount?: SortOrder
    maxAmount?: SortOrder
    displayOrder?: SortOrder
  }

  export type BudgetRangeMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetRangeMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetRangeSumOrderByAggregateInput = {
    minAmount?: SortOrder
    maxAmount?: SortOrder
    displayOrder?: SortOrder
  }

  export type TimelineOptionCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type TimelineOptionAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type TimelineOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type TimelineOptionMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type TimelineOptionSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type PackageOptionCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PackageOptionAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type PackageOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PackageOptionMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PackageOptionSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MigrationLogCountOrderByAggregateInput = {
    id?: SortOrder
    migrationPhase?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    operation?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    validationResult?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type MigrationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    migrationPhase?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    operation?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type MigrationLogMinOrderByAggregateInput = {
    id?: SortOrder
    migrationPhase?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    operation?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type SystemAuditCountOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operation?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    userId?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemAuditMaxOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operation?: SortOrder
    userId?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemAuditMinOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operation?: SortOrder
    userId?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type FeatureFlagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isEnabled?: SortOrder
    rolloutPercentage?: SortOrder
    conditions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureFlagAvgOrderByAggregateInput = {
    rolloutPercentage?: SortOrder
  }

  export type FeatureFlagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isEnabled?: SortOrder
    rolloutPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureFlagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isEnabled?: SortOrder
    rolloutPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureFlagSumOrderByAggregateInput = {
    rolloutPercentage?: SortOrder
  }

  export type FeatureCreateNestedManyWithoutGroupInput = {
    create?: XOR<FeatureCreateWithoutGroupInput, FeatureUncheckedCreateWithoutGroupInput> | FeatureCreateWithoutGroupInput[] | FeatureUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutGroupInput | FeatureCreateOrConnectWithoutGroupInput[]
    createMany?: FeatureCreateManyGroupInputEnvelope
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
  }

  export type FeatureUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<FeatureCreateWithoutGroupInput, FeatureUncheckedCreateWithoutGroupInput> | FeatureCreateWithoutGroupInput[] | FeatureUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutGroupInput | FeatureCreateOrConnectWithoutGroupInput[]
    createMany?: FeatureCreateManyGroupInputEnvelope
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FeatureUpdateManyWithoutGroupNestedInput = {
    create?: XOR<FeatureCreateWithoutGroupInput, FeatureUncheckedCreateWithoutGroupInput> | FeatureCreateWithoutGroupInput[] | FeatureUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutGroupInput | FeatureCreateOrConnectWithoutGroupInput[]
    upsert?: FeatureUpsertWithWhereUniqueWithoutGroupInput | FeatureUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: FeatureCreateManyGroupInputEnvelope
    set?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    disconnect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    delete?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    update?: FeatureUpdateWithWhereUniqueWithoutGroupInput | FeatureUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: FeatureUpdateManyWithWhereWithoutGroupInput | FeatureUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: FeatureScalarWhereInput | FeatureScalarWhereInput[]
  }

  export type FeatureUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<FeatureCreateWithoutGroupInput, FeatureUncheckedCreateWithoutGroupInput> | FeatureCreateWithoutGroupInput[] | FeatureUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutGroupInput | FeatureCreateOrConnectWithoutGroupInput[]
    upsert?: FeatureUpsertWithWhereUniqueWithoutGroupInput | FeatureUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: FeatureCreateManyGroupInputEnvelope
    set?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    disconnect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    delete?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    update?: FeatureUpdateWithWhereUniqueWithoutGroupInput | FeatureUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: FeatureUpdateManyWithWhereWithoutGroupInput | FeatureUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: FeatureScalarWhereInput | FeatureScalarWhereInput[]
  }

  export type BusinessTypeDefaultCreateNestedManyWithoutFeatureInput = {
    create?: XOR<BusinessTypeDefaultCreateWithoutFeatureInput, BusinessTypeDefaultUncheckedCreateWithoutFeatureInput> | BusinessTypeDefaultCreateWithoutFeatureInput[] | BusinessTypeDefaultUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: BusinessTypeDefaultCreateOrConnectWithoutFeatureInput | BusinessTypeDefaultCreateOrConnectWithoutFeatureInput[]
    createMany?: BusinessTypeDefaultCreateManyFeatureInputEnvelope
    connect?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
  }

  export type CalculationFeatureCreateNestedManyWithoutFeatureInput = {
    create?: XOR<CalculationFeatureCreateWithoutFeatureInput, CalculationFeatureUncheckedCreateWithoutFeatureInput> | CalculationFeatureCreateWithoutFeatureInput[] | CalculationFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: CalculationFeatureCreateOrConnectWithoutFeatureInput | CalculationFeatureCreateOrConnectWithoutFeatureInput[]
    createMany?: CalculationFeatureCreateManyFeatureInputEnvelope
    connect?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
  }

  export type FeatureTierCreateNestedManyWithoutFeatureInput = {
    create?: XOR<FeatureTierCreateWithoutFeatureInput, FeatureTierUncheckedCreateWithoutFeatureInput> | FeatureTierCreateWithoutFeatureInput[] | FeatureTierUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: FeatureTierCreateOrConnectWithoutFeatureInput | FeatureTierCreateOrConnectWithoutFeatureInput[]
    createMany?: FeatureTierCreateManyFeatureInputEnvelope
    connect?: FeatureTierWhereUniqueInput | FeatureTierWhereUniqueInput[]
  }

  export type FeatureGroupCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<FeatureGroupCreateWithoutFeaturesInput, FeatureGroupUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: FeatureGroupCreateOrConnectWithoutFeaturesInput
    connect?: FeatureGroupWhereUniqueInput
  }

  export type BusinessTypeDefaultUncheckedCreateNestedManyWithoutFeatureInput = {
    create?: XOR<BusinessTypeDefaultCreateWithoutFeatureInput, BusinessTypeDefaultUncheckedCreateWithoutFeatureInput> | BusinessTypeDefaultCreateWithoutFeatureInput[] | BusinessTypeDefaultUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: BusinessTypeDefaultCreateOrConnectWithoutFeatureInput | BusinessTypeDefaultCreateOrConnectWithoutFeatureInput[]
    createMany?: BusinessTypeDefaultCreateManyFeatureInputEnvelope
    connect?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
  }

  export type CalculationFeatureUncheckedCreateNestedManyWithoutFeatureInput = {
    create?: XOR<CalculationFeatureCreateWithoutFeatureInput, CalculationFeatureUncheckedCreateWithoutFeatureInput> | CalculationFeatureCreateWithoutFeatureInput[] | CalculationFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: CalculationFeatureCreateOrConnectWithoutFeatureInput | CalculationFeatureCreateOrConnectWithoutFeatureInput[]
    createMany?: CalculationFeatureCreateManyFeatureInputEnvelope
    connect?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
  }

  export type FeatureTierUncheckedCreateNestedManyWithoutFeatureInput = {
    create?: XOR<FeatureTierCreateWithoutFeatureInput, FeatureTierUncheckedCreateWithoutFeatureInput> | FeatureTierCreateWithoutFeatureInput[] | FeatureTierUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: FeatureTierCreateOrConnectWithoutFeatureInput | FeatureTierCreateOrConnectWithoutFeatureInput[]
    createMany?: FeatureTierCreateManyFeatureInputEnvelope
    connect?: FeatureTierWhereUniqueInput | FeatureTierWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BusinessTypeDefaultUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<BusinessTypeDefaultCreateWithoutFeatureInput, BusinessTypeDefaultUncheckedCreateWithoutFeatureInput> | BusinessTypeDefaultCreateWithoutFeatureInput[] | BusinessTypeDefaultUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: BusinessTypeDefaultCreateOrConnectWithoutFeatureInput | BusinessTypeDefaultCreateOrConnectWithoutFeatureInput[]
    upsert?: BusinessTypeDefaultUpsertWithWhereUniqueWithoutFeatureInput | BusinessTypeDefaultUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: BusinessTypeDefaultCreateManyFeatureInputEnvelope
    set?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
    disconnect?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
    delete?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
    connect?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
    update?: BusinessTypeDefaultUpdateWithWhereUniqueWithoutFeatureInput | BusinessTypeDefaultUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: BusinessTypeDefaultUpdateManyWithWhereWithoutFeatureInput | BusinessTypeDefaultUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: BusinessTypeDefaultScalarWhereInput | BusinessTypeDefaultScalarWhereInput[]
  }

  export type CalculationFeatureUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<CalculationFeatureCreateWithoutFeatureInput, CalculationFeatureUncheckedCreateWithoutFeatureInput> | CalculationFeatureCreateWithoutFeatureInput[] | CalculationFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: CalculationFeatureCreateOrConnectWithoutFeatureInput | CalculationFeatureCreateOrConnectWithoutFeatureInput[]
    upsert?: CalculationFeatureUpsertWithWhereUniqueWithoutFeatureInput | CalculationFeatureUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: CalculationFeatureCreateManyFeatureInputEnvelope
    set?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    disconnect?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    delete?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    connect?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    update?: CalculationFeatureUpdateWithWhereUniqueWithoutFeatureInput | CalculationFeatureUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: CalculationFeatureUpdateManyWithWhereWithoutFeatureInput | CalculationFeatureUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: CalculationFeatureScalarWhereInput | CalculationFeatureScalarWhereInput[]
  }

  export type FeatureTierUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<FeatureTierCreateWithoutFeatureInput, FeatureTierUncheckedCreateWithoutFeatureInput> | FeatureTierCreateWithoutFeatureInput[] | FeatureTierUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: FeatureTierCreateOrConnectWithoutFeatureInput | FeatureTierCreateOrConnectWithoutFeatureInput[]
    upsert?: FeatureTierUpsertWithWhereUniqueWithoutFeatureInput | FeatureTierUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: FeatureTierCreateManyFeatureInputEnvelope
    set?: FeatureTierWhereUniqueInput | FeatureTierWhereUniqueInput[]
    disconnect?: FeatureTierWhereUniqueInput | FeatureTierWhereUniqueInput[]
    delete?: FeatureTierWhereUniqueInput | FeatureTierWhereUniqueInput[]
    connect?: FeatureTierWhereUniqueInput | FeatureTierWhereUniqueInput[]
    update?: FeatureTierUpdateWithWhereUniqueWithoutFeatureInput | FeatureTierUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: FeatureTierUpdateManyWithWhereWithoutFeatureInput | FeatureTierUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: FeatureTierScalarWhereInput | FeatureTierScalarWhereInput[]
  }

  export type FeatureGroupUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<FeatureGroupCreateWithoutFeaturesInput, FeatureGroupUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: FeatureGroupCreateOrConnectWithoutFeaturesInput
    upsert?: FeatureGroupUpsertWithoutFeaturesInput
    connect?: FeatureGroupWhereUniqueInput
    update?: XOR<XOR<FeatureGroupUpdateToOneWithWhereWithoutFeaturesInput, FeatureGroupUpdateWithoutFeaturesInput>, FeatureGroupUncheckedUpdateWithoutFeaturesInput>
  }

  export type BusinessTypeDefaultUncheckedUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<BusinessTypeDefaultCreateWithoutFeatureInput, BusinessTypeDefaultUncheckedCreateWithoutFeatureInput> | BusinessTypeDefaultCreateWithoutFeatureInput[] | BusinessTypeDefaultUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: BusinessTypeDefaultCreateOrConnectWithoutFeatureInput | BusinessTypeDefaultCreateOrConnectWithoutFeatureInput[]
    upsert?: BusinessTypeDefaultUpsertWithWhereUniqueWithoutFeatureInput | BusinessTypeDefaultUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: BusinessTypeDefaultCreateManyFeatureInputEnvelope
    set?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
    disconnect?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
    delete?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
    connect?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
    update?: BusinessTypeDefaultUpdateWithWhereUniqueWithoutFeatureInput | BusinessTypeDefaultUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: BusinessTypeDefaultUpdateManyWithWhereWithoutFeatureInput | BusinessTypeDefaultUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: BusinessTypeDefaultScalarWhereInput | BusinessTypeDefaultScalarWhereInput[]
  }

  export type CalculationFeatureUncheckedUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<CalculationFeatureCreateWithoutFeatureInput, CalculationFeatureUncheckedCreateWithoutFeatureInput> | CalculationFeatureCreateWithoutFeatureInput[] | CalculationFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: CalculationFeatureCreateOrConnectWithoutFeatureInput | CalculationFeatureCreateOrConnectWithoutFeatureInput[]
    upsert?: CalculationFeatureUpsertWithWhereUniqueWithoutFeatureInput | CalculationFeatureUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: CalculationFeatureCreateManyFeatureInputEnvelope
    set?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    disconnect?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    delete?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    connect?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    update?: CalculationFeatureUpdateWithWhereUniqueWithoutFeatureInput | CalculationFeatureUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: CalculationFeatureUpdateManyWithWhereWithoutFeatureInput | CalculationFeatureUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: CalculationFeatureScalarWhereInput | CalculationFeatureScalarWhereInput[]
  }

  export type FeatureTierUncheckedUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<FeatureTierCreateWithoutFeatureInput, FeatureTierUncheckedCreateWithoutFeatureInput> | FeatureTierCreateWithoutFeatureInput[] | FeatureTierUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: FeatureTierCreateOrConnectWithoutFeatureInput | FeatureTierCreateOrConnectWithoutFeatureInput[]
    upsert?: FeatureTierUpsertWithWhereUniqueWithoutFeatureInput | FeatureTierUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: FeatureTierCreateManyFeatureInputEnvelope
    set?: FeatureTierWhereUniqueInput | FeatureTierWhereUniqueInput[]
    disconnect?: FeatureTierWhereUniqueInput | FeatureTierWhereUniqueInput[]
    delete?: FeatureTierWhereUniqueInput | FeatureTierWhereUniqueInput[]
    connect?: FeatureTierWhereUniqueInput | FeatureTierWhereUniqueInput[]
    update?: FeatureTierUpdateWithWhereUniqueWithoutFeatureInput | FeatureTierUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: FeatureTierUpdateManyWithWhereWithoutFeatureInput | FeatureTierUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: FeatureTierScalarWhereInput | FeatureTierScalarWhereInput[]
  }

  export type CalculationFeatureCreateNestedManyWithoutTierInput = {
    create?: XOR<CalculationFeatureCreateWithoutTierInput, CalculationFeatureUncheckedCreateWithoutTierInput> | CalculationFeatureCreateWithoutTierInput[] | CalculationFeatureUncheckedCreateWithoutTierInput[]
    connectOrCreate?: CalculationFeatureCreateOrConnectWithoutTierInput | CalculationFeatureCreateOrConnectWithoutTierInput[]
    createMany?: CalculationFeatureCreateManyTierInputEnvelope
    connect?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
  }

  export type FeatureCreateNestedOneWithoutTiersInput = {
    create?: XOR<FeatureCreateWithoutTiersInput, FeatureUncheckedCreateWithoutTiersInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutTiersInput
    connect?: FeatureWhereUniqueInput
  }

  export type CalculationFeatureUncheckedCreateNestedManyWithoutTierInput = {
    create?: XOR<CalculationFeatureCreateWithoutTierInput, CalculationFeatureUncheckedCreateWithoutTierInput> | CalculationFeatureCreateWithoutTierInput[] | CalculationFeatureUncheckedCreateWithoutTierInput[]
    connectOrCreate?: CalculationFeatureCreateOrConnectWithoutTierInput | CalculationFeatureCreateOrConnectWithoutTierInput[]
    createMany?: CalculationFeatureCreateManyTierInputEnvelope
    connect?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CalculationFeatureUpdateManyWithoutTierNestedInput = {
    create?: XOR<CalculationFeatureCreateWithoutTierInput, CalculationFeatureUncheckedCreateWithoutTierInput> | CalculationFeatureCreateWithoutTierInput[] | CalculationFeatureUncheckedCreateWithoutTierInput[]
    connectOrCreate?: CalculationFeatureCreateOrConnectWithoutTierInput | CalculationFeatureCreateOrConnectWithoutTierInput[]
    upsert?: CalculationFeatureUpsertWithWhereUniqueWithoutTierInput | CalculationFeatureUpsertWithWhereUniqueWithoutTierInput[]
    createMany?: CalculationFeatureCreateManyTierInputEnvelope
    set?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    disconnect?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    delete?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    connect?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    update?: CalculationFeatureUpdateWithWhereUniqueWithoutTierInput | CalculationFeatureUpdateWithWhereUniqueWithoutTierInput[]
    updateMany?: CalculationFeatureUpdateManyWithWhereWithoutTierInput | CalculationFeatureUpdateManyWithWhereWithoutTierInput[]
    deleteMany?: CalculationFeatureScalarWhereInput | CalculationFeatureScalarWhereInput[]
  }

  export type FeatureUpdateOneRequiredWithoutTiersNestedInput = {
    create?: XOR<FeatureCreateWithoutTiersInput, FeatureUncheckedCreateWithoutTiersInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutTiersInput
    upsert?: FeatureUpsertWithoutTiersInput
    connect?: FeatureWhereUniqueInput
    update?: XOR<XOR<FeatureUpdateToOneWithWhereWithoutTiersInput, FeatureUpdateWithoutTiersInput>, FeatureUncheckedUpdateWithoutTiersInput>
  }

  export type CalculationFeatureUncheckedUpdateManyWithoutTierNestedInput = {
    create?: XOR<CalculationFeatureCreateWithoutTierInput, CalculationFeatureUncheckedCreateWithoutTierInput> | CalculationFeatureCreateWithoutTierInput[] | CalculationFeatureUncheckedCreateWithoutTierInput[]
    connectOrCreate?: CalculationFeatureCreateOrConnectWithoutTierInput | CalculationFeatureCreateOrConnectWithoutTierInput[]
    upsert?: CalculationFeatureUpsertWithWhereUniqueWithoutTierInput | CalculationFeatureUpsertWithWhereUniqueWithoutTierInput[]
    createMany?: CalculationFeatureCreateManyTierInputEnvelope
    set?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    disconnect?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    delete?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    connect?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    update?: CalculationFeatureUpdateWithWhereUniqueWithoutTierInput | CalculationFeatureUpdateWithWhereUniqueWithoutTierInput[]
    updateMany?: CalculationFeatureUpdateManyWithWhereWithoutTierInput | CalculationFeatureUpdateManyWithWhereWithoutTierInput[]
    deleteMany?: CalculationFeatureScalarWhereInput | CalculationFeatureScalarWhereInput[]
  }

  export type BusinessTypeDefaultCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<BusinessTypeDefaultCreateWithoutBusinessTypeInput, BusinessTypeDefaultUncheckedCreateWithoutBusinessTypeInput> | BusinessTypeDefaultCreateWithoutBusinessTypeInput[] | BusinessTypeDefaultUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessTypeDefaultCreateOrConnectWithoutBusinessTypeInput | BusinessTypeDefaultCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: BusinessTypeDefaultCreateManyBusinessTypeInputEnvelope
    connect?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
  }

  export type BusinessTypePageCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<BusinessTypePageCreateWithoutBusinessTypeInput, BusinessTypePageUncheckedCreateWithoutBusinessTypeInput> | BusinessTypePageCreateWithoutBusinessTypeInput[] | BusinessTypePageUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessTypePageCreateOrConnectWithoutBusinessTypeInput | BusinessTypePageCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: BusinessTypePageCreateManyBusinessTypeInputEnvelope
    connect?: BusinessTypePageWhereUniqueInput | BusinessTypePageWhereUniqueInput[]
  }

  export type PricingCalculationCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<PricingCalculationCreateWithoutBusinessTypeInput, PricingCalculationUncheckedCreateWithoutBusinessTypeInput> | PricingCalculationCreateWithoutBusinessTypeInput[] | PricingCalculationUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: PricingCalculationCreateOrConnectWithoutBusinessTypeInput | PricingCalculationCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: PricingCalculationCreateManyBusinessTypeInputEnvelope
    connect?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
  }

  export type BusinessTypeDefaultUncheckedCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<BusinessTypeDefaultCreateWithoutBusinessTypeInput, BusinessTypeDefaultUncheckedCreateWithoutBusinessTypeInput> | BusinessTypeDefaultCreateWithoutBusinessTypeInput[] | BusinessTypeDefaultUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessTypeDefaultCreateOrConnectWithoutBusinessTypeInput | BusinessTypeDefaultCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: BusinessTypeDefaultCreateManyBusinessTypeInputEnvelope
    connect?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
  }

  export type BusinessTypePageUncheckedCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<BusinessTypePageCreateWithoutBusinessTypeInput, BusinessTypePageUncheckedCreateWithoutBusinessTypeInput> | BusinessTypePageCreateWithoutBusinessTypeInput[] | BusinessTypePageUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessTypePageCreateOrConnectWithoutBusinessTypeInput | BusinessTypePageCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: BusinessTypePageCreateManyBusinessTypeInputEnvelope
    connect?: BusinessTypePageWhereUniqueInput | BusinessTypePageWhereUniqueInput[]
  }

  export type PricingCalculationUncheckedCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<PricingCalculationCreateWithoutBusinessTypeInput, PricingCalculationUncheckedCreateWithoutBusinessTypeInput> | PricingCalculationCreateWithoutBusinessTypeInput[] | PricingCalculationUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: PricingCalculationCreateOrConnectWithoutBusinessTypeInput | PricingCalculationCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: PricingCalculationCreateManyBusinessTypeInputEnvelope
    connect?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
  }

  export type BusinessTypeDefaultUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<BusinessTypeDefaultCreateWithoutBusinessTypeInput, BusinessTypeDefaultUncheckedCreateWithoutBusinessTypeInput> | BusinessTypeDefaultCreateWithoutBusinessTypeInput[] | BusinessTypeDefaultUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessTypeDefaultCreateOrConnectWithoutBusinessTypeInput | BusinessTypeDefaultCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: BusinessTypeDefaultUpsertWithWhereUniqueWithoutBusinessTypeInput | BusinessTypeDefaultUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: BusinessTypeDefaultCreateManyBusinessTypeInputEnvelope
    set?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
    disconnect?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
    delete?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
    connect?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
    update?: BusinessTypeDefaultUpdateWithWhereUniqueWithoutBusinessTypeInput | BusinessTypeDefaultUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: BusinessTypeDefaultUpdateManyWithWhereWithoutBusinessTypeInput | BusinessTypeDefaultUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: BusinessTypeDefaultScalarWhereInput | BusinessTypeDefaultScalarWhereInput[]
  }

  export type BusinessTypePageUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<BusinessTypePageCreateWithoutBusinessTypeInput, BusinessTypePageUncheckedCreateWithoutBusinessTypeInput> | BusinessTypePageCreateWithoutBusinessTypeInput[] | BusinessTypePageUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessTypePageCreateOrConnectWithoutBusinessTypeInput | BusinessTypePageCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: BusinessTypePageUpsertWithWhereUniqueWithoutBusinessTypeInput | BusinessTypePageUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: BusinessTypePageCreateManyBusinessTypeInputEnvelope
    set?: BusinessTypePageWhereUniqueInput | BusinessTypePageWhereUniqueInput[]
    disconnect?: BusinessTypePageWhereUniqueInput | BusinessTypePageWhereUniqueInput[]
    delete?: BusinessTypePageWhereUniqueInput | BusinessTypePageWhereUniqueInput[]
    connect?: BusinessTypePageWhereUniqueInput | BusinessTypePageWhereUniqueInput[]
    update?: BusinessTypePageUpdateWithWhereUniqueWithoutBusinessTypeInput | BusinessTypePageUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: BusinessTypePageUpdateManyWithWhereWithoutBusinessTypeInput | BusinessTypePageUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: BusinessTypePageScalarWhereInput | BusinessTypePageScalarWhereInput[]
  }

  export type PricingCalculationUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<PricingCalculationCreateWithoutBusinessTypeInput, PricingCalculationUncheckedCreateWithoutBusinessTypeInput> | PricingCalculationCreateWithoutBusinessTypeInput[] | PricingCalculationUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: PricingCalculationCreateOrConnectWithoutBusinessTypeInput | PricingCalculationCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: PricingCalculationUpsertWithWhereUniqueWithoutBusinessTypeInput | PricingCalculationUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: PricingCalculationCreateManyBusinessTypeInputEnvelope
    set?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
    disconnect?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
    delete?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
    connect?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
    update?: PricingCalculationUpdateWithWhereUniqueWithoutBusinessTypeInput | PricingCalculationUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: PricingCalculationUpdateManyWithWhereWithoutBusinessTypeInput | PricingCalculationUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: PricingCalculationScalarWhereInput | PricingCalculationScalarWhereInput[]
  }

  export type BusinessTypeDefaultUncheckedUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<BusinessTypeDefaultCreateWithoutBusinessTypeInput, BusinessTypeDefaultUncheckedCreateWithoutBusinessTypeInput> | BusinessTypeDefaultCreateWithoutBusinessTypeInput[] | BusinessTypeDefaultUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessTypeDefaultCreateOrConnectWithoutBusinessTypeInput | BusinessTypeDefaultCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: BusinessTypeDefaultUpsertWithWhereUniqueWithoutBusinessTypeInput | BusinessTypeDefaultUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: BusinessTypeDefaultCreateManyBusinessTypeInputEnvelope
    set?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
    disconnect?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
    delete?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
    connect?: BusinessTypeDefaultWhereUniqueInput | BusinessTypeDefaultWhereUniqueInput[]
    update?: BusinessTypeDefaultUpdateWithWhereUniqueWithoutBusinessTypeInput | BusinessTypeDefaultUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: BusinessTypeDefaultUpdateManyWithWhereWithoutBusinessTypeInput | BusinessTypeDefaultUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: BusinessTypeDefaultScalarWhereInput | BusinessTypeDefaultScalarWhereInput[]
  }

  export type BusinessTypePageUncheckedUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<BusinessTypePageCreateWithoutBusinessTypeInput, BusinessTypePageUncheckedCreateWithoutBusinessTypeInput> | BusinessTypePageCreateWithoutBusinessTypeInput[] | BusinessTypePageUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: BusinessTypePageCreateOrConnectWithoutBusinessTypeInput | BusinessTypePageCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: BusinessTypePageUpsertWithWhereUniqueWithoutBusinessTypeInput | BusinessTypePageUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: BusinessTypePageCreateManyBusinessTypeInputEnvelope
    set?: BusinessTypePageWhereUniqueInput | BusinessTypePageWhereUniqueInput[]
    disconnect?: BusinessTypePageWhereUniqueInput | BusinessTypePageWhereUniqueInput[]
    delete?: BusinessTypePageWhereUniqueInput | BusinessTypePageWhereUniqueInput[]
    connect?: BusinessTypePageWhereUniqueInput | BusinessTypePageWhereUniqueInput[]
    update?: BusinessTypePageUpdateWithWhereUniqueWithoutBusinessTypeInput | BusinessTypePageUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: BusinessTypePageUpdateManyWithWhereWithoutBusinessTypeInput | BusinessTypePageUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: BusinessTypePageScalarWhereInput | BusinessTypePageScalarWhereInput[]
  }

  export type PricingCalculationUncheckedUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<PricingCalculationCreateWithoutBusinessTypeInput, PricingCalculationUncheckedCreateWithoutBusinessTypeInput> | PricingCalculationCreateWithoutBusinessTypeInput[] | PricingCalculationUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: PricingCalculationCreateOrConnectWithoutBusinessTypeInput | PricingCalculationCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: PricingCalculationUpsertWithWhereUniqueWithoutBusinessTypeInput | PricingCalculationUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: PricingCalculationCreateManyBusinessTypeInputEnvelope
    set?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
    disconnect?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
    delete?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
    connect?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
    update?: PricingCalculationUpdateWithWhereUniqueWithoutBusinessTypeInput | PricingCalculationUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: PricingCalculationUpdateManyWithWhereWithoutBusinessTypeInput | PricingCalculationUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: PricingCalculationScalarWhereInput | PricingCalculationScalarWhereInput[]
  }

  export type BusinessTypeCreateNestedOneWithoutDefaultsInput = {
    create?: XOR<BusinessTypeCreateWithoutDefaultsInput, BusinessTypeUncheckedCreateWithoutDefaultsInput>
    connectOrCreate?: BusinessTypeCreateOrConnectWithoutDefaultsInput
    connect?: BusinessTypeWhereUniqueInput
  }

  export type FeatureCreateNestedOneWithoutDefaultsInput = {
    create?: XOR<FeatureCreateWithoutDefaultsInput, FeatureUncheckedCreateWithoutDefaultsInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutDefaultsInput
    connect?: FeatureWhereUniqueInput
  }

  export type BusinessTypeUpdateOneRequiredWithoutDefaultsNestedInput = {
    create?: XOR<BusinessTypeCreateWithoutDefaultsInput, BusinessTypeUncheckedCreateWithoutDefaultsInput>
    connectOrCreate?: BusinessTypeCreateOrConnectWithoutDefaultsInput
    upsert?: BusinessTypeUpsertWithoutDefaultsInput
    connect?: BusinessTypeWhereUniqueInput
    update?: XOR<XOR<BusinessTypeUpdateToOneWithWhereWithoutDefaultsInput, BusinessTypeUpdateWithoutDefaultsInput>, BusinessTypeUncheckedUpdateWithoutDefaultsInput>
  }

  export type FeatureUpdateOneRequiredWithoutDefaultsNestedInput = {
    create?: XOR<FeatureCreateWithoutDefaultsInput, FeatureUncheckedCreateWithoutDefaultsInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutDefaultsInput
    upsert?: FeatureUpsertWithoutDefaultsInput
    connect?: FeatureWhereUniqueInput
    update?: XOR<XOR<FeatureUpdateToOneWithWhereWithoutDefaultsInput, FeatureUpdateWithoutDefaultsInput>, FeatureUncheckedUpdateWithoutDefaultsInput>
  }

  export type BusinessTypeCreateNestedOneWithoutPagesInput = {
    create?: XOR<BusinessTypeCreateWithoutPagesInput, BusinessTypeUncheckedCreateWithoutPagesInput>
    connectOrCreate?: BusinessTypeCreateOrConnectWithoutPagesInput
    connect?: BusinessTypeWhereUniqueInput
  }

  export type BusinessTypeUpdateOneRequiredWithoutPagesNestedInput = {
    create?: XOR<BusinessTypeCreateWithoutPagesInput, BusinessTypeUncheckedCreateWithoutPagesInput>
    connectOrCreate?: BusinessTypeCreateOrConnectWithoutPagesInput
    upsert?: BusinessTypeUpsertWithoutPagesInput
    connect?: BusinessTypeWhereUniqueInput
    update?: XOR<XOR<BusinessTypeUpdateToOneWithWhereWithoutPagesInput, BusinessTypeUpdateWithoutPagesInput>, BusinessTypeUncheckedUpdateWithoutPagesInput>
  }

  export type ServiceCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCategoryInput | ServiceUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCategoryInput | ServiceUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCategoryInput | ServiceUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCategoryInput | ServiceUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCategoryInput | ServiceUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCategoryInput | ServiceUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceCategoryCreateNestedOneWithoutServicesInput = {
    create?: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutServicesInput
    connect?: ServiceCategoryWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutServicesInput
    upsert?: ServiceCategoryUpsertWithoutServicesInput
    connect?: ServiceCategoryWhereUniqueInput
    update?: XOR<XOR<ServiceCategoryUpdateToOneWithWhereWithoutServicesInput, ServiceCategoryUpdateWithoutServicesInput>, ServiceCategoryUncheckedUpdateWithoutServicesInput>
  }

  export type ContactFormStepCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactFormStepCreateWithoutContactInput, ContactFormStepUncheckedCreateWithoutContactInput> | ContactFormStepCreateWithoutContactInput[] | ContactFormStepUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactFormStepCreateOrConnectWithoutContactInput | ContactFormStepCreateOrConnectWithoutContactInput[]
    createMany?: ContactFormStepCreateManyContactInputEnvelope
    connect?: ContactFormStepWhereUniqueInput | ContactFormStepWhereUniqueInput[]
  }

  export type PricingCalculationCreateNestedManyWithoutContactInput = {
    create?: XOR<PricingCalculationCreateWithoutContactInput, PricingCalculationUncheckedCreateWithoutContactInput> | PricingCalculationCreateWithoutContactInput[] | PricingCalculationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: PricingCalculationCreateOrConnectWithoutContactInput | PricingCalculationCreateOrConnectWithoutContactInput[]
    createMany?: PricingCalculationCreateManyContactInputEnvelope
    connect?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
  }

  export type TimeSlotCreateNestedManyWithoutContactInput = {
    create?: XOR<TimeSlotCreateWithoutContactInput, TimeSlotUncheckedCreateWithoutContactInput> | TimeSlotCreateWithoutContactInput[] | TimeSlotUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutContactInput | TimeSlotCreateOrConnectWithoutContactInput[]
    createMany?: TimeSlotCreateManyContactInputEnvelope
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
  }

  export type ContactFormStepUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactFormStepCreateWithoutContactInput, ContactFormStepUncheckedCreateWithoutContactInput> | ContactFormStepCreateWithoutContactInput[] | ContactFormStepUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactFormStepCreateOrConnectWithoutContactInput | ContactFormStepCreateOrConnectWithoutContactInput[]
    createMany?: ContactFormStepCreateManyContactInputEnvelope
    connect?: ContactFormStepWhereUniqueInput | ContactFormStepWhereUniqueInput[]
  }

  export type PricingCalculationUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<PricingCalculationCreateWithoutContactInput, PricingCalculationUncheckedCreateWithoutContactInput> | PricingCalculationCreateWithoutContactInput[] | PricingCalculationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: PricingCalculationCreateOrConnectWithoutContactInput | PricingCalculationCreateOrConnectWithoutContactInput[]
    createMany?: PricingCalculationCreateManyContactInputEnvelope
    connect?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
  }

  export type TimeSlotUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<TimeSlotCreateWithoutContactInput, TimeSlotUncheckedCreateWithoutContactInput> | TimeSlotCreateWithoutContactInput[] | TimeSlotUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutContactInput | TimeSlotCreateOrConnectWithoutContactInput[]
    createMany?: TimeSlotCreateManyContactInputEnvelope
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
  }

  export type ContactFormStepUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactFormStepCreateWithoutContactInput, ContactFormStepUncheckedCreateWithoutContactInput> | ContactFormStepCreateWithoutContactInput[] | ContactFormStepUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactFormStepCreateOrConnectWithoutContactInput | ContactFormStepCreateOrConnectWithoutContactInput[]
    upsert?: ContactFormStepUpsertWithWhereUniqueWithoutContactInput | ContactFormStepUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactFormStepCreateManyContactInputEnvelope
    set?: ContactFormStepWhereUniqueInput | ContactFormStepWhereUniqueInput[]
    disconnect?: ContactFormStepWhereUniqueInput | ContactFormStepWhereUniqueInput[]
    delete?: ContactFormStepWhereUniqueInput | ContactFormStepWhereUniqueInput[]
    connect?: ContactFormStepWhereUniqueInput | ContactFormStepWhereUniqueInput[]
    update?: ContactFormStepUpdateWithWhereUniqueWithoutContactInput | ContactFormStepUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactFormStepUpdateManyWithWhereWithoutContactInput | ContactFormStepUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactFormStepScalarWhereInput | ContactFormStepScalarWhereInput[]
  }

  export type PricingCalculationUpdateManyWithoutContactNestedInput = {
    create?: XOR<PricingCalculationCreateWithoutContactInput, PricingCalculationUncheckedCreateWithoutContactInput> | PricingCalculationCreateWithoutContactInput[] | PricingCalculationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: PricingCalculationCreateOrConnectWithoutContactInput | PricingCalculationCreateOrConnectWithoutContactInput[]
    upsert?: PricingCalculationUpsertWithWhereUniqueWithoutContactInput | PricingCalculationUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: PricingCalculationCreateManyContactInputEnvelope
    set?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
    disconnect?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
    delete?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
    connect?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
    update?: PricingCalculationUpdateWithWhereUniqueWithoutContactInput | PricingCalculationUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: PricingCalculationUpdateManyWithWhereWithoutContactInput | PricingCalculationUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: PricingCalculationScalarWhereInput | PricingCalculationScalarWhereInput[]
  }

  export type TimeSlotUpdateManyWithoutContactNestedInput = {
    create?: XOR<TimeSlotCreateWithoutContactInput, TimeSlotUncheckedCreateWithoutContactInput> | TimeSlotCreateWithoutContactInput[] | TimeSlotUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutContactInput | TimeSlotCreateOrConnectWithoutContactInput[]
    upsert?: TimeSlotUpsertWithWhereUniqueWithoutContactInput | TimeSlotUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: TimeSlotCreateManyContactInputEnvelope
    set?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    disconnect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    delete?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    update?: TimeSlotUpdateWithWhereUniqueWithoutContactInput | TimeSlotUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: TimeSlotUpdateManyWithWhereWithoutContactInput | TimeSlotUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
  }

  export type ContactFormStepUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactFormStepCreateWithoutContactInput, ContactFormStepUncheckedCreateWithoutContactInput> | ContactFormStepCreateWithoutContactInput[] | ContactFormStepUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactFormStepCreateOrConnectWithoutContactInput | ContactFormStepCreateOrConnectWithoutContactInput[]
    upsert?: ContactFormStepUpsertWithWhereUniqueWithoutContactInput | ContactFormStepUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactFormStepCreateManyContactInputEnvelope
    set?: ContactFormStepWhereUniqueInput | ContactFormStepWhereUniqueInput[]
    disconnect?: ContactFormStepWhereUniqueInput | ContactFormStepWhereUniqueInput[]
    delete?: ContactFormStepWhereUniqueInput | ContactFormStepWhereUniqueInput[]
    connect?: ContactFormStepWhereUniqueInput | ContactFormStepWhereUniqueInput[]
    update?: ContactFormStepUpdateWithWhereUniqueWithoutContactInput | ContactFormStepUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactFormStepUpdateManyWithWhereWithoutContactInput | ContactFormStepUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactFormStepScalarWhereInput | ContactFormStepScalarWhereInput[]
  }

  export type PricingCalculationUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<PricingCalculationCreateWithoutContactInput, PricingCalculationUncheckedCreateWithoutContactInput> | PricingCalculationCreateWithoutContactInput[] | PricingCalculationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: PricingCalculationCreateOrConnectWithoutContactInput | PricingCalculationCreateOrConnectWithoutContactInput[]
    upsert?: PricingCalculationUpsertWithWhereUniqueWithoutContactInput | PricingCalculationUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: PricingCalculationCreateManyContactInputEnvelope
    set?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
    disconnect?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
    delete?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
    connect?: PricingCalculationWhereUniqueInput | PricingCalculationWhereUniqueInput[]
    update?: PricingCalculationUpdateWithWhereUniqueWithoutContactInput | PricingCalculationUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: PricingCalculationUpdateManyWithWhereWithoutContactInput | PricingCalculationUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: PricingCalculationScalarWhereInput | PricingCalculationScalarWhereInput[]
  }

  export type TimeSlotUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<TimeSlotCreateWithoutContactInput, TimeSlotUncheckedCreateWithoutContactInput> | TimeSlotCreateWithoutContactInput[] | TimeSlotUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutContactInput | TimeSlotCreateOrConnectWithoutContactInput[]
    upsert?: TimeSlotUpsertWithWhereUniqueWithoutContactInput | TimeSlotUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: TimeSlotCreateManyContactInputEnvelope
    set?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    disconnect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    delete?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    update?: TimeSlotUpdateWithWhereUniqueWithoutContactInput | TimeSlotUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: TimeSlotUpdateManyWithWhereWithoutContactInput | TimeSlotUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
  }

  export type ContactCreateNestedOneWithoutTimeSlotsInput = {
    create?: XOR<ContactCreateWithoutTimeSlotsInput, ContactUncheckedCreateWithoutTimeSlotsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTimeSlotsInput
    connect?: ContactWhereUniqueInput
  }

  export type ContactUpdateOneWithoutTimeSlotsNestedInput = {
    create?: XOR<ContactCreateWithoutTimeSlotsInput, ContactUncheckedCreateWithoutTimeSlotsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTimeSlotsInput
    upsert?: ContactUpsertWithoutTimeSlotsInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutTimeSlotsInput, ContactUpdateWithoutTimeSlotsInput>, ContactUncheckedUpdateWithoutTimeSlotsInput>
  }

  export type ContactCreateNestedOneWithoutFormStepsInput = {
    create?: XOR<ContactCreateWithoutFormStepsInput, ContactUncheckedCreateWithoutFormStepsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutFormStepsInput
    connect?: ContactWhereUniqueInput
  }

  export type ContactUpdateOneRequiredWithoutFormStepsNestedInput = {
    create?: XOR<ContactCreateWithoutFormStepsInput, ContactUncheckedCreateWithoutFormStepsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutFormStepsInput
    upsert?: ContactUpsertWithoutFormStepsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutFormStepsInput, ContactUpdateWithoutFormStepsInput>, ContactUncheckedUpdateWithoutFormStepsInput>
  }

  export type CalculationFeatureCreateNestedManyWithoutCalculationInput = {
    create?: XOR<CalculationFeatureCreateWithoutCalculationInput, CalculationFeatureUncheckedCreateWithoutCalculationInput> | CalculationFeatureCreateWithoutCalculationInput[] | CalculationFeatureUncheckedCreateWithoutCalculationInput[]
    connectOrCreate?: CalculationFeatureCreateOrConnectWithoutCalculationInput | CalculationFeatureCreateOrConnectWithoutCalculationInput[]
    createMany?: CalculationFeatureCreateManyCalculationInputEnvelope
    connect?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
  }

  export type BusinessTypeCreateNestedOneWithoutCalculationsInput = {
    create?: XOR<BusinessTypeCreateWithoutCalculationsInput, BusinessTypeUncheckedCreateWithoutCalculationsInput>
    connectOrCreate?: BusinessTypeCreateOrConnectWithoutCalculationsInput
    connect?: BusinessTypeWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutCalculationsInput = {
    create?: XOR<ContactCreateWithoutCalculationsInput, ContactUncheckedCreateWithoutCalculationsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutCalculationsInput
    connect?: ContactWhereUniqueInput
  }

  export type CalculationFeatureUncheckedCreateNestedManyWithoutCalculationInput = {
    create?: XOR<CalculationFeatureCreateWithoutCalculationInput, CalculationFeatureUncheckedCreateWithoutCalculationInput> | CalculationFeatureCreateWithoutCalculationInput[] | CalculationFeatureUncheckedCreateWithoutCalculationInput[]
    connectOrCreate?: CalculationFeatureCreateOrConnectWithoutCalculationInput | CalculationFeatureCreateOrConnectWithoutCalculationInput[]
    createMany?: CalculationFeatureCreateManyCalculationInputEnvelope
    connect?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
  }

  export type CalculationFeatureUpdateManyWithoutCalculationNestedInput = {
    create?: XOR<CalculationFeatureCreateWithoutCalculationInput, CalculationFeatureUncheckedCreateWithoutCalculationInput> | CalculationFeatureCreateWithoutCalculationInput[] | CalculationFeatureUncheckedCreateWithoutCalculationInput[]
    connectOrCreate?: CalculationFeatureCreateOrConnectWithoutCalculationInput | CalculationFeatureCreateOrConnectWithoutCalculationInput[]
    upsert?: CalculationFeatureUpsertWithWhereUniqueWithoutCalculationInput | CalculationFeatureUpsertWithWhereUniqueWithoutCalculationInput[]
    createMany?: CalculationFeatureCreateManyCalculationInputEnvelope
    set?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    disconnect?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    delete?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    connect?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    update?: CalculationFeatureUpdateWithWhereUniqueWithoutCalculationInput | CalculationFeatureUpdateWithWhereUniqueWithoutCalculationInput[]
    updateMany?: CalculationFeatureUpdateManyWithWhereWithoutCalculationInput | CalculationFeatureUpdateManyWithWhereWithoutCalculationInput[]
    deleteMany?: CalculationFeatureScalarWhereInput | CalculationFeatureScalarWhereInput[]
  }

  export type BusinessTypeUpdateOneRequiredWithoutCalculationsNestedInput = {
    create?: XOR<BusinessTypeCreateWithoutCalculationsInput, BusinessTypeUncheckedCreateWithoutCalculationsInput>
    connectOrCreate?: BusinessTypeCreateOrConnectWithoutCalculationsInput
    upsert?: BusinessTypeUpsertWithoutCalculationsInput
    connect?: BusinessTypeWhereUniqueInput
    update?: XOR<XOR<BusinessTypeUpdateToOneWithWhereWithoutCalculationsInput, BusinessTypeUpdateWithoutCalculationsInput>, BusinessTypeUncheckedUpdateWithoutCalculationsInput>
  }

  export type ContactUpdateOneWithoutCalculationsNestedInput = {
    create?: XOR<ContactCreateWithoutCalculationsInput, ContactUncheckedCreateWithoutCalculationsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutCalculationsInput
    upsert?: ContactUpsertWithoutCalculationsInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutCalculationsInput, ContactUpdateWithoutCalculationsInput>, ContactUncheckedUpdateWithoutCalculationsInput>
  }

  export type CalculationFeatureUncheckedUpdateManyWithoutCalculationNestedInput = {
    create?: XOR<CalculationFeatureCreateWithoutCalculationInput, CalculationFeatureUncheckedCreateWithoutCalculationInput> | CalculationFeatureCreateWithoutCalculationInput[] | CalculationFeatureUncheckedCreateWithoutCalculationInput[]
    connectOrCreate?: CalculationFeatureCreateOrConnectWithoutCalculationInput | CalculationFeatureCreateOrConnectWithoutCalculationInput[]
    upsert?: CalculationFeatureUpsertWithWhereUniqueWithoutCalculationInput | CalculationFeatureUpsertWithWhereUniqueWithoutCalculationInput[]
    createMany?: CalculationFeatureCreateManyCalculationInputEnvelope
    set?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    disconnect?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    delete?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    connect?: CalculationFeatureWhereUniqueInput | CalculationFeatureWhereUniqueInput[]
    update?: CalculationFeatureUpdateWithWhereUniqueWithoutCalculationInput | CalculationFeatureUpdateWithWhereUniqueWithoutCalculationInput[]
    updateMany?: CalculationFeatureUpdateManyWithWhereWithoutCalculationInput | CalculationFeatureUpdateManyWithWhereWithoutCalculationInput[]
    deleteMany?: CalculationFeatureScalarWhereInput | CalculationFeatureScalarWhereInput[]
  }

  export type PricingCalculationCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<PricingCalculationCreateWithoutFeaturesInput, PricingCalculationUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: PricingCalculationCreateOrConnectWithoutFeaturesInput
    connect?: PricingCalculationWhereUniqueInput
  }

  export type FeatureCreateNestedOneWithoutCalculationsInput = {
    create?: XOR<FeatureCreateWithoutCalculationsInput, FeatureUncheckedCreateWithoutCalculationsInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutCalculationsInput
    connect?: FeatureWhereUniqueInput
  }

  export type FeatureTierCreateNestedOneWithoutCalculationsInput = {
    create?: XOR<FeatureTierCreateWithoutCalculationsInput, FeatureTierUncheckedCreateWithoutCalculationsInput>
    connectOrCreate?: FeatureTierCreateOrConnectWithoutCalculationsInput
    connect?: FeatureTierWhereUniqueInput
  }

  export type PricingCalculationUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<PricingCalculationCreateWithoutFeaturesInput, PricingCalculationUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: PricingCalculationCreateOrConnectWithoutFeaturesInput
    upsert?: PricingCalculationUpsertWithoutFeaturesInput
    connect?: PricingCalculationWhereUniqueInput
    update?: XOR<XOR<PricingCalculationUpdateToOneWithWhereWithoutFeaturesInput, PricingCalculationUpdateWithoutFeaturesInput>, PricingCalculationUncheckedUpdateWithoutFeaturesInput>
  }

  export type FeatureUpdateOneRequiredWithoutCalculationsNestedInput = {
    create?: XOR<FeatureCreateWithoutCalculationsInput, FeatureUncheckedCreateWithoutCalculationsInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutCalculationsInput
    upsert?: FeatureUpsertWithoutCalculationsInput
    connect?: FeatureWhereUniqueInput
    update?: XOR<XOR<FeatureUpdateToOneWithWhereWithoutCalculationsInput, FeatureUpdateWithoutCalculationsInput>, FeatureUncheckedUpdateWithoutCalculationsInput>
  }

  export type FeatureTierUpdateOneRequiredWithoutCalculationsNestedInput = {
    create?: XOR<FeatureTierCreateWithoutCalculationsInput, FeatureTierUncheckedCreateWithoutCalculationsInput>
    connectOrCreate?: FeatureTierCreateOrConnectWithoutCalculationsInput
    upsert?: FeatureTierUpsertWithoutCalculationsInput
    connect?: FeatureTierWhereUniqueInput
    update?: XOR<XOR<FeatureTierUpdateToOneWithWhereWithoutCalculationsInput, FeatureTierUpdateWithoutCalculationsInput>, FeatureTierUncheckedUpdateWithoutCalculationsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FeatureCreateWithoutGroupInput = {
    id?: string
    name: string
    description?: string | null
    explanation?: string | null
    isCountable?: boolean
    minCount?: number
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaults?: BusinessTypeDefaultCreateNestedManyWithoutFeatureInput
    calculations?: CalculationFeatureCreateNestedManyWithoutFeatureInput
    tiers?: FeatureTierCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateWithoutGroupInput = {
    id?: string
    name: string
    description?: string | null
    explanation?: string | null
    isCountable?: boolean
    minCount?: number
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaults?: BusinessTypeDefaultUncheckedCreateNestedManyWithoutFeatureInput
    calculations?: CalculationFeatureUncheckedCreateNestedManyWithoutFeatureInput
    tiers?: FeatureTierUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutGroupInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutGroupInput, FeatureUncheckedCreateWithoutGroupInput>
  }

  export type FeatureCreateManyGroupInputEnvelope = {
    data: FeatureCreateManyGroupInput | FeatureCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type FeatureUpsertWithWhereUniqueWithoutGroupInput = {
    where: FeatureWhereUniqueInput
    update: XOR<FeatureUpdateWithoutGroupInput, FeatureUncheckedUpdateWithoutGroupInput>
    create: XOR<FeatureCreateWithoutGroupInput, FeatureUncheckedCreateWithoutGroupInput>
  }

  export type FeatureUpdateWithWhereUniqueWithoutGroupInput = {
    where: FeatureWhereUniqueInput
    data: XOR<FeatureUpdateWithoutGroupInput, FeatureUncheckedUpdateWithoutGroupInput>
  }

  export type FeatureUpdateManyWithWhereWithoutGroupInput = {
    where: FeatureScalarWhereInput
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyWithoutGroupInput>
  }

  export type FeatureScalarWhereInput = {
    AND?: FeatureScalarWhereInput | FeatureScalarWhereInput[]
    OR?: FeatureScalarWhereInput[]
    NOT?: FeatureScalarWhereInput | FeatureScalarWhereInput[]
    id?: UuidFilter<"Feature"> | string
    groupId?: UuidFilter<"Feature"> | string
    name?: StringFilter<"Feature"> | string
    description?: StringNullableFilter<"Feature"> | string | null
    explanation?: StringNullableFilter<"Feature"> | string | null
    isCountable?: BoolFilter<"Feature"> | boolean
    minCount?: IntFilter<"Feature"> | number
    displayOrder?: IntNullableFilter<"Feature"> | number | null
    isActive?: BoolFilter<"Feature"> | boolean
    createdAt?: DateTimeFilter<"Feature"> | Date | string
    updatedAt?: DateTimeFilter<"Feature"> | Date | string
  }

  export type BusinessTypeDefaultCreateWithoutFeatureInput = {
    id?: string
    defaultTier: string
    defaultCount?: number
    createdAt?: Date | string
    businessType: BusinessTypeCreateNestedOneWithoutDefaultsInput
  }

  export type BusinessTypeDefaultUncheckedCreateWithoutFeatureInput = {
    id?: string
    businessTypeId: string
    defaultTier: string
    defaultCount?: number
    createdAt?: Date | string
  }

  export type BusinessTypeDefaultCreateOrConnectWithoutFeatureInput = {
    where: BusinessTypeDefaultWhereUniqueInput
    create: XOR<BusinessTypeDefaultCreateWithoutFeatureInput, BusinessTypeDefaultUncheckedCreateWithoutFeatureInput>
  }

  export type BusinessTypeDefaultCreateManyFeatureInputEnvelope = {
    data: BusinessTypeDefaultCreateManyFeatureInput | BusinessTypeDefaultCreateManyFeatureInput[]
    skipDuplicates?: boolean
  }

  export type CalculationFeatureCreateWithoutFeatureInput = {
    id?: string
    count?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    calculation: PricingCalculationCreateNestedOneWithoutFeaturesInput
    tier: FeatureTierCreateNestedOneWithoutCalculationsInput
  }

  export type CalculationFeatureUncheckedCreateWithoutFeatureInput = {
    id?: string
    calculationId: string
    tierName: string
    count?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type CalculationFeatureCreateOrConnectWithoutFeatureInput = {
    where: CalculationFeatureWhereUniqueInput
    create: XOR<CalculationFeatureCreateWithoutFeatureInput, CalculationFeatureUncheckedCreateWithoutFeatureInput>
  }

  export type CalculationFeatureCreateManyFeatureInputEnvelope = {
    data: CalculationFeatureCreateManyFeatureInput | CalculationFeatureCreateManyFeatureInput[]
    skipDuplicates?: boolean
  }

  export type FeatureTierCreateWithoutFeatureInput = {
    id?: string
    tierName: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    calculations?: CalculationFeatureCreateNestedManyWithoutTierInput
  }

  export type FeatureTierUncheckedCreateWithoutFeatureInput = {
    id?: string
    tierName: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    calculations?: CalculationFeatureUncheckedCreateNestedManyWithoutTierInput
  }

  export type FeatureTierCreateOrConnectWithoutFeatureInput = {
    where: FeatureTierWhereUniqueInput
    create: XOR<FeatureTierCreateWithoutFeatureInput, FeatureTierUncheckedCreateWithoutFeatureInput>
  }

  export type FeatureTierCreateManyFeatureInputEnvelope = {
    data: FeatureTierCreateManyFeatureInput | FeatureTierCreateManyFeatureInput[]
    skipDuplicates?: boolean
  }

  export type FeatureGroupCreateWithoutFeaturesInput = {
    id?: string
    name: string
    description?: string | null
    iconName?: string | null
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureGroupUncheckedCreateWithoutFeaturesInput = {
    id?: string
    name: string
    description?: string | null
    iconName?: string | null
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureGroupCreateOrConnectWithoutFeaturesInput = {
    where: FeatureGroupWhereUniqueInput
    create: XOR<FeatureGroupCreateWithoutFeaturesInput, FeatureGroupUncheckedCreateWithoutFeaturesInput>
  }

  export type BusinessTypeDefaultUpsertWithWhereUniqueWithoutFeatureInput = {
    where: BusinessTypeDefaultWhereUniqueInput
    update: XOR<BusinessTypeDefaultUpdateWithoutFeatureInput, BusinessTypeDefaultUncheckedUpdateWithoutFeatureInput>
    create: XOR<BusinessTypeDefaultCreateWithoutFeatureInput, BusinessTypeDefaultUncheckedCreateWithoutFeatureInput>
  }

  export type BusinessTypeDefaultUpdateWithWhereUniqueWithoutFeatureInput = {
    where: BusinessTypeDefaultWhereUniqueInput
    data: XOR<BusinessTypeDefaultUpdateWithoutFeatureInput, BusinessTypeDefaultUncheckedUpdateWithoutFeatureInput>
  }

  export type BusinessTypeDefaultUpdateManyWithWhereWithoutFeatureInput = {
    where: BusinessTypeDefaultScalarWhereInput
    data: XOR<BusinessTypeDefaultUpdateManyMutationInput, BusinessTypeDefaultUncheckedUpdateManyWithoutFeatureInput>
  }

  export type BusinessTypeDefaultScalarWhereInput = {
    AND?: BusinessTypeDefaultScalarWhereInput | BusinessTypeDefaultScalarWhereInput[]
    OR?: BusinessTypeDefaultScalarWhereInput[]
    NOT?: BusinessTypeDefaultScalarWhereInput | BusinessTypeDefaultScalarWhereInput[]
    id?: UuidFilter<"BusinessTypeDefault"> | string
    businessTypeId?: UuidFilter<"BusinessTypeDefault"> | string
    featureId?: UuidFilter<"BusinessTypeDefault"> | string
    defaultTier?: StringFilter<"BusinessTypeDefault"> | string
    defaultCount?: IntFilter<"BusinessTypeDefault"> | number
    createdAt?: DateTimeFilter<"BusinessTypeDefault"> | Date | string
  }

  export type CalculationFeatureUpsertWithWhereUniqueWithoutFeatureInput = {
    where: CalculationFeatureWhereUniqueInput
    update: XOR<CalculationFeatureUpdateWithoutFeatureInput, CalculationFeatureUncheckedUpdateWithoutFeatureInput>
    create: XOR<CalculationFeatureCreateWithoutFeatureInput, CalculationFeatureUncheckedCreateWithoutFeatureInput>
  }

  export type CalculationFeatureUpdateWithWhereUniqueWithoutFeatureInput = {
    where: CalculationFeatureWhereUniqueInput
    data: XOR<CalculationFeatureUpdateWithoutFeatureInput, CalculationFeatureUncheckedUpdateWithoutFeatureInput>
  }

  export type CalculationFeatureUpdateManyWithWhereWithoutFeatureInput = {
    where: CalculationFeatureScalarWhereInput
    data: XOR<CalculationFeatureUpdateManyMutationInput, CalculationFeatureUncheckedUpdateManyWithoutFeatureInput>
  }

  export type CalculationFeatureScalarWhereInput = {
    AND?: CalculationFeatureScalarWhereInput | CalculationFeatureScalarWhereInput[]
    OR?: CalculationFeatureScalarWhereInput[]
    NOT?: CalculationFeatureScalarWhereInput | CalculationFeatureScalarWhereInput[]
    id?: UuidFilter<"CalculationFeature"> | string
    calculationId?: UuidFilter<"CalculationFeature"> | string
    featureId?: UuidFilter<"CalculationFeature"> | string
    tierName?: StringFilter<"CalculationFeature"> | string
    count?: IntFilter<"CalculationFeature"> | number
    unitPrice?: DecimalFilter<"CalculationFeature"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"CalculationFeature"> | Decimal | DecimalJsLike | number | string
  }

  export type FeatureTierUpsertWithWhereUniqueWithoutFeatureInput = {
    where: FeatureTierWhereUniqueInput
    update: XOR<FeatureTierUpdateWithoutFeatureInput, FeatureTierUncheckedUpdateWithoutFeatureInput>
    create: XOR<FeatureTierCreateWithoutFeatureInput, FeatureTierUncheckedCreateWithoutFeatureInput>
  }

  export type FeatureTierUpdateWithWhereUniqueWithoutFeatureInput = {
    where: FeatureTierWhereUniqueInput
    data: XOR<FeatureTierUpdateWithoutFeatureInput, FeatureTierUncheckedUpdateWithoutFeatureInput>
  }

  export type FeatureTierUpdateManyWithWhereWithoutFeatureInput = {
    where: FeatureTierScalarWhereInput
    data: XOR<FeatureTierUpdateManyMutationInput, FeatureTierUncheckedUpdateManyWithoutFeatureInput>
  }

  export type FeatureTierScalarWhereInput = {
    AND?: FeatureTierScalarWhereInput | FeatureTierScalarWhereInput[]
    OR?: FeatureTierScalarWhereInput[]
    NOT?: FeatureTierScalarWhereInput | FeatureTierScalarWhereInput[]
    id?: UuidFilter<"FeatureTier"> | string
    featureId?: UuidFilter<"FeatureTier"> | string
    tierName?: StringFilter<"FeatureTier"> | string
    description?: StringNullableFilter<"FeatureTier"> | string | null
    price?: DecimalFilter<"FeatureTier"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"FeatureTier"> | Date | string
    updatedAt?: DateTimeFilter<"FeatureTier"> | Date | string
  }

  export type FeatureGroupUpsertWithoutFeaturesInput = {
    update: XOR<FeatureGroupUpdateWithoutFeaturesInput, FeatureGroupUncheckedUpdateWithoutFeaturesInput>
    create: XOR<FeatureGroupCreateWithoutFeaturesInput, FeatureGroupUncheckedCreateWithoutFeaturesInput>
    where?: FeatureGroupWhereInput
  }

  export type FeatureGroupUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: FeatureGroupWhereInput
    data: XOR<FeatureGroupUpdateWithoutFeaturesInput, FeatureGroupUncheckedUpdateWithoutFeaturesInput>
  }

  export type FeatureGroupUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureGroupUncheckedUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalculationFeatureCreateWithoutTierInput = {
    id?: string
    count?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    calculation: PricingCalculationCreateNestedOneWithoutFeaturesInput
    feature: FeatureCreateNestedOneWithoutCalculationsInput
  }

  export type CalculationFeatureUncheckedCreateWithoutTierInput = {
    id?: string
    calculationId: string
    count?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type CalculationFeatureCreateOrConnectWithoutTierInput = {
    where: CalculationFeatureWhereUniqueInput
    create: XOR<CalculationFeatureCreateWithoutTierInput, CalculationFeatureUncheckedCreateWithoutTierInput>
  }

  export type CalculationFeatureCreateManyTierInputEnvelope = {
    data: CalculationFeatureCreateManyTierInput | CalculationFeatureCreateManyTierInput[]
    skipDuplicates?: boolean
  }

  export type FeatureCreateWithoutTiersInput = {
    id?: string
    name: string
    description?: string | null
    explanation?: string | null
    isCountable?: boolean
    minCount?: number
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaults?: BusinessTypeDefaultCreateNestedManyWithoutFeatureInput
    calculations?: CalculationFeatureCreateNestedManyWithoutFeatureInput
    group: FeatureGroupCreateNestedOneWithoutFeaturesInput
  }

  export type FeatureUncheckedCreateWithoutTiersInput = {
    id?: string
    groupId: string
    name: string
    description?: string | null
    explanation?: string | null
    isCountable?: boolean
    minCount?: number
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaults?: BusinessTypeDefaultUncheckedCreateNestedManyWithoutFeatureInput
    calculations?: CalculationFeatureUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutTiersInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutTiersInput, FeatureUncheckedCreateWithoutTiersInput>
  }

  export type CalculationFeatureUpsertWithWhereUniqueWithoutTierInput = {
    where: CalculationFeatureWhereUniqueInput
    update: XOR<CalculationFeatureUpdateWithoutTierInput, CalculationFeatureUncheckedUpdateWithoutTierInput>
    create: XOR<CalculationFeatureCreateWithoutTierInput, CalculationFeatureUncheckedCreateWithoutTierInput>
  }

  export type CalculationFeatureUpdateWithWhereUniqueWithoutTierInput = {
    where: CalculationFeatureWhereUniqueInput
    data: XOR<CalculationFeatureUpdateWithoutTierInput, CalculationFeatureUncheckedUpdateWithoutTierInput>
  }

  export type CalculationFeatureUpdateManyWithWhereWithoutTierInput = {
    where: CalculationFeatureScalarWhereInput
    data: XOR<CalculationFeatureUpdateManyMutationInput, CalculationFeatureUncheckedUpdateManyWithoutTierInput>
  }

  export type FeatureUpsertWithoutTiersInput = {
    update: XOR<FeatureUpdateWithoutTiersInput, FeatureUncheckedUpdateWithoutTiersInput>
    create: XOR<FeatureCreateWithoutTiersInput, FeatureUncheckedCreateWithoutTiersInput>
    where?: FeatureWhereInput
  }

  export type FeatureUpdateToOneWithWhereWithoutTiersInput = {
    where?: FeatureWhereInput
    data: XOR<FeatureUpdateWithoutTiersInput, FeatureUncheckedUpdateWithoutTiersInput>
  }

  export type FeatureUpdateWithoutTiersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isCountable?: BoolFieldUpdateOperationsInput | boolean
    minCount?: IntFieldUpdateOperationsInput | number
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaults?: BusinessTypeDefaultUpdateManyWithoutFeatureNestedInput
    calculations?: CalculationFeatureUpdateManyWithoutFeatureNestedInput
    group?: FeatureGroupUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type FeatureUncheckedUpdateWithoutTiersInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isCountable?: BoolFieldUpdateOperationsInput | boolean
    minCount?: IntFieldUpdateOperationsInput | number
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaults?: BusinessTypeDefaultUncheckedUpdateManyWithoutFeatureNestedInput
    calculations?: CalculationFeatureUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type BusinessTypeDefaultCreateWithoutBusinessTypeInput = {
    id?: string
    defaultTier: string
    defaultCount?: number
    createdAt?: Date | string
    feature: FeatureCreateNestedOneWithoutDefaultsInput
  }

  export type BusinessTypeDefaultUncheckedCreateWithoutBusinessTypeInput = {
    id?: string
    featureId: string
    defaultTier: string
    defaultCount?: number
    createdAt?: Date | string
  }

  export type BusinessTypeDefaultCreateOrConnectWithoutBusinessTypeInput = {
    where: BusinessTypeDefaultWhereUniqueInput
    create: XOR<BusinessTypeDefaultCreateWithoutBusinessTypeInput, BusinessTypeDefaultUncheckedCreateWithoutBusinessTypeInput>
  }

  export type BusinessTypeDefaultCreateManyBusinessTypeInputEnvelope = {
    data: BusinessTypeDefaultCreateManyBusinessTypeInput | BusinessTypeDefaultCreateManyBusinessTypeInput[]
    skipDuplicates?: boolean
  }

  export type BusinessTypePageCreateWithoutBusinessTypeInput = {
    id?: string
    pageType: string
    pageName: string
    isDefault?: boolean
    displayOrder?: number | null
    createdAt?: Date | string
  }

  export type BusinessTypePageUncheckedCreateWithoutBusinessTypeInput = {
    id?: string
    pageType: string
    pageName: string
    isDefault?: boolean
    displayOrder?: number | null
    createdAt?: Date | string
  }

  export type BusinessTypePageCreateOrConnectWithoutBusinessTypeInput = {
    where: BusinessTypePageWhereUniqueInput
    create: XOR<BusinessTypePageCreateWithoutBusinessTypeInput, BusinessTypePageUncheckedCreateWithoutBusinessTypeInput>
  }

  export type BusinessTypePageCreateManyBusinessTypeInputEnvelope = {
    data: BusinessTypePageCreateManyBusinessTypeInput | BusinessTypePageCreateManyBusinessTypeInput[]
    skipDuplicates?: boolean
  }

  export type PricingCalculationCreateWithoutBusinessTypeInput = {
    id?: string
    sessionId?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    calculationData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    features?: CalculationFeatureCreateNestedManyWithoutCalculationInput
    contact?: ContactCreateNestedOneWithoutCalculationsInput
  }

  export type PricingCalculationUncheckedCreateWithoutBusinessTypeInput = {
    id?: string
    sessionId?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    calculationData: JsonNullValueInput | InputJsonValue
    contactId?: string | null
    createdAt?: Date | string
    features?: CalculationFeatureUncheckedCreateNestedManyWithoutCalculationInput
  }

  export type PricingCalculationCreateOrConnectWithoutBusinessTypeInput = {
    where: PricingCalculationWhereUniqueInput
    create: XOR<PricingCalculationCreateWithoutBusinessTypeInput, PricingCalculationUncheckedCreateWithoutBusinessTypeInput>
  }

  export type PricingCalculationCreateManyBusinessTypeInputEnvelope = {
    data: PricingCalculationCreateManyBusinessTypeInput | PricingCalculationCreateManyBusinessTypeInput[]
    skipDuplicates?: boolean
  }

  export type BusinessTypeDefaultUpsertWithWhereUniqueWithoutBusinessTypeInput = {
    where: BusinessTypeDefaultWhereUniqueInput
    update: XOR<BusinessTypeDefaultUpdateWithoutBusinessTypeInput, BusinessTypeDefaultUncheckedUpdateWithoutBusinessTypeInput>
    create: XOR<BusinessTypeDefaultCreateWithoutBusinessTypeInput, BusinessTypeDefaultUncheckedCreateWithoutBusinessTypeInput>
  }

  export type BusinessTypeDefaultUpdateWithWhereUniqueWithoutBusinessTypeInput = {
    where: BusinessTypeDefaultWhereUniqueInput
    data: XOR<BusinessTypeDefaultUpdateWithoutBusinessTypeInput, BusinessTypeDefaultUncheckedUpdateWithoutBusinessTypeInput>
  }

  export type BusinessTypeDefaultUpdateManyWithWhereWithoutBusinessTypeInput = {
    where: BusinessTypeDefaultScalarWhereInput
    data: XOR<BusinessTypeDefaultUpdateManyMutationInput, BusinessTypeDefaultUncheckedUpdateManyWithoutBusinessTypeInput>
  }

  export type BusinessTypePageUpsertWithWhereUniqueWithoutBusinessTypeInput = {
    where: BusinessTypePageWhereUniqueInput
    update: XOR<BusinessTypePageUpdateWithoutBusinessTypeInput, BusinessTypePageUncheckedUpdateWithoutBusinessTypeInput>
    create: XOR<BusinessTypePageCreateWithoutBusinessTypeInput, BusinessTypePageUncheckedCreateWithoutBusinessTypeInput>
  }

  export type BusinessTypePageUpdateWithWhereUniqueWithoutBusinessTypeInput = {
    where: BusinessTypePageWhereUniqueInput
    data: XOR<BusinessTypePageUpdateWithoutBusinessTypeInput, BusinessTypePageUncheckedUpdateWithoutBusinessTypeInput>
  }

  export type BusinessTypePageUpdateManyWithWhereWithoutBusinessTypeInput = {
    where: BusinessTypePageScalarWhereInput
    data: XOR<BusinessTypePageUpdateManyMutationInput, BusinessTypePageUncheckedUpdateManyWithoutBusinessTypeInput>
  }

  export type BusinessTypePageScalarWhereInput = {
    AND?: BusinessTypePageScalarWhereInput | BusinessTypePageScalarWhereInput[]
    OR?: BusinessTypePageScalarWhereInput[]
    NOT?: BusinessTypePageScalarWhereInput | BusinessTypePageScalarWhereInput[]
    id?: UuidFilter<"BusinessTypePage"> | string
    businessTypeId?: UuidFilter<"BusinessTypePage"> | string
    pageType?: StringFilter<"BusinessTypePage"> | string
    pageName?: StringFilter<"BusinessTypePage"> | string
    isDefault?: BoolFilter<"BusinessTypePage"> | boolean
    displayOrder?: IntNullableFilter<"BusinessTypePage"> | number | null
    createdAt?: DateTimeFilter<"BusinessTypePage"> | Date | string
  }

  export type PricingCalculationUpsertWithWhereUniqueWithoutBusinessTypeInput = {
    where: PricingCalculationWhereUniqueInput
    update: XOR<PricingCalculationUpdateWithoutBusinessTypeInput, PricingCalculationUncheckedUpdateWithoutBusinessTypeInput>
    create: XOR<PricingCalculationCreateWithoutBusinessTypeInput, PricingCalculationUncheckedCreateWithoutBusinessTypeInput>
  }

  export type PricingCalculationUpdateWithWhereUniqueWithoutBusinessTypeInput = {
    where: PricingCalculationWhereUniqueInput
    data: XOR<PricingCalculationUpdateWithoutBusinessTypeInput, PricingCalculationUncheckedUpdateWithoutBusinessTypeInput>
  }

  export type PricingCalculationUpdateManyWithWhereWithoutBusinessTypeInput = {
    where: PricingCalculationScalarWhereInput
    data: XOR<PricingCalculationUpdateManyMutationInput, PricingCalculationUncheckedUpdateManyWithoutBusinessTypeInput>
  }

  export type PricingCalculationScalarWhereInput = {
    AND?: PricingCalculationScalarWhereInput | PricingCalculationScalarWhereInput[]
    OR?: PricingCalculationScalarWhereInput[]
    NOT?: PricingCalculationScalarWhereInput | PricingCalculationScalarWhereInput[]
    id?: UuidFilter<"PricingCalculation"> | string
    sessionId?: StringNullableFilter<"PricingCalculation"> | string | null
    businessTypeId?: UuidFilter<"PricingCalculation"> | string
    totalPrice?: DecimalFilter<"PricingCalculation"> | Decimal | DecimalJsLike | number | string
    calculationData?: JsonFilter<"PricingCalculation">
    contactId?: UuidNullableFilter<"PricingCalculation"> | string | null
    createdAt?: DateTimeFilter<"PricingCalculation"> | Date | string
  }

  export type BusinessTypeCreateWithoutDefaultsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    timelineDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pages?: BusinessTypePageCreateNestedManyWithoutBusinessTypeInput
    calculations?: PricingCalculationCreateNestedManyWithoutBusinessTypeInput
  }

  export type BusinessTypeUncheckedCreateWithoutDefaultsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    timelineDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pages?: BusinessTypePageUncheckedCreateNestedManyWithoutBusinessTypeInput
    calculations?: PricingCalculationUncheckedCreateNestedManyWithoutBusinessTypeInput
  }

  export type BusinessTypeCreateOrConnectWithoutDefaultsInput = {
    where: BusinessTypeWhereUniqueInput
    create: XOR<BusinessTypeCreateWithoutDefaultsInput, BusinessTypeUncheckedCreateWithoutDefaultsInput>
  }

  export type FeatureCreateWithoutDefaultsInput = {
    id?: string
    name: string
    description?: string | null
    explanation?: string | null
    isCountable?: boolean
    minCount?: number
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    calculations?: CalculationFeatureCreateNestedManyWithoutFeatureInput
    tiers?: FeatureTierCreateNestedManyWithoutFeatureInput
    group: FeatureGroupCreateNestedOneWithoutFeaturesInput
  }

  export type FeatureUncheckedCreateWithoutDefaultsInput = {
    id?: string
    groupId: string
    name: string
    description?: string | null
    explanation?: string | null
    isCountable?: boolean
    minCount?: number
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    calculations?: CalculationFeatureUncheckedCreateNestedManyWithoutFeatureInput
    tiers?: FeatureTierUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutDefaultsInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutDefaultsInput, FeatureUncheckedCreateWithoutDefaultsInput>
  }

  export type BusinessTypeUpsertWithoutDefaultsInput = {
    update: XOR<BusinessTypeUpdateWithoutDefaultsInput, BusinessTypeUncheckedUpdateWithoutDefaultsInput>
    create: XOR<BusinessTypeCreateWithoutDefaultsInput, BusinessTypeUncheckedCreateWithoutDefaultsInput>
    where?: BusinessTypeWhereInput
  }

  export type BusinessTypeUpdateToOneWithWhereWithoutDefaultsInput = {
    where?: BusinessTypeWhereInput
    data: XOR<BusinessTypeUpdateWithoutDefaultsInput, BusinessTypeUncheckedUpdateWithoutDefaultsInput>
  }

  export type BusinessTypeUpdateWithoutDefaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timelineDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pages?: BusinessTypePageUpdateManyWithoutBusinessTypeNestedInput
    calculations?: PricingCalculationUpdateManyWithoutBusinessTypeNestedInput
  }

  export type BusinessTypeUncheckedUpdateWithoutDefaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timelineDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pages?: BusinessTypePageUncheckedUpdateManyWithoutBusinessTypeNestedInput
    calculations?: PricingCalculationUncheckedUpdateManyWithoutBusinessTypeNestedInput
  }

  export type FeatureUpsertWithoutDefaultsInput = {
    update: XOR<FeatureUpdateWithoutDefaultsInput, FeatureUncheckedUpdateWithoutDefaultsInput>
    create: XOR<FeatureCreateWithoutDefaultsInput, FeatureUncheckedCreateWithoutDefaultsInput>
    where?: FeatureWhereInput
  }

  export type FeatureUpdateToOneWithWhereWithoutDefaultsInput = {
    where?: FeatureWhereInput
    data: XOR<FeatureUpdateWithoutDefaultsInput, FeatureUncheckedUpdateWithoutDefaultsInput>
  }

  export type FeatureUpdateWithoutDefaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isCountable?: BoolFieldUpdateOperationsInput | boolean
    minCount?: IntFieldUpdateOperationsInput | number
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculations?: CalculationFeatureUpdateManyWithoutFeatureNestedInput
    tiers?: FeatureTierUpdateManyWithoutFeatureNestedInput
    group?: FeatureGroupUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type FeatureUncheckedUpdateWithoutDefaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isCountable?: BoolFieldUpdateOperationsInput | boolean
    minCount?: IntFieldUpdateOperationsInput | number
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculations?: CalculationFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    tiers?: FeatureTierUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type BusinessTypeCreateWithoutPagesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    timelineDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaults?: BusinessTypeDefaultCreateNestedManyWithoutBusinessTypeInput
    calculations?: PricingCalculationCreateNestedManyWithoutBusinessTypeInput
  }

  export type BusinessTypeUncheckedCreateWithoutPagesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    timelineDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaults?: BusinessTypeDefaultUncheckedCreateNestedManyWithoutBusinessTypeInput
    calculations?: PricingCalculationUncheckedCreateNestedManyWithoutBusinessTypeInput
  }

  export type BusinessTypeCreateOrConnectWithoutPagesInput = {
    where: BusinessTypeWhereUniqueInput
    create: XOR<BusinessTypeCreateWithoutPagesInput, BusinessTypeUncheckedCreateWithoutPagesInput>
  }

  export type BusinessTypeUpsertWithoutPagesInput = {
    update: XOR<BusinessTypeUpdateWithoutPagesInput, BusinessTypeUncheckedUpdateWithoutPagesInput>
    create: XOR<BusinessTypeCreateWithoutPagesInput, BusinessTypeUncheckedCreateWithoutPagesInput>
    where?: BusinessTypeWhereInput
  }

  export type BusinessTypeUpdateToOneWithWhereWithoutPagesInput = {
    where?: BusinessTypeWhereInput
    data: XOR<BusinessTypeUpdateWithoutPagesInput, BusinessTypeUncheckedUpdateWithoutPagesInput>
  }

  export type BusinessTypeUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timelineDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaults?: BusinessTypeDefaultUpdateManyWithoutBusinessTypeNestedInput
    calculations?: PricingCalculationUpdateManyWithoutBusinessTypeNestedInput
  }

  export type BusinessTypeUncheckedUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timelineDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaults?: BusinessTypeDefaultUncheckedUpdateManyWithoutBusinessTypeNestedInput
    calculations?: PricingCalculationUncheckedUpdateManyWithoutBusinessTypeNestedInput
  }

  export type ServiceCreateWithoutCategoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceMin?: Decimal | DecimalJsLike | number | string | null
    priceMax?: Decimal | DecimalJsLike | number | string | null
    demoUrl?: string | null
    iconName?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceMin?: Decimal | DecimalJsLike | number | string | null
    priceMax?: Decimal | DecimalJsLike | number | string | null
    demoUrl?: string | null
    iconName?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreateOrConnectWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceCreateManyCategoryInputEnvelope = {
    data: ServiceCreateManyCategoryInput | ServiceCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutCategoryInput, ServiceUncheckedUpdateWithoutCategoryInput>
    create: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutCategoryInput, ServiceUncheckedUpdateWithoutCategoryInput>
  }

  export type ServiceUpdateManyWithWhereWithoutCategoryInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: UuidFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    slug?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    categoryId?: UuidFilter<"Service"> | string
    priceMin?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    priceMax?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    demoUrl?: StringNullableFilter<"Service"> | string | null
    iconName?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
  }

  export type ServiceCategoryCreateWithoutServicesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
  }

  export type ServiceCategoryUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
  }

  export type ServiceCategoryCreateOrConnectWithoutServicesInput = {
    where: ServiceCategoryWhereUniqueInput
    create: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCategoryUpsertWithoutServicesInput = {
    update: XOR<ServiceCategoryUpdateWithoutServicesInput, ServiceCategoryUncheckedUpdateWithoutServicesInput>
    create: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
    where?: ServiceCategoryWhereInput
  }

  export type ServiceCategoryUpdateToOneWithWhereWithoutServicesInput = {
    where?: ServiceCategoryWhereInput
    data: XOR<ServiceCategoryUpdateWithoutServicesInput, ServiceCategoryUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceCategoryUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFormStepCreateWithoutContactInput = {
    id?: string
    stepNumber: number
    stepData: JsonNullValueInput | InputJsonValue
    completedAt: Date | string
  }

  export type ContactFormStepUncheckedCreateWithoutContactInput = {
    id?: string
    stepNumber: number
    stepData: JsonNullValueInput | InputJsonValue
    completedAt: Date | string
  }

  export type ContactFormStepCreateOrConnectWithoutContactInput = {
    where: ContactFormStepWhereUniqueInput
    create: XOR<ContactFormStepCreateWithoutContactInput, ContactFormStepUncheckedCreateWithoutContactInput>
  }

  export type ContactFormStepCreateManyContactInputEnvelope = {
    data: ContactFormStepCreateManyContactInput | ContactFormStepCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type PricingCalculationCreateWithoutContactInput = {
    id?: string
    sessionId?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    calculationData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    features?: CalculationFeatureCreateNestedManyWithoutCalculationInput
    businessType: BusinessTypeCreateNestedOneWithoutCalculationsInput
  }

  export type PricingCalculationUncheckedCreateWithoutContactInput = {
    id?: string
    sessionId?: string | null
    businessTypeId: string
    totalPrice: Decimal | DecimalJsLike | number | string
    calculationData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    features?: CalculationFeatureUncheckedCreateNestedManyWithoutCalculationInput
  }

  export type PricingCalculationCreateOrConnectWithoutContactInput = {
    where: PricingCalculationWhereUniqueInput
    create: XOR<PricingCalculationCreateWithoutContactInput, PricingCalculationUncheckedCreateWithoutContactInput>
  }

  export type PricingCalculationCreateManyContactInputEnvelope = {
    data: PricingCalculationCreateManyContactInput | PricingCalculationCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type TimeSlotCreateWithoutContactInput = {
    id?: string
    date: Date | string
    time: Date | string
    isAvailable?: boolean
    createdAt?: Date | string
  }

  export type TimeSlotUncheckedCreateWithoutContactInput = {
    id?: string
    date: Date | string
    time: Date | string
    isAvailable?: boolean
    createdAt?: Date | string
  }

  export type TimeSlotCreateOrConnectWithoutContactInput = {
    where: TimeSlotWhereUniqueInput
    create: XOR<TimeSlotCreateWithoutContactInput, TimeSlotUncheckedCreateWithoutContactInput>
  }

  export type TimeSlotCreateManyContactInputEnvelope = {
    data: TimeSlotCreateManyContactInput | TimeSlotCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ContactFormStepUpsertWithWhereUniqueWithoutContactInput = {
    where: ContactFormStepWhereUniqueInput
    update: XOR<ContactFormStepUpdateWithoutContactInput, ContactFormStepUncheckedUpdateWithoutContactInput>
    create: XOR<ContactFormStepCreateWithoutContactInput, ContactFormStepUncheckedCreateWithoutContactInput>
  }

  export type ContactFormStepUpdateWithWhereUniqueWithoutContactInput = {
    where: ContactFormStepWhereUniqueInput
    data: XOR<ContactFormStepUpdateWithoutContactInput, ContactFormStepUncheckedUpdateWithoutContactInput>
  }

  export type ContactFormStepUpdateManyWithWhereWithoutContactInput = {
    where: ContactFormStepScalarWhereInput
    data: XOR<ContactFormStepUpdateManyMutationInput, ContactFormStepUncheckedUpdateManyWithoutContactInput>
  }

  export type ContactFormStepScalarWhereInput = {
    AND?: ContactFormStepScalarWhereInput | ContactFormStepScalarWhereInput[]
    OR?: ContactFormStepScalarWhereInput[]
    NOT?: ContactFormStepScalarWhereInput | ContactFormStepScalarWhereInput[]
    id?: UuidFilter<"ContactFormStep"> | string
    contactId?: UuidFilter<"ContactFormStep"> | string
    stepNumber?: IntFilter<"ContactFormStep"> | number
    stepData?: JsonFilter<"ContactFormStep">
    completedAt?: DateTimeFilter<"ContactFormStep"> | Date | string
  }

  export type PricingCalculationUpsertWithWhereUniqueWithoutContactInput = {
    where: PricingCalculationWhereUniqueInput
    update: XOR<PricingCalculationUpdateWithoutContactInput, PricingCalculationUncheckedUpdateWithoutContactInput>
    create: XOR<PricingCalculationCreateWithoutContactInput, PricingCalculationUncheckedCreateWithoutContactInput>
  }

  export type PricingCalculationUpdateWithWhereUniqueWithoutContactInput = {
    where: PricingCalculationWhereUniqueInput
    data: XOR<PricingCalculationUpdateWithoutContactInput, PricingCalculationUncheckedUpdateWithoutContactInput>
  }

  export type PricingCalculationUpdateManyWithWhereWithoutContactInput = {
    where: PricingCalculationScalarWhereInput
    data: XOR<PricingCalculationUpdateManyMutationInput, PricingCalculationUncheckedUpdateManyWithoutContactInput>
  }

  export type TimeSlotUpsertWithWhereUniqueWithoutContactInput = {
    where: TimeSlotWhereUniqueInput
    update: XOR<TimeSlotUpdateWithoutContactInput, TimeSlotUncheckedUpdateWithoutContactInput>
    create: XOR<TimeSlotCreateWithoutContactInput, TimeSlotUncheckedCreateWithoutContactInput>
  }

  export type TimeSlotUpdateWithWhereUniqueWithoutContactInput = {
    where: TimeSlotWhereUniqueInput
    data: XOR<TimeSlotUpdateWithoutContactInput, TimeSlotUncheckedUpdateWithoutContactInput>
  }

  export type TimeSlotUpdateManyWithWhereWithoutContactInput = {
    where: TimeSlotScalarWhereInput
    data: XOR<TimeSlotUpdateManyMutationInput, TimeSlotUncheckedUpdateManyWithoutContactInput>
  }

  export type TimeSlotScalarWhereInput = {
    AND?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
    OR?: TimeSlotScalarWhereInput[]
    NOT?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
    id?: UuidFilter<"TimeSlot"> | string
    date?: DateTimeFilter<"TimeSlot"> | Date | string
    time?: DateTimeFilter<"TimeSlot"> | Date | string
    isAvailable?: BoolFilter<"TimeSlot"> | boolean
    contactId?: UuidNullableFilter<"TimeSlot"> | string | null
    createdAt?: DateTimeFilter<"TimeSlot"> | Date | string
  }

  export type ContactCreateWithoutTimeSlotsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    company?: string | null
    projectType?: string | null
    budgetRange?: string | null
    timeline?: string | null
    description?: string | null
    preferredPackage?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formSteps?: ContactFormStepCreateNestedManyWithoutContactInput
    calculations?: PricingCalculationCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutTimeSlotsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    company?: string | null
    projectType?: string | null
    budgetRange?: string | null
    timeline?: string | null
    description?: string | null
    preferredPackage?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formSteps?: ContactFormStepUncheckedCreateNestedManyWithoutContactInput
    calculations?: PricingCalculationUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutTimeSlotsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutTimeSlotsInput, ContactUncheckedCreateWithoutTimeSlotsInput>
  }

  export type ContactUpsertWithoutTimeSlotsInput = {
    update: XOR<ContactUpdateWithoutTimeSlotsInput, ContactUncheckedUpdateWithoutTimeSlotsInput>
    create: XOR<ContactCreateWithoutTimeSlotsInput, ContactUncheckedCreateWithoutTimeSlotsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutTimeSlotsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutTimeSlotsInput, ContactUncheckedUpdateWithoutTimeSlotsInput>
  }

  export type ContactUpdateWithoutTimeSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preferredPackage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formSteps?: ContactFormStepUpdateManyWithoutContactNestedInput
    calculations?: PricingCalculationUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutTimeSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preferredPackage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formSteps?: ContactFormStepUncheckedUpdateManyWithoutContactNestedInput
    calculations?: PricingCalculationUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateWithoutFormStepsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    company?: string | null
    projectType?: string | null
    budgetRange?: string | null
    timeline?: string | null
    description?: string | null
    preferredPackage?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    calculations?: PricingCalculationCreateNestedManyWithoutContactInput
    timeSlots?: TimeSlotCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutFormStepsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    company?: string | null
    projectType?: string | null
    budgetRange?: string | null
    timeline?: string | null
    description?: string | null
    preferredPackage?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    calculations?: PricingCalculationUncheckedCreateNestedManyWithoutContactInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutFormStepsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutFormStepsInput, ContactUncheckedCreateWithoutFormStepsInput>
  }

  export type ContactUpsertWithoutFormStepsInput = {
    update: XOR<ContactUpdateWithoutFormStepsInput, ContactUncheckedUpdateWithoutFormStepsInput>
    create: XOR<ContactCreateWithoutFormStepsInput, ContactUncheckedCreateWithoutFormStepsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutFormStepsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutFormStepsInput, ContactUncheckedUpdateWithoutFormStepsInput>
  }

  export type ContactUpdateWithoutFormStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preferredPackage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculations?: PricingCalculationUpdateManyWithoutContactNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutFormStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preferredPackage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculations?: PricingCalculationUncheckedUpdateManyWithoutContactNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutContactNestedInput
  }

  export type CalculationFeatureCreateWithoutCalculationInput = {
    id?: string
    count?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    feature: FeatureCreateNestedOneWithoutCalculationsInput
    tier: FeatureTierCreateNestedOneWithoutCalculationsInput
  }

  export type CalculationFeatureUncheckedCreateWithoutCalculationInput = {
    id?: string
    featureId: string
    tierName: string
    count?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type CalculationFeatureCreateOrConnectWithoutCalculationInput = {
    where: CalculationFeatureWhereUniqueInput
    create: XOR<CalculationFeatureCreateWithoutCalculationInput, CalculationFeatureUncheckedCreateWithoutCalculationInput>
  }

  export type CalculationFeatureCreateManyCalculationInputEnvelope = {
    data: CalculationFeatureCreateManyCalculationInput | CalculationFeatureCreateManyCalculationInput[]
    skipDuplicates?: boolean
  }

  export type BusinessTypeCreateWithoutCalculationsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    timelineDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaults?: BusinessTypeDefaultCreateNestedManyWithoutBusinessTypeInput
    pages?: BusinessTypePageCreateNestedManyWithoutBusinessTypeInput
  }

  export type BusinessTypeUncheckedCreateWithoutCalculationsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    basePrice: Decimal | DecimalJsLike | number | string
    timelineDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaults?: BusinessTypeDefaultUncheckedCreateNestedManyWithoutBusinessTypeInput
    pages?: BusinessTypePageUncheckedCreateNestedManyWithoutBusinessTypeInput
  }

  export type BusinessTypeCreateOrConnectWithoutCalculationsInput = {
    where: BusinessTypeWhereUniqueInput
    create: XOR<BusinessTypeCreateWithoutCalculationsInput, BusinessTypeUncheckedCreateWithoutCalculationsInput>
  }

  export type ContactCreateWithoutCalculationsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    company?: string | null
    projectType?: string | null
    budgetRange?: string | null
    timeline?: string | null
    description?: string | null
    preferredPackage?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formSteps?: ContactFormStepCreateNestedManyWithoutContactInput
    timeSlots?: TimeSlotCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutCalculationsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    company?: string | null
    projectType?: string | null
    budgetRange?: string | null
    timeline?: string | null
    description?: string | null
    preferredPackage?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formSteps?: ContactFormStepUncheckedCreateNestedManyWithoutContactInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutCalculationsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCalculationsInput, ContactUncheckedCreateWithoutCalculationsInput>
  }

  export type CalculationFeatureUpsertWithWhereUniqueWithoutCalculationInput = {
    where: CalculationFeatureWhereUniqueInput
    update: XOR<CalculationFeatureUpdateWithoutCalculationInput, CalculationFeatureUncheckedUpdateWithoutCalculationInput>
    create: XOR<CalculationFeatureCreateWithoutCalculationInput, CalculationFeatureUncheckedCreateWithoutCalculationInput>
  }

  export type CalculationFeatureUpdateWithWhereUniqueWithoutCalculationInput = {
    where: CalculationFeatureWhereUniqueInput
    data: XOR<CalculationFeatureUpdateWithoutCalculationInput, CalculationFeatureUncheckedUpdateWithoutCalculationInput>
  }

  export type CalculationFeatureUpdateManyWithWhereWithoutCalculationInput = {
    where: CalculationFeatureScalarWhereInput
    data: XOR<CalculationFeatureUpdateManyMutationInput, CalculationFeatureUncheckedUpdateManyWithoutCalculationInput>
  }

  export type BusinessTypeUpsertWithoutCalculationsInput = {
    update: XOR<BusinessTypeUpdateWithoutCalculationsInput, BusinessTypeUncheckedUpdateWithoutCalculationsInput>
    create: XOR<BusinessTypeCreateWithoutCalculationsInput, BusinessTypeUncheckedCreateWithoutCalculationsInput>
    where?: BusinessTypeWhereInput
  }

  export type BusinessTypeUpdateToOneWithWhereWithoutCalculationsInput = {
    where?: BusinessTypeWhereInput
    data: XOR<BusinessTypeUpdateWithoutCalculationsInput, BusinessTypeUncheckedUpdateWithoutCalculationsInput>
  }

  export type BusinessTypeUpdateWithoutCalculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timelineDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaults?: BusinessTypeDefaultUpdateManyWithoutBusinessTypeNestedInput
    pages?: BusinessTypePageUpdateManyWithoutBusinessTypeNestedInput
  }

  export type BusinessTypeUncheckedUpdateWithoutCalculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timelineDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaults?: BusinessTypeDefaultUncheckedUpdateManyWithoutBusinessTypeNestedInput
    pages?: BusinessTypePageUncheckedUpdateManyWithoutBusinessTypeNestedInput
  }

  export type ContactUpsertWithoutCalculationsInput = {
    update: XOR<ContactUpdateWithoutCalculationsInput, ContactUncheckedUpdateWithoutCalculationsInput>
    create: XOR<ContactCreateWithoutCalculationsInput, ContactUncheckedCreateWithoutCalculationsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutCalculationsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutCalculationsInput, ContactUncheckedUpdateWithoutCalculationsInput>
  }

  export type ContactUpdateWithoutCalculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preferredPackage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formSteps?: ContactFormStepUpdateManyWithoutContactNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutCalculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: NullableStringFieldUpdateOperationsInput | string | null
    budgetRange?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preferredPackage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formSteps?: ContactFormStepUncheckedUpdateManyWithoutContactNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutContactNestedInput
  }

  export type PricingCalculationCreateWithoutFeaturesInput = {
    id?: string
    sessionId?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    calculationData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    businessType: BusinessTypeCreateNestedOneWithoutCalculationsInput
    contact?: ContactCreateNestedOneWithoutCalculationsInput
  }

  export type PricingCalculationUncheckedCreateWithoutFeaturesInput = {
    id?: string
    sessionId?: string | null
    businessTypeId: string
    totalPrice: Decimal | DecimalJsLike | number | string
    calculationData: JsonNullValueInput | InputJsonValue
    contactId?: string | null
    createdAt?: Date | string
  }

  export type PricingCalculationCreateOrConnectWithoutFeaturesInput = {
    where: PricingCalculationWhereUniqueInput
    create: XOR<PricingCalculationCreateWithoutFeaturesInput, PricingCalculationUncheckedCreateWithoutFeaturesInput>
  }

  export type FeatureCreateWithoutCalculationsInput = {
    id?: string
    name: string
    description?: string | null
    explanation?: string | null
    isCountable?: boolean
    minCount?: number
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaults?: BusinessTypeDefaultCreateNestedManyWithoutFeatureInput
    tiers?: FeatureTierCreateNestedManyWithoutFeatureInput
    group: FeatureGroupCreateNestedOneWithoutFeaturesInput
  }

  export type FeatureUncheckedCreateWithoutCalculationsInput = {
    id?: string
    groupId: string
    name: string
    description?: string | null
    explanation?: string | null
    isCountable?: boolean
    minCount?: number
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaults?: BusinessTypeDefaultUncheckedCreateNestedManyWithoutFeatureInput
    tiers?: FeatureTierUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutCalculationsInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutCalculationsInput, FeatureUncheckedCreateWithoutCalculationsInput>
  }

  export type FeatureTierCreateWithoutCalculationsInput = {
    id?: string
    tierName: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    feature: FeatureCreateNestedOneWithoutTiersInput
  }

  export type FeatureTierUncheckedCreateWithoutCalculationsInput = {
    id?: string
    featureId: string
    tierName: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureTierCreateOrConnectWithoutCalculationsInput = {
    where: FeatureTierWhereUniqueInput
    create: XOR<FeatureTierCreateWithoutCalculationsInput, FeatureTierUncheckedCreateWithoutCalculationsInput>
  }

  export type PricingCalculationUpsertWithoutFeaturesInput = {
    update: XOR<PricingCalculationUpdateWithoutFeaturesInput, PricingCalculationUncheckedUpdateWithoutFeaturesInput>
    create: XOR<PricingCalculationCreateWithoutFeaturesInput, PricingCalculationUncheckedCreateWithoutFeaturesInput>
    where?: PricingCalculationWhereInput
  }

  export type PricingCalculationUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: PricingCalculationWhereInput
    data: XOR<PricingCalculationUpdateWithoutFeaturesInput, PricingCalculationUncheckedUpdateWithoutFeaturesInput>
  }

  export type PricingCalculationUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessType?: BusinessTypeUpdateOneRequiredWithoutCalculationsNestedInput
    contact?: ContactUpdateOneWithoutCalculationsNestedInput
  }

  export type PricingCalculationUncheckedUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    businessTypeId?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationData?: JsonNullValueInput | InputJsonValue
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureUpsertWithoutCalculationsInput = {
    update: XOR<FeatureUpdateWithoutCalculationsInput, FeatureUncheckedUpdateWithoutCalculationsInput>
    create: XOR<FeatureCreateWithoutCalculationsInput, FeatureUncheckedCreateWithoutCalculationsInput>
    where?: FeatureWhereInput
  }

  export type FeatureUpdateToOneWithWhereWithoutCalculationsInput = {
    where?: FeatureWhereInput
    data: XOR<FeatureUpdateWithoutCalculationsInput, FeatureUncheckedUpdateWithoutCalculationsInput>
  }

  export type FeatureUpdateWithoutCalculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isCountable?: BoolFieldUpdateOperationsInput | boolean
    minCount?: IntFieldUpdateOperationsInput | number
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaults?: BusinessTypeDefaultUpdateManyWithoutFeatureNestedInput
    tiers?: FeatureTierUpdateManyWithoutFeatureNestedInput
    group?: FeatureGroupUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type FeatureUncheckedUpdateWithoutCalculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isCountable?: BoolFieldUpdateOperationsInput | boolean
    minCount?: IntFieldUpdateOperationsInput | number
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaults?: BusinessTypeDefaultUncheckedUpdateManyWithoutFeatureNestedInput
    tiers?: FeatureTierUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureTierUpsertWithoutCalculationsInput = {
    update: XOR<FeatureTierUpdateWithoutCalculationsInput, FeatureTierUncheckedUpdateWithoutCalculationsInput>
    create: XOR<FeatureTierCreateWithoutCalculationsInput, FeatureTierUncheckedCreateWithoutCalculationsInput>
    where?: FeatureTierWhereInput
  }

  export type FeatureTierUpdateToOneWithWhereWithoutCalculationsInput = {
    where?: FeatureTierWhereInput
    data: XOR<FeatureTierUpdateWithoutCalculationsInput, FeatureTierUncheckedUpdateWithoutCalculationsInput>
  }

  export type FeatureTierUpdateWithoutCalculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feature?: FeatureUpdateOneRequiredWithoutTiersNestedInput
  }

  export type FeatureTierUncheckedUpdateWithoutCalculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureId?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureCreateManyGroupInput = {
    id?: string
    name: string
    description?: string | null
    explanation?: string | null
    isCountable?: boolean
    minCount?: number
    displayOrder?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isCountable?: BoolFieldUpdateOperationsInput | boolean
    minCount?: IntFieldUpdateOperationsInput | number
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaults?: BusinessTypeDefaultUpdateManyWithoutFeatureNestedInput
    calculations?: CalculationFeatureUpdateManyWithoutFeatureNestedInput
    tiers?: FeatureTierUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isCountable?: BoolFieldUpdateOperationsInput | boolean
    minCount?: IntFieldUpdateOperationsInput | number
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaults?: BusinessTypeDefaultUncheckedUpdateManyWithoutFeatureNestedInput
    calculations?: CalculationFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    tiers?: FeatureTierUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isCountable?: BoolFieldUpdateOperationsInput | boolean
    minCount?: IntFieldUpdateOperationsInput | number
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeDefaultCreateManyFeatureInput = {
    id?: string
    businessTypeId: string
    defaultTier: string
    defaultCount?: number
    createdAt?: Date | string
  }

  export type CalculationFeatureCreateManyFeatureInput = {
    id?: string
    calculationId: string
    tierName: string
    count?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type FeatureTierCreateManyFeatureInput = {
    id?: string
    tierName: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessTypeDefaultUpdateWithoutFeatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultTier?: StringFieldUpdateOperationsInput | string
    defaultCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessType?: BusinessTypeUpdateOneRequiredWithoutDefaultsNestedInput
  }

  export type BusinessTypeDefaultUncheckedUpdateWithoutFeatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    defaultTier?: StringFieldUpdateOperationsInput | string
    defaultCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeDefaultUncheckedUpdateManyWithoutFeatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessTypeId?: StringFieldUpdateOperationsInput | string
    defaultTier?: StringFieldUpdateOperationsInput | string
    defaultCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalculationFeatureUpdateWithoutFeatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculation?: PricingCalculationUpdateOneRequiredWithoutFeaturesNestedInput
    tier?: FeatureTierUpdateOneRequiredWithoutCalculationsNestedInput
  }

  export type CalculationFeatureUncheckedUpdateWithoutFeatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    calculationId?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CalculationFeatureUncheckedUpdateManyWithoutFeatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    calculationId?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type FeatureTierUpdateWithoutFeatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculations?: CalculationFeatureUpdateManyWithoutTierNestedInput
  }

  export type FeatureTierUncheckedUpdateWithoutFeatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculations?: CalculationFeatureUncheckedUpdateManyWithoutTierNestedInput
  }

  export type FeatureTierUncheckedUpdateManyWithoutFeatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalculationFeatureCreateManyTierInput = {
    id?: string
    calculationId: string
    count?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type CalculationFeatureUpdateWithoutTierInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculation?: PricingCalculationUpdateOneRequiredWithoutFeaturesNestedInput
    feature?: FeatureUpdateOneRequiredWithoutCalculationsNestedInput
  }

  export type CalculationFeatureUncheckedUpdateWithoutTierInput = {
    id?: StringFieldUpdateOperationsInput | string
    calculationId?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CalculationFeatureUncheckedUpdateManyWithoutTierInput = {
    id?: StringFieldUpdateOperationsInput | string
    calculationId?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BusinessTypeDefaultCreateManyBusinessTypeInput = {
    id?: string
    featureId: string
    defaultTier: string
    defaultCount?: number
    createdAt?: Date | string
  }

  export type BusinessTypePageCreateManyBusinessTypeInput = {
    id?: string
    pageType: string
    pageName: string
    isDefault?: boolean
    displayOrder?: number | null
    createdAt?: Date | string
  }

  export type PricingCalculationCreateManyBusinessTypeInput = {
    id?: string
    sessionId?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    calculationData: JsonNullValueInput | InputJsonValue
    contactId?: string | null
    createdAt?: Date | string
  }

  export type BusinessTypeDefaultUpdateWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultTier?: StringFieldUpdateOperationsInput | string
    defaultCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feature?: FeatureUpdateOneRequiredWithoutDefaultsNestedInput
  }

  export type BusinessTypeDefaultUncheckedUpdateWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureId?: StringFieldUpdateOperationsInput | string
    defaultTier?: StringFieldUpdateOperationsInput | string
    defaultCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypeDefaultUncheckedUpdateManyWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureId?: StringFieldUpdateOperationsInput | string
    defaultTier?: StringFieldUpdateOperationsInput | string
    defaultCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypePageUpdateWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageType?: StringFieldUpdateOperationsInput | string
    pageName?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypePageUncheckedUpdateWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageType?: StringFieldUpdateOperationsInput | string
    pageName?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessTypePageUncheckedUpdateManyWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageType?: StringFieldUpdateOperationsInput | string
    pageName?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingCalculationUpdateWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: CalculationFeatureUpdateManyWithoutCalculationNestedInput
    contact?: ContactUpdateOneWithoutCalculationsNestedInput
  }

  export type PricingCalculationUncheckedUpdateWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationData?: JsonNullValueInput | InputJsonValue
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: CalculationFeatureUncheckedUpdateManyWithoutCalculationNestedInput
  }

  export type PricingCalculationUncheckedUpdateManyWithoutBusinessTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationData?: JsonNullValueInput | InputJsonValue
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateManyCategoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceMin?: Decimal | DecimalJsLike | number | string | null
    priceMax?: Decimal | DecimalJsLike | number | string | null
    demoUrl?: string | null
    iconName?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceMax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFormStepCreateManyContactInput = {
    id?: string
    stepNumber: number
    stepData: JsonNullValueInput | InputJsonValue
    completedAt: Date | string
  }

  export type PricingCalculationCreateManyContactInput = {
    id?: string
    sessionId?: string | null
    businessTypeId: string
    totalPrice: Decimal | DecimalJsLike | number | string
    calculationData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TimeSlotCreateManyContactInput = {
    id?: string
    date: Date | string
    time: Date | string
    isAvailable?: boolean
    createdAt?: Date | string
  }

  export type ContactFormStepUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    stepData?: JsonNullValueInput | InputJsonValue
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFormStepUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    stepData?: JsonNullValueInput | InputJsonValue
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFormStepUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    stepData?: JsonNullValueInput | InputJsonValue
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingCalculationUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: CalculationFeatureUpdateManyWithoutCalculationNestedInput
    businessType?: BusinessTypeUpdateOneRequiredWithoutCalculationsNestedInput
  }

  export type PricingCalculationUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    businessTypeId?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: CalculationFeatureUncheckedUpdateManyWithoutCalculationNestedInput
  }

  export type PricingCalculationUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    businessTypeId?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculationData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeSlotUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeSlotUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeSlotUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalculationFeatureCreateManyCalculationInput = {
    id?: string
    featureId: string
    tierName: string
    count?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type CalculationFeatureUpdateWithoutCalculationInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feature?: FeatureUpdateOneRequiredWithoutCalculationsNestedInput
    tier?: FeatureTierUpdateOneRequiredWithoutCalculationsNestedInput
  }

  export type CalculationFeatureUncheckedUpdateWithoutCalculationInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureId?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CalculationFeatureUncheckedUpdateManyWithoutCalculationInput = {
    id?: StringFieldUpdateOperationsInput | string
    featureId?: StringFieldUpdateOperationsInput | string
    tierName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}